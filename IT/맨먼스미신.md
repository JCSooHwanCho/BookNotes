# 책 제목 : 맨먼스 미신

저자 : 프레더릭 브룩스  
역자 : 강중빈
출판사 : 인사이트  
출판년월 : 15/3  
페이지 : 362  

- - - -

* **프로그래밍을 관리하는 것은 왜 어려운가?**
	1. 대규모 프로젝트는 업무 분배 때문에 소규모 프로젝트에는 없던 관리 문제가 생긴다.  
	2. 많은 사람의 의견이 모이기 때문에, 제품 자체의 개념적 일관성을 유지하기 어렵다.  

## 1. 타르 구덩이

* 대규모 시스템 프로그래밍은 마치 타르 구덩이 같다.  
	1. 수많은 실력자들이 그 속에 빠져서 헤어나오기 힘들다.
	2. 어떻게 빠져 나오더라도 목표,일정,예산을 충족하는 경우는 드물다.  
	3. 타르 속에서는 멀쩡히 움직일 수 있는 것 처럼, 실패의 원인을 지목하기도 어렵지만, 여러 요인들이 동시 다발적이고 상호적으로 작용하면서 지나치게 복잡해진다.
		* 문제를 해결하기 위해서는 문제의 본질이 먼지 이해하려고 노력해야 한다.  
* 프로그래머(혹은 개발팀)이 만드는 것은 무엇인가?  
	1. 프로그램 : 자체적으로 완결적이고, 개발된 장비에서 개발한 사람에 의해 실행이 가능한 것  
		* 프로그래머 개인의 생산성 추정을 할 때 사용되는 것  
	2. 프로그래밍 제품 : 프로그램이 일반화 된 것. 누구든지 테스트,보수, 확장할 수 있고, 다양한 환경에서 여러 데이터에 적용될 수 있어야 한다.  
					* 일반화, 테스트, 문서화가 모두 철저히 이루어져야 한다.  
	3. 프로그래밍 시스템 : 상호 작용하는 여러 프로그램의 묶음, 다 합쳐진 상태에서 대규모 작업을 수행할 수 있게 만든 것  
		* 개별 프로그램은 시스템에서 정의한 인터페이스를 반드시 따라야만 한다.  
		* 규정된 자원만 사용하도록 섬세하게 설계되어야 한다.  
		* 다른 구성요소들과 조합 가능한 모든 경우에 대해 테스트 되어야 하며, 테스트가 제대로 되었다 해도 예기치 못한 상호작용으로 인한 문제가 일어날 수 있기 때문에 테스트에 드는 시간도 많이 든다.  
	4. 프로그래밍 시스템 제품 : 프로그래밍 시스템 + 프로그래밍 제품  
		* 대다수 시스템 프로그래밍이 목표로 하는 결과물  
* 프로그래밍은 왜 재미있는가?  
	1. 무언가를 만드는 데서 오는 순전한 기쁨  
	2. 다른 이들에게 쓸모있는 사물을 만드는 데서 오는 기쁨  
	3. 복잡한 퍼즐같은 것들이 그 안에 있는 법칙들에 따라 미묘한 순환을 이루며 돌아가는 것을 보는 매혹적인 경험  
	4. 지속적인 배움에서 오는 기쁨  
	5. 너무나도 유연하고 다루기 쉬운 표현 수단으로 작업하는 데서 오는 기쁨  
* 프로그래밍은 왜 고달픈가?  
	1. 완벽함이 요구된다.  
	2. 다른 사람들이 내 목표를 설정하고 자원과 정보를 제공한다.
	3. 다른 사람이 만든 프로그램에 대한 의존성을 해결하느라 시간이 허비된다  
	4. 장대한 개념을 설계하는 것은 재밌지만, 버그 잡는 것은 그저 일일 뿐이다.  
	5. 힘들게 만든 제품이 완성되었을 때, 혹은 완성되기도 전에 한 물 가서 퇴출되버린다.  
* 우리의 도전과 임무는 가용한 자원으로 실질적인 일정 내에서 현실의 문제에 대한 현실적인 해법을 찾는 데 있다.  

## 2. 맨먼스 미신
* 부족한 시간 탓에 망가진 소프트웨어 프로젝트 수는 다른 이유로 그렇게 된 경우보다 훨씬 많다.  
	1. 우리의 추정 능력은 형편없다. 거기에 사실에 기반하지 않은 지나친 낙관이 반영되어 있기까지 하다.  
	2. 투입 공수(맨먼스)와 작업 진척도를 혼동한다. 즉 사람을 많이 투입하면 일이 빨리 끝날거라 생각한다.  
	3. 추정에 대한 자기 확신이 없기에, 정중한 고집이 결여되어 있다.  
	4. 일정 진척도가 제대로 모니터링 되고 있지 않다.  
	5. 일정이 어긋나는 것을 감지했을 때의 자연스러운 대응 방법이 인원 충원이다.  
* 프로그래머들은 다들 낙관성을 가지고 있다. 이러한 낙관론은 모든 작업이 예정내에 완료될 것이다’란 잘못된 가정의 원인이 된다.  
	* 아이디어는 그 자체가 결함이 있더라도, 구현되지 않으면 그 결함이 드러나지 않는다. 그래서 실제로 구현을 해보는 것은 필수적이다.
	* 프로그래밍의 재료는 다른 창작활동의 재료보다 다루기가 훨씬 쉽기 때문에, 구현도 쉬울 것이라고 오해한다. 하지만 아이디어 자체의 결함이 있을 수 있기에 버그는 필연적이고, 이러한 낙관주의는 정당성이 없어진다.  
	* 한 작업이 제대로 되더라도 다른 작업이 모두 일정에 맞출 가능성은 한없이 낮다
* 맨먼스는 비용 추산 지표일 뿐, 이것으로 작업 진척도를 잰다는 것은 위험하고 기만적인 미신이다.  
	* 사람과 일정이 교환 가능하기 위해서는 분업이 용이하고, 서로 소통할 필요가 없는 경우다. 시스템 프로그래밍은 이 두가지 모두 해당하지 않는다.  
		* 분업이 용이하지 않은 경우 : 각 작업 간에 의존성이 존재한다.  
		* 소통할 필요가 있는 경우 : 소통에 들어가는 비용 또한 전체 작업 계산에 포함되어야 한다. 소통은 훈련이 필요하고, 소통 자체에 들어가는 부담은 분업을 통해 얻을 수 있는 이득을 상회하기도 한다.  
	* 소프트워어 개발은 원래가 복잡한 상호 연관성을 가진 활동이기 때문에 사람을 더 투입하면 오히려 일정을 늘어지게 만든다.  
* 시스템에 대한 테스트는 쉽게 간과되기 때문에, 일정 예측이 빗나가는데 가장 큰 지분을 차지한다.  
	* 시스템 테스트에 충분한 시간을 배정하지 않으면, 결국 그 배정하지 않은 시간만큼 일정을 지연시키게 된다. 따라서 테스트에는 충분한 시간을 할애해야 한다.  (저자는 구성 요소 테스트&초기 테스트에 1/4, 전체 시스템 테스트에 1/4로 총 1/2의 시간을 할당하고, 1/3을 계획수립, 1/6의 시간만 코딩에 할당)  
	* 특히 프로젝트 말미에는 여러가지 관련 작업이 동시에 돌아가야 하기 때문에, 일정이 지연되면 2차적인 비용이 더 커지게 된다.  
* 고객의 긴급한 요청등에 의해 일정이 앞당겨 질 수도 있다. 하지만 그렇다고 그만큼 일이 빨리 진행되는 것은 아니고, 앞당겨진 일정만큼의 업무는 하지 않은 상태로 남아버린다.  
	* 이는 정량적인 추정을 하지않고, 이 추정을 뒷받침할 데이터가 없고 대부분 관리자들의 예감과 경험에 의존하기 때문에 이 추정을 적극적으로 방어할 수 없기 때문이다.  
	* 이를 해결하기 위해서는 생산성 수치, 버그 발생률, 추정 원칙등을 도입해 추정의 기반이 견고해져야 하고, 관리자들은 그 기반이 견고해질 때까지는 스스로가 당당하게 추정치를 방어해야 한다.  
* 어떤 프로젝트가 일정에 뒤쳐지고 있을 때, 원래의 계획에 맞추기 위해 섣불리 인력을 투자하는 행위는 무조건 원하는 결과를 얻어내지 못한다.  
	* 새로 투입된 멤버가 바로 일할 수는 없다. 기존 멤버에게 훈련을 받아야하고, 그 기간동안은 기존 멤버도 일을 제대로 할 수 없다. 또 기존 인원에 맞게 분할된 일을 다시 나눠야 하므로, 진행된 작업 중 일부는 재사용이 불가능해 날리게 될 것이다. 결국 인원을 늘려도 일정에 맞추는 것은 요원하기만 하다.  
		* 일정에 맞추지 못했기 때문에, 관리자는 더 많은 인원을 투입하려는 유혹에 빠지게 된다. 하지만 이는 다시 위의 문제를 일으키고, 프로젝트는 점점 더 악화된다.  
		* 이렇게 거듭되는 문제 끝에 나온 결과물은, 원래 인원을 유지하며 일정을 재수립했을 때보다 더 못하리라는 것은 자명하다.  
	* **늦어진 소프트웨어 프로젝트에 인력을 추가로 투입하면 더 늦어지게 된다.**  
* 프로젝트에 소요되는 기간은 순서대로 처리해야하는 내부 요소에 좌우되며, 필요한 최대 인원수는 독립된 하위 작업의 개수에 좌우된다. 무조건 인원이 많다고, 시간이 부족하단 이유로 재촉한다고 일이 잘되는 게 아니다.  
	* 이 두가지 수치를 파악해야지만 관리자는 더 적은 수의 사람과 더 긴 기간에 기초한 합리적인 일정을 수립할 수 있다.  
	* 그래도 제품이 시대에 뒤쳐지는 것은 어쩔 수 없지만…

## 3. 외과 수술 팀

* 작은 팀 vs 큰 팀, 어떤 것이 답일까?  
	1. 효율적 개념과 일관성을 위해서는 적은 인원으로 팀을 구성하는 게 훨씬 낫다.
	2. 하지만 아무리 뛰어난 프로그래머들을 모아놓아도 작은 팀이라면 큰 시스템을 의미있는 시간내에 만들어 내지 못한다. 큰 시스템은 원래 만드는 데 많은 작업이 필요한 법이다.  
* 할란 밀스(Halan Mills)의 해결책 : 커다란 전체 업무를 여러 팀에 나눠 맡기되, 각 팀을 외과 수술 팀 처럼 조직하라.  
	* 즉, 한 명이 주도적으로 문제를 해결해 가는 동안, 다른 사람은 그 사람의 효율과 생산성을 높이기 위해 지원하는 체제  
	* 이 방법이면 설계와 구축에 적은 인원이 들어가면서, 작업에는 많은 인원이 투입되게 된다.  
* 일을 어떻게 나누고, 어떤 역할을 부여할 것인가?  
	1. 외과의(수석 프로그래머) : 기능과 성능 명세를 직접 정의하며, 설계, 코딩,테스트, 문서화 등 모든 작업에 관여한다. 재능, 경력, 시스템 및 응용 분야에 대한 지식 등에서 상당한 수준이 요구된다.  
	2. 부조종사 : 외과의의 분신, 올라운더지만 경험이 많지는 않다. 주 역할은 설계 과정에 참여하여 같이 고민하고 토론하고 평가하는 것이다. 종종 팀을 대표하기도 하며, 모든 코드를 파악하고 대안적 설계에 대한 전략을 연구한다. 코드를 만들수도 있지만 책임은 지지 않는다.  
	3. 행정 담당 : 외과의를 대신해 행정 업무를 수행하는 사람. 다만, 꼭 필요한 경우에만(법률적, 계약적 중대 사안이 있는 경우, 보고를 강화해야 하거나, 재무적 이슈가 있을때) 전일제로 두어야 한명의 행정 담당이 여러 팀에 걸칠 수도 있다.  
	4. 편집자 : 외과의가 작성한 초안이나 구술 원고를 비평,수정,보충,관리하는 등의 역할  
	5. 비서 : 행정 담당과 편집자 각각 한 명씩, 총 두 명의 비서가 필요하다. 프로젝트 관련 우편물과 일반적인 업무 서류를 담당한다.  
	6. 프로그램 사무원 : 팀에서 생산되는 모든 기술적 산출물을 하나의 프로그래밍 제품 라이브러리로 관리할 책임을 진다. 기계가 읽을 파일과 사람이 읽기 위한 파일 모두 담당한다. 팀의 반복적인 사무 작업을 덜어주고 등한시되는 그런 작업들이 잘 진행되도록 하여, 작업 산출물을 향상 시킨다.  
				* 핵심은 프로그래밍이라는 작업을 ‘개인적인 예술’에서 ‘공개적인 실행’으로 바꾸는 것이다.  
	7. 도구 담당 : 이전처럼 팀별로 자체적인 장비와 운영요원을 필요로 하지는 않는 시대지만, 외과의를 대신하여 팀 전체가 사용하는 도구들이 적합한지 확인해주고, 팀 자체적인 도구들을 구축하고 유지보수하는 사람은 반드시 필요하다.  
	8. 테스터 : 테스트 케이스를 만들고, 테스트 데이터를 제공한다. 또한 테스트 순서를 계획하고, 구성 요소를 테스트를 위한 얼개를 짜기도 한다.  
	9. 언어 마스터 : 새로운 언어를 익히고 복잡한 문제에 대해 특정 언어를 사용한 더 깔끔하고 효율적인 방법을 연구한다. 여러 팀에 걸쳐 자문역할을 하기도 한다.  
* 이러한 팀은 동등한 지위를 가지고 분업하는 팀과 다르게 다음과 같은 이유로 한 사람처럼 행동할 수 있게 된다.  
	1. 외과의와 부조종사 모두 전체 설계와 구현을 다 알고 있으므로, 서로 조율하는 수고가 줄어들고, 개념적 일관성 또한 보장된다.  
	2. 팀 안에서의 불가피한 의견 차이가 외과의에 의해 일방적으로 정리된다.  
* 대규모 작업에서는 10명 가지고는 안되지만, 여러 외과의 팀이 모이면 이러한 작업이 가능하다. 각 부분의 개념적 일관성이 보장이 되었기 때문에, 각 외과의들간의 조율 문제만 해결하면 되는 것이다.  
* 하지만 이 외과의들 간의 조율에는 또 다른 기법이 필요하다. 우선은 ‘전체 시스템 역시 개념적 일관성을 가져야 하고, 한명의 시스템 아키텍트가 시스템 전부를 하향식으로 설계할 필요가 있다’라고 요약된다.  
* 이를 위해서는 구현과 아키텍처를 명확히 구분해야 하고, 시스템 아키텍트는 자신의 역할을 철저히 아키텍처 쪽으로만 국한해야한다.  

## 4. 귀족 정치, 민주주의, 시스템 설계

* 시스템 설계에서 가장 중요하게 고려되어야 할 것은 바로 **개념적 일관성**이다. 아무리 좋더라도 연관성 없고 조율도 안된 기능들을 넣기보다, 일련의 설계사상을 고수하는 편이 낫다.  
* 개념적 일관성 얻기  
	* 프로그래밍 시스템은 컴퓨터를 쉽게 사용하게 하기 위함이기 때문에, 기능과 개념적 복잡성의 비율은 시스템 설계의 최종적 기준이 된다. 둘 중 하나만으로는 좋은 설계가 나올 수 없다.  
	* 즉, 일정 수준의 기능을 제공한다는 가정하에서, 최대한 단순하고 명확하게 사용할 수 있는 시스템이 최상이다.  
	* 단순함과 명확성은 개념적 일관성에서 온다.  
	* 사용의 용이성을 추구하는 것이 곧 설계의 통일성과 개념적 일관성을 가져오게 된다.  
* 개념적 일관성은 곧 시스템 설계를 한명 또는 생각을 같이하는 극소수가 하도록 유도한다.  
	* 하지만 일정 압박 때문에 시스템 구축에는 많은 사람이 필요하게 된다.  
		1. 아키텍쳐와 구현을 주의깊게 나누는 방법으로 해결  
		2. 프로그래밍 구현팀의 구성에 새로운 방식(외과의 팀)을 적용하는 것으로 해결  
* 아키텍쳐와 구현을 분리하라  
	* 아키텍쳐 : 사용자 인터페이스의 완전하고도 상세한 명세  
	* 아키텍트 : 사용자의 대리자로써 사용자의 이해만을 대변하기 위해 전문적이고 기술적인 지식을 동원하는 역할을 맡는다.  
	* 아키텍쳐가 ‘무슨 일이 일어날 지’ 정하는 것이라면, 구현은 그것이 ‘어떻게 현실화 되는지’를 정한다.  
	* 물론 아키텍트들만이 참신한 생각을 할 수 있다는 것은 아니다. 하지만, 아무리 훌륭한 기능이나 아이디어도 시스템의 기본 개념에 들어맞지 않는다면 배제하는 것이 상책이다. 이미 너무 많은 아이디어들이 기본 개념에 맞지 않게 들어가 있다면, 전체 설계를 폐기하고 기본 개념을 바꾸고 다시 시작하는게 낫다.  
	* 아키텍트는 소수여야 하고, 그들의 결과물은 구현자들의 것들보다 오래 지속되어야만 한다. 또한 모든 힘겨루기의 중심에서, 사용자의 이해를 대변하여 그 힘들을 중재할 사람은 결국 아키텍트다. 개념적 일관성을 위해서는 누군가가 개념을 통제해야 하며, 이것은 귀족 정치라고 비난받을 대상이 아니다.  
	* 그렇다고 아키텍트의 업무가 구현작업보다 더 창조적이지는 않다. 시스템의 외부 명세를 따라 구현 방안을 설계하는 것은, 외부 명세 설계 만큼이나 많은 창의력과 새로운 아이디어, 기술적 탁월성을 요구한다.  
	* 예술이나 공예 분야에서 절제가 미덕이라고 믿을 만한 사례가 다수 있다.
	> “형식이 자유롭게 한다.”  
	* 제약이 없으면 대부분의 고민과 토론이 아키텍쳐 결정에 관한 방향으로 흘러가며, 본래 의미의 구현 작업은 관심에서 멀어진다.  
* **구현자들의 반론과 이에 대한 반박**
	1. 명세에 너무 많은 기능이 포함될 것이며, 비용에 대한 현실적인 고려도 미비할 것이다.  
		* 정말로 위험한 상황이다. 이후 장에서 이에 대해 논의할 것이다.  
	2. 창조적인 즐거움은 모두 아키텍트 몫이 되고 구현자들의 독창성은 배제될 것이다.  
		* 구현 작업 역시 아키텍쳐 설계에 버금가는 창의적 행위이다. 오히려 명세에 맞춰 작업하는 것이 오히려 창조 수준이 높아질 수도 있다.  
	3. 아키텍쳐팀이 명세를 완성할 때 까지, 많은 구현자들은 하는 일 없이 앉아 있어야 할 것이다.  
		* 타이밍과 단계적 실행의 문제다. 명세가 완성되기 전까지는 구현자들을 배정하지 말아라.  
		* 하지만 이 분야는 일 진행이 빠르고 가능하면 일정을 많이 당기려고 한다. 즉, 병렬적으로 할 수 있는 일은 병렬적으로 해야만 한다.  
		* 창조적 작업은 아키텍처, 구현, 제품화의 단계를 거치는데, 이 과정은 같이 시작해서 동시에 진행이 가능함이 밝혀지고있다. 즉 각 단계는 다른 단계에 의존하지 않는 부분이 많이 있다.  
		* 폭넓게 수평적으로 나뉜 일이 수직적 분업에 의해 대폭 줄어들게 되고, 그 결과는 극단적으로 단순화 된 커뮤니케이션과 향상된 개념적 일관성으로 나타난다.  

## 5. 두번째 시스템 효과

* **기능 명세의 책임과 빠르고 저렴한 제품 구현의 책임이 분리되어 있다면 아키텍트의 창의적인 열정을 제어할 방법은 무엇인가?**
	* 근본적인 해법은 철저하고 주의 깊게 서로 공감하고 소통하는 것이지만, 더 세부적으로도 관심을 기울일 만한 해법들이 있다.  
* 시스템 아키텍트의 업무는 나름의 추정을 써서 예산에 맞추고, 이 것이 실제로 구현될 수 있도록 입찰자들과의 조율을 행한다는 점에서 건축계의 아키텍트와 업무적 유사성을 가진다.  
	* 차이점이라고 하면 설계 초반부터 원한다면 언제든지 입찰가를 받아볼 수 있다는 이점이 있고, 입찰자가 한 명밖에 없기 때문에 입찰 금액의 유동성이 크다는 단점도 있다.  
* 추청 비용이 너무 높게 나오는 경우?  
	1. 설계 자체를 축소한다.  
	2. 더 쉬운 구현으로 대응한다.  
		* 구현 담당자의 감정이 개입되게 만드는 행동이기 때문에 조심스럽게 접근해야 한다.  
			1. 구현 과정에서의 창의성을 발휘할 책임은 구현자에게 있기 때문에, 지시가 아닌 제안을 해야한다.  
			2. 명세에 대한 적어도 1가지 구현법을 제시할 수 있도록 준비하고, 같은 결과라면 다른 방법도 수용해야 한다. 사소한 기능이라도 실제 구현하다보면 의외로 비용이 많이 들 수 있기 때문이다.  
			3. 이러한 제안은 조용히 개인적으로 이야기 해야한다.  
			4. 개선안을 제시한 공을 인정받으려고 미련두지 말아야 한다.  
* 두 번째 시스템 효과를 주의하라.  
	* 첫 작품은 조심스럽고 자제하면서 만들어서 단출하고 깔끔한 반면, 두번째 작품은 첫 작품으로 자신감이 붙어 첫번째 때 미뤄두었던 온갖 아이디어야 장식을 도입하여 설계가 과도해지는 효과  
	* 기능이 비대해지는 것 뿐 아니라, 시스템에 대한 가정이 변하면서 존재 가치가 없어진 기술을 개선하려는 경향이 나타난다.  
* 두 번째 시스템 효과를 건너뛰고 넘어갈 도리는 없지만, 그것을 염두에 두고 자제할 수는 있을 것이다.  
	* 아키텍트의 눈을 뜨게 하는 훈련으로 세부기능 하나하나에 값을 부여하는 방법이 있다.  
	* 최소 두 개 이상의 시스템 개발 경험이 있는 사람을 선임 아키텍트로 고수한다.  
	* 두번째 시스템 효과를 생각하며 자신이 세운 철학과 목적이 완전히 반영되도록 하는 올바른 질문들을 던질 수 있을 것이다.  

## 6. 말을 전하다

* 아키텍트는 소수고 구현자는 다수인 경우에는 어떻게 개념적 일관성을 유지할 것인가?  
	1. 메뉴얼(문서화된 명세) : 충분하지 않더라도 필요한 도구  
		* 사용자와 구현자들로부터 계속 피드백을 받아서 매뉴얼을 개선해 나가야 한다.  
		* 너무 실시간으로 반영하지말고, 어느정도 분량을 모아서 반영해야 한다.  
		* 사용자가 보는 모든 것을 기술하고, 사용자가 보지 않는 부분은 기술을 자제해야 한다. 이 부분은 구현자의 재량으로 남겨 두어야 하며, 아키텍트가 이 부분의 구현 방안을 지시하려고 해서는 안된다.  
		* 메뉴얼을 꼼꼼하고 완전하며, 세부사항이 정확해야 한다.  
		* 사용자는 보통 항목 하나만 참조하는 경우가 많으므로, 필요한 내용을 빠짐없이 반복하되, 전체 내용이 일치되어야 한다.  
	2. 형식적 정의  
		* 완결적이고 정확한 정의를 위해 사용할 수 있다.  
		* 배우지 않으면 이해하기 쉽지 않다는 장점이 있다.  
		* 형식적 정의와 서술적 정의를 모두 사용하되, 둘 중 하나를 기준으로 삼아야 한다.  
		* 형식적 정의 역시 하나의 구현체기 때문에 아키텍쳐를 제한할 염려가 있다. 작성자는 이러한 형식적 정의가 외부적 측면에만 해당됨을 명시하고, 그것이 어느 부분인지도 일러둬야 한다.  
		* 반대로, 구현체가 형식적 정의로 사용될 수 있다. 기존의 구현이 호환되는 새로운 시스템을 만들 때 적용할 수 있다.  
			1. 장점 : 모든 의문은 실험에 의해 확실히 정리되고, 즉각적인 답을 얻을 수 있다. 그 답은 항상 정확하고 올바르다.  
			2. 단점 : 
				1. 외부적인 측면마저도 과도하게 규정할 우려가 있다.  
				2.  구현체의 세부사항에 의해 설계가 우아하지 못하게 될 수 있다.  
				3. 서술적 정의와 형식적 정의 어떤 것이 진짜 표준인지 혼동하기 쉽다.  
	3. 직접 포함하기 : 아키텍트가 인터페이스를 직접 선언해서 넘겨준다.  
	4. 회의와 법정  
		* 회의 : 모든 아키텍트, 구현 파트의 대표들, 마케팅 담당자들이 함께 참석하는 반나절 가량의 주간회의  
			* 누구든지 문제를 제기하거나 변경을 제청할 수 있지만, 보통 그 내용은 서면으로 미리 배포된다.  
			* 새로운 문제에 대해서는 시간을 들여 논의하되, 결정보다는 창의성 발현에 중점을 둔다.  
			* 이렇게 나온 해법들은 그 중 몇가지를 골라서 아키텍트가 메뉴얼 변경 제안서를 만든다.  
			* 이 제안서는 의사결정 안건이 되어 구현자와 사용자들에게 회람되어 신중한 검토가 이루어지며, 합의를 도출해본 뒤 합의되지 않는다면 수석 아키텍트가 결정한다.  
			* 이러한 회의 내용은 기록으로 남겨지고, 결정된 내용은 공식적으로 지체없이 널리 전파된다.  
			* 장점  
				1. 아키텍트, 사용자, 구현자로 구성된 동일 집단이 여러 달 동안 매주 만나므로 최신 정보 갱신의 시간을 들일 필요가 없다.  
				2. 모두가 생기 있고 능력 있는 사람들이며, 결론의 향방에 깊이 관여되어 있다. 즉, 꼭 필요한 사람들만 회의에 참여하게 된다.  
				3. 문제의 안쪽에 있는 사람들뿐 아니라 바깥에 있는 사람들도 해결책을 모색하게 된다.  
				4. 문서화된 제안서는 공식적이기 때문에, 주의가 자연스레 집중되고 결정에 영향을 미칠 수 있으며, 앞뒤가 맞지 않는 일도 없다.  
				5. 의사 결정권이 수석 아키텍트에게 있음을 명확히 함으로 타협과 시간 지연을 피할 수 있다.  
		* 법정 : 주간회의에서 다루지 못했거나, 시간이 지나면서 생긴 여러 불만들을 정리해 놓은 백로그를 정리하기 위한 모임  
			* 프리즈가 걸려 코드나 문서 변경이 어려워지기 직전에 개최되어야 한다.  
	5. 여러 벌 구현하기 : 구현체에 매뉴얼이 따라가는것을 막기 위해, 여러 구현체를 두는 것.  
	6. 통화일지 : 구현에서의 불명확한 점은 아키텍트에게 물어봐야하며, 아키텍트의 답변은 권위를 가지고 모두에게 공유되어야 한다. 이를 위해 통화 내역을 기록하고, 이를 모아 사용자 및 구현자들에게 배포한다.  
	7. 제품 테스트 : 설계와 동시에 초반부터 테스트 팀을 둠으로써 결함과 불일치를 지속적으로 집어내는 선의의 비판자 역할을 하게 한다. 이들은 궁극적인 감사인인 고객의 대리인으로써 존재하게 된다.  

## 7. 바벨탑은 왜 실패했는가

* 바벨탑을 엔지니어링 프로젝트로써 보면, 성공할 전제 조건을 얼마나 갖추고 있었을까?  
	1. 명확한 임무 - 불가능했지만, 존재했다. 하지만 그 태생적 한계를 보기 전부터 실패했다.  
	2. 인력 - 많았다.  
	3. 재료 - 풍부했다.  
	4. 시간 - 시간적 암시는 없었다.  
	5. 적절한 기술 - 존재했던 것으로 보인다. 하지만, 기술적 한계 이전에 실패했다.  
* 실패의 이유는 바로 ‘의사소통’, 거기서 귀결되는 ‘조직’이다. 의사소통이 불가능해지면서 작업을 조율할 수 없게되고, 논쟁을 해결할 수 없게 되면서 각 부족들은 고립을 택하게 된다.  
* 시스템이 구축되어 가면서 프로그램의 기능, 크기, 속도 등이 암시적, 명시적으로 바뀌게 되는데 이것이 제대로 전파되지 않음으로 모든 문제가 생기게 된다.  
* 그렇다면 어떻게 소통해야 할까?  
	1. 비공식적 소통 : 통신이 잘 되어 있고, 그룹간 의존관계가 명확하다면 빈번한 소통으로 공통된 해석을 이끌어낼 수 있다.  
	2. 회의 : 정기 프로젝트 회의를 통해 각 팀이 차례로 기술적 브리핑을 함으로 수많은 사소한 오해를 드러낸다.  
	3. 워크북 활용  
* 워크북 : 프로젝트를 진행하면서 어차피 생산될 문서들로 구성된 하나의 체계. 프로젝트의 ‘모든’ 문서는 여기에 포함되어야 한다.  
	* 왜 만들어야 하나?
		* 기술적인 글의 생명은 거의 영원하고, 새로운 문서가 나와도 언제나 기존 글을 참조하여 작성되기 때문에 처음부터 문서 산출물의 구조를 제대로 잡는 것이 아주 중요하다.  
		* 프로젝트 워크북의 구조를 초기부터 잡아두면 마구잡이로 문서화 되는 것을 막을 수 있고, 차후 작성될 문서들도 체계의 일부로 자연스레 흡수된다.  
		* 이 체계를 통해 정보를 목록화하면, 작업자는 필요한 문건을 쉽게 확인할 수 있다.  
		* 메모들을 계층화시켜서 배포 목록을 서브트리 단위로 관리할 수 있게 만들어 준다.  
	* 어떻게 운영하나?(과거편)  
		* 모든 프로그래머가 워크북의 사본을 1부씩 보유한다. 이 사본은 변경된 페이지를 교체하기 쉽게하기 위해 바인더 형태로 제작된다.  
		* 변경된 부분은 재빠르게 배포되며, 무엇이 변경되었는지 쉽게 알 수 있도록 하이라이팅과 변경 사항들 전체의 요약본을 함께 배포되어야 한다.  
		* 워크북 크기가 너무 커질경우 종이말고 다른 방법(microfiche 등)으로 물리적인 분량을 줄여야 한다.  
	* 어떻게 운영하나?(현재편)  
		* 워크북을 직접 접근식 파일에 두고 변경 표식과 개정 일자를 명기하는 방법이 좋을 것이다.  
		* 변경 사항은 계속 쌓이고, 프로그래머는 이 변경사항과 본문을 비교하면서 꾸준히 읽어 나가면 된다.  
	* 좋은 정보 시스템은 인터페이스상의 오류를 드러내기도 하지만, 그 오류의 정정 또한 고무시킨다.  
* 대규모 프로그래밍 프로젝트의 조직 구성  
	* 조직의 목적은 필요한 의사소통의 양과 팀 간 조율의 양을 줄이는 것이다.  
	* 일반적인 조직구조인 트리형태의 조직은 권한과 책임 구조로부터 파생된 것이기 때문에 그물망 형태인 의사소통 구조를 잘 반영하고 있지는 않다.  
	* 트리형 조직에서 의사소통을 줄이기 위한 방법 : 분업과 전문화  
	* 효율적 운영을 위해 하위 조직에서 반드시 갖춰야 할 핵심사항  
		1. 임무  
		2. 프로듀서  
		3. 기술 총괄 또는 아키텍트  
		4. 일정  
		5. 업무 분장  
		6. 각 파트 간 인테페이스 정의  
	* 프로듀서의 역할  
		1. 팀을 조직하고, 업무를 나누고 일정을 수립한다.  
		2. 필요한 자원을 지속적으로 확보하는 책임을 맡는다.  
		3. 팀 외부와 사방으로 소통하고, 팀 내의 의사소통 및 보고 체계를 수립한다.  
		4. 주위 환경의 변화에 대응하여 자원 투입과 조직 구성을 조정해가며 일정이 지켜질 수 있도록 한다.  
	* 기술 총괄의 역할  
		1. 설계를 구상하고, 하위요소를 결정하며, 시스템의 외부 구조를 명세하고, 내부 구조를 스케치한다.  
		2. 전체 설계에 통일성과 개념적 일관성을 부여하고, 시스템 복잡도를 관리한다.  
		3. 기술적 문제가 발생하면 해결책을 고안하거나, 설계를 변경한다.  
	* 프로듀서와 기술 총괄의 조합  
		1. 프로듀서와 기술 총괄이 같은 사람 : 3~6인 정도의 소규모 팀에 적합. 관리적 재능과 기술적 재능이 모두 뛰어난 사람은 찾기 힘들 뿐 아니라, 팀이 커지면 각 일이 한 사람이 맡을 규모가 아니게 된다.  
		2. 프로듀서가 수장, 기술 총괄이 오른팔 : 큰 규모의 조직에 적합. 기술 총괄을 명령 계통 상에 두어서 시간을 뺏기게 하지 않고도 기술적 결정에 대한 권위가 서도록 하는 것이 과제이다. 이것이 가능하려면 기본적인 기술적 철학에 대해 프로듀서와 기술 총괄이 같은 관점을 공유하고 있어야 한다. 효과적으로 운용될 수 있지만, 프로젝트 관리자가 관리능력 떨어지는 기술 분야 귀재를 잘 활용하는 경우는 드물다.  
		3. 기술 총괄이 수장, 프로듀서가 오른팔 : 기술 총괄이 기술적인 결정에 집중할 수 있도록 프로듀서가 보좌한다. 앞에서 말한 외과의 팀과 같은 중소규모 팀에 적합.
* **조직이란 현재 있는 사람들을 중심에 두고 구성하는 것이지, 이론적인 조직에다 사람을 끼워 맞추면 안된다.**

## 8. 예고 홈런

* 시스템 프로그래밍 작업에 들어가는 시간과 공수를 어떻게 추정할 수 있을까?  
* 추산 시의 주의점  
	1. 코딩 부분만을 추산한 뒤 전체 작업량을 추정해서는 안된다. 코딩이 전체에서 차지하는 비중은 낮다.  
	2. 독립된 소규모 프로그램에 대한 생산성 데이터로 시스템 전체를 추정하려고 하면 안된다.  
* 엄격히 비교는 곤란하지만, 작업에 드는 노력은 프로그램 크기의 거듭제곱에 비례하여 늘어나는 경향이 있다.  
* Nanus & Farr의 연구 : (투입공수) = (상수) * (명령문 개수)^1.5  
* 포트먼(Protman)의 데이터 : 개발팀이 일정을 절반 정도 밖에 지키지 못한다. 각 작업은 애초 추정보다 2배의 시간이 걸렸다. 이러한 일정 추정상의 오류는 기술적인 업무를 처리하는 시간에 대한 비현실적인 가정 때문에 일어난다.  
* 아론(Aron)의 데이터, 하(Harr)의 데이터, OS/360의 데이터 : 작업 자체의 복잡도 및 난이도와 관련된 생산성 차이가 현저하다.  
* 코르바토(Corbato)의 데이터 : 기본적인 문장 단위로 볼 때 생산성은 일정 수준으로 유지되는 경향이 있다. 또 적절한 고급 언어를 사용하면 생산성을 대략 5배까지도 끌어올릴 수 있다.  

## 9. 5파운드 자루에 담은 10파운드

* 프로그램의 크기 역시 비용이다. 따라서 꼭 필요한 만큼의 크기를 가질 수 있도록 목표치를 세우고 그것을 통제하여 크기를 줄일 수 있어야 한다.  
* 크기를 정하기 위해서는 각 요소 내의 절충 가능한 부분을 파악할 줄 알아야 하는 까다로운 일이다.  
	1. 메모리에 대한 목표치를 세우는 것만으로는 충분하지 않다. 상주 공간 뿐 아니라, ‘전체’공간의 크기를 가지고 예산을 배정하라. 또 보조 저장 장치 접근 빈도에도 제한을 두라.  
	2. 모듈의 크기를 정할 때는 그 모듈이 할 일도 명확히 하라.  
	3. 공간을 사용함에 있어서 전체적이고 사용자 중심적인 관점이 각 구현자 개인에게 필요하다.  
* 공간 절약에 관한 기법들  
	1. 기능과 크기 맞바꾸기
		* 사용자에게 선택의 여지가 많을수록 공간이 커진다. 사용자가 어느정도까지 세밀하게 할 수 있을지를 설계시에 결정해야 한다.  
		* 메모리가 제한된 시스템에서는 모듈의 크기도 제한되는데, 모듈이 너무 잘게 쪼개지면 속도에서 손해를 보게 된다. 그래서 소형 시스템에서 효율적인 시스템의 최대 크기는 제한을 받게 된다.  
	2. 메모리 공간과 실행 시간 사이의 적절한 타협 : 어떤 기능에 더 많은 공간을 할당한다면 더 빨리 수행될 수 있다.  
* 속도와 크기 사이에서 적절한 타협점을 찾도록 관리자가 팀을 돕는 법  
	1. 적절한 프로그래밍 기법에 대한 훈련을 받게 하고 이를 장려한다.  
	2. 프로그래밍에서의 기본적 구성요소들과 기법들을 개발하고 이를 공유하게 한다. 각 프로그램은 속도 우선 버전과 점유 공간 우선 버전으로 나누어져 기록되어야 한다.  
* 데이터 표현 방법만 바꿔도 속도와 공간면에서 획기적인 발전이 일어나는 경우가 많은데, 이 부분이 바로 프로그래밍의 정수라 할 수 있다.  

## 10. 기록물 가설

* 기록물 가설 : 온갖 서류의 홍수 속에서 몇몇 문서는 점차 모든 프로젝트 관리 업무가 그것을 중심으로 돌아가는 핵심적인 축이 된다. 이 문서들이 관리자의 주요한 개인 도구다.  
* 어떠한 관리 업무라도 그 관심사는 무엇은, 언제, 얼마나, 어디서, 누가 하느냐에 있다.  
* 소프트웨어 프로젝트의 문서들  
	1. 무엇을: 목표(요구사항, 최종 목표, 필요한 것, 제약 조건, 우선순위)  
	2.  무엇을: 제품 명세(제안서 -> 매뉴얼 및 내부 문서, 속도와 공간 명세가 핵심)  
	3. 언제 : 일정 
	4. 얼마나 : 예산  
	5. 어디서 : 공간 할당 
	6. 누가 : 조직도  
		* 시스템을 설계하는 조직은, 그 조직의 의사소통 구조를 본뜬 시스템을 만들어내게 되어있다.(Conway의 법칙)  
		* 최초의 조직도에는 첫 설계 내용이 반영되고, 그 설계가 제대로일 가능성은 낮으므로 조직은 언제나 변화에 대비해야한다.  
* 왜 형식을 갖춘 문서를 만드는가?  
	1. 글로 적는 과정이 필수불가결하기 때문이다. 글로 적는 과정에서 수많은 의사결정이 필요하고 이 과정을 통해 모순이 드러나고 정책이 더 분명해진다.  
	2. 결정된 내용을 다른이들에게 말보다 효과적으로 알릴 수 있기 때문이다.  
	3. 문서 자체가 데이터베이스와 체크리스트 역할을 하게 된다.  
* 소수의 핵심 문서가 관리자의 업무 대부분을 요약하고 있기 때문에, 관리자들은 이 문서의 유용성을 빠르게 간파하고, 문서들을 이용해야 한다.  

## 11. 버리기 위한 계획
* 대부분의 프로젝트에서 나온 첫 시스템은 쓸 수 없는 수준의 물건이다.
	* 답은 다시 설계해서 문제를 해결한 버전을 만드는 것 뿐이다.
	* 시스템의 재설계는 필연적이고, 미완성된 시스템을 납품한 댓가는 비싸다
* 변화를 하나의 생활 양식으로써 받아들여야 한다.
	* 하드웨어 제품은 변화가 쉽지 않기 때문에 변화에 대한 요구를 자제하게 되지만, 소프트웨어는 다루기 쉽고 형체가 없기 때문에 끝없는 변경 요구에 노출된다.
	* 목표와 요구 변경 사항을 모두 반영할 수 도, 할 필요도 없다. 반영하는 기준이 필요하고 개발이 진행될 수록 이 기준은 점점 높아져야 한다.
	* 하지만 목표가 얼마간은 변경되는 걸 피할 수 없기 때문에, 사전에 대비해 두는 편이 낫다.
* 변화에 대응하는 방법
	* 주의 깊은 모듈화
	* 광범위한 서브루틴의 사용
	* 모듈 간 인터페이스의 명확하고 완전한 정의
	* 모든 것에 대한 철저한 문서화
	* 표준 호출 절자 수립
	* 테이블 기반 기법 활용
	* 이외 여러가지 방법들…
* 중요한 것은 **고급 언어와 자체 문서화 기법을 사용하는 것** -> 변경 과정에서 비롯되는 오류를 줄일 수 있다.
* 변경 사항은 반드시 일정 묶음으로 처리되어야 한다.
	* 버전을 매겨야 한다.
	* 모든 버전은 고유 일정과 코드 프리즈 날짜를 가져야 한다
* 조직 전체가 기술적인 유연함을 가져야 한다. -> 관리자와 기술자가 임무를 교대할 수 있게 되어야 한다
	* 사회학적 장벽
		1. 선임자들을 실무에 투입하지 않으려 하는 경향
		2. 관리 쪽 직군이 더 중요시 되는 풍토
	* 해결책
		1. 관리직과 기술직에 단순히 급여 뿐 아니라 대등한 수준의 위신을 부여해야 한다. -> 현재의 경향상 기술쪽에 더 큰 보상을 해야 한다
		2. 관리자와 선임 기술자 모두 상대 직군의 훈련 과정을 이수하도록 할 필요가 있다.
		3. 재능이 허락하는 범위 안에서라면 선임자들이 관리, 기술적으로 직접 참여할 감정적,실력적인 준비가 되어야 한다. 
			* 외과의 팀을 꾸리는 것이 근본적 해답이다
			* 이러한 팀은 인터페이스 수를 최소화하게 된다.
* 프로그램 유지보수 측면에서도 기술적 유연함은 도움이 된다.
	* 유지보수의 근본적 문제 : 결함을 수정할 때 상당한 확률로 또 다른 결함이 유입된다.
		1. 시스템 전체에 미치는 결함도 국부적인 문제로 나타나기 때문에 진단이 쉽지 않다.
		2. 수리 담당자가 코드를 짠 당사자가 아니고, 직위도 낮은 경우가 많다.
	* 부작용을 없어내거 최소한 드러나도록 만드는 프로그램 설계 방법을 사용하고, 더 적은 인원이 인터페이스를 더 단순하게 구현한다면  유지보수에 이득을 볼 수 있을 것이다
		* 다만 시스템의 수정은 엔트로피를 상승시키는 행위이므로 결국 언젠가는 수리 불가능한 상태가 오고, 재설계하는 건 불가피하다.
* 

