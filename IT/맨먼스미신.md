# 책 제목 : 맨먼스 미신

저자 : 프레더릭 브룩스  
역자 : 강중빈
출판사 : 인사이트  
출판년월 : 15/3  
페이지 : 362  

---

* **프로그래밍을 관리하는 것은 왜 어려운가?**
	1. 대규모 프로젝트는 업무 분배 때문에 소규모 프로젝트에는 없던 관리 문제가 생긴다.  
	2. 많은 사람의 의견이 모이기 때문에, 제품 자체의 개념적 일관성을 유지하기 어렵다.  

## 1. 타르 구덩이

* 대규모 시스템 프로그래밍은 마치 타르 구덩이 같다.  
	1. 수많은 실력자들이 그 속에 빠져서 헤어나오기 힘들다.
	2. 어떻게 빠져 나오더라도 목표,일정,예산을 충족하는 경우는 드물다.  
	3. 타르 속에서는 멀쩡히 움직일 수 있는 것 처럼, 실패의 원인을 지목하기도 어렵지만, 여러 요인들이 동시 다발적이고 상호적으로 작용하면서 지나치게 복잡해진다.
		* 문제를 해결하기 위해서는 문제의 본질이 먼지 이해하려고 노력해야 한다.  
* 프로그래머(혹은 개발팀)이 만드는 것은 무엇인가?  
	1. 프로그램 : 자체적으로 완결적이고, 개발된 장비에서 개발한 사람에 의해 실행이 가능한 것  
		* 프로그래머 개인의 생산성 추정을 할 때 사용되는 것  
	2. 프로그래밍 제품 : 프로그램이 일반화 된 것. 누구든지 테스트,보수, 확장할 수 있고, 다양한 환경에서 여러 데이터에 적용될 수 있어야 한다.  
	    * 일반화, 테스트, 문서화가 모두 철저히 이루어져야 한다.  
	3. 프로그래밍 시스템 : 상호 작용하는 여러 프로그램의 묶음, 다 합쳐진 상태에서 대규모 작업을 수행할 수 있게 만든 것  
		* 개별 프로그램은 시스템에서 정의한 인터페이스를 반드시 따라야만 한다.  
		* 규정된 자원만 사용하도록 섬세하게 설계되어야 한다.  
		* 다른 구성요소들과 조합 가능한 모든 경우에 대해 테스트 되어야 하며, 테스트가 제대로 되었다 해도 예기치 못한 상호작용으로 인한 문제가 일어날 수 있기 때문에 테스트에 드는 시간도 많이 든다.  
	4. 프로그래밍 시스템 제품 : 프로그래밍 시스템 + 프로그래밍 제품  
		* 대다수 시스템 프로그래밍이 목표로 하는 결과물  
* 프로그래밍은 왜 재미있는가?  
	1. 무언가를 만드는 데서 오는 순전한 기쁨  
	2. 다른 이들에게 쓸모있는 사물을 만드는 데서 오는 기쁨  
	3. 복잡한 퍼즐같은 것들이 그 안에 있는 법칙들에 따라 미묘한 순환을 이루며 돌아가는 것을 보는 매혹적인 경험  
	4. 지속적인 배움에서 오는 기쁨  
	5. 너무나도 유연하고 다루기 쉬운 표현 수단으로 작업하는 데서 오는 기쁨  
* 프로그래밍은 왜 고달픈가?  
	1. 완벽함이 요구된다.  
	2. 다른 사람들이 내 목표를 설정하고 자원과 정보를 제공한다.
	3. 다른 사람이 만든 프로그램에 대한 의존성을 해결하느라 시간이 허비된다  
	4. 장대한 개념을 설계하는 것은 재밌지만, 버그 잡는 것은 그저 일일 뿐이다.  
	5. 힘들게 만든 제품이 완성되었을 때, 혹은 완성되기도 전에 한 물 가서 퇴출되버린다.  
* 우리의 도전과 임무는 가용한 자원으로 실질적인 일정 내에서 현실의 문제에 대한 현실적인 해법을 찾는 데 있다.  

## 2. 맨먼스 미신
* 부족한 시간 탓에 망가진 소프트웨어 프로젝트 수는 다른 이유로 그렇게 된 경우보다 훨씬 많다.  
	1. 우리의 추정 능력은 형편없다. 거기에 사실에 기반하지 않은 지나친 낙관이 반영되어 있기까지 하다.  
	2. 투입 공수(맨먼스)와 작업 진척도를 혼동한다. 즉 사람을 많이 투입하면 일이 빨리 끝날거라 생각한다.  
	3. 추정에 대한 자기 확신이 없기에, 정중한 고집이 결여되어 있다.  
	4. 일정 진척도가 제대로 모니터링 되고 있지 않다.  
	5. 일정이 어긋나는 것을 감지했을 때의 자연스러운 대응 방법이 인원 충원이다.  
* 프로그래머들은 다들 낙관성을 가지고 있다. 이러한 낙관론은 모든 작업이 예정내에 완료될 것이다’란 잘못된 가정의 원인이 된다.  
	* 아이디어는 그 자체가 결함이 있더라도, 구현되지 않으면 그 결함이 드러나지 않는다. 그래서 실제로 구현을 해보는 것은 필수적이다.
	* 프로그래밍의 재료는 다른 창작활동의 재료보다 다루기가 훨씬 쉽기 때문에, 구현도 쉬울 것이라고 오해한다. 하지만 아이디어 자체의 결함이 있을 수 있기에 버그는 필연적이고, 이러한 낙관주의는 정당성이 없어진다.  
	* 한 작업이 제대로 되더라도 다른 작업이 모두 일정에 맞출 가능성은 한없이 낮다
* 맨먼스는 비용 추산 지표일 뿐, 이것으로 작업 진척도를 잰다는 것은 위험하고 기만적인 미신이다.  
	* 사람과 일정이 교환 가능하기 위해서는 분업이 용이하고, 서로 소통할 필요가 없는 경우다. 시스템 프로그래밍은 이 두가지 모두 해당하지 않는다.  
		* 분업이 용이하지 않은 경우 : 각 작업 간에 의존성이 존재한다.  
		* 소통할 필요가 있는 경우 : 소통에 들어가는 비용 또한 전체 작업 계산에 포함되어야 한다. 소통은 훈련이 필요하고, 소통 자체에 들어가는 부담은 분업을 통해 얻을 수 있는 이득을 상회하기도 한다.  
	* 소프트워어 개발은 원래가 복잡한 상호 연관성을 가진 활동이기 때문에 사람을 더 투입하면 오히려 일정을 늘어지게 만든다.  
* 시스템에 대한 테스트는 쉽게 간과되기 때문에, 일정 예측이 빗나가는데 가장 큰 지분을 차지한다.  
	* 시스템 테스트에 충분한 시간을 배정하지 않으면, 결국 그 배정하지 않은 시간만큼 일정을 지연시키게 된다. 따라서 테스트에는 충분한 시간을 할애해야 한다.  (저자는 구성 요소 테스트&초기 테스트에 1/4, 전체 시스템 테스트에 1/4로 총 1/2의 시간을 할당하고, 1/3을 계획수립, 1/6의 시간만 코딩에 할당)  
	* 특히 프로젝트 말미에는 여러가지 관련 작업이 동시에 돌아가야 하기 때문에, 일정이 지연되면 2차적인 비용이 더 커지게 된다.  
* 고객의 긴급한 요청등에 의해 일정이 앞당겨 질 수도 있다. 하지만 그렇다고 그만큼 일이 빨리 진행되는 것은 아니고, 앞당겨진 일정만큼의 업무는 하지 않은 상태로 남아버린다.  
	* 이는 정량적인 추정을 하지않고, 이 추정을 뒷받침할 데이터가 없고 대부분 관리자들의 예감과 경험에 의존하기 때문에 이 추정을 적극적으로 방어할 수 없기 때문이다.  
	* 이를 해결하기 위해서는 생산성 수치, 버그 발생률, 추정 원칙등을 도입해 추정의 기반이 견고해져야 하고, 관리자들은 그 기반이 견고해질 때까지는 스스로가 당당하게 추정치를 방어해야 한다.  
* 어떤 프로젝트가 일정에 뒤쳐지고 있을 때, 원래의 계획에 맞추기 위해 섣불리 인력을 투자하는 행위는 무조건 원하는 결과를 얻어내지 못한다.  
	* 새로 투입된 멤버가 바로 일할 수는 없다. 기존 멤버에게 훈련을 받아야하고, 그 기간동안은 기존 멤버도 일을 제대로 할 수 없다. 또 기존 인원에 맞게 분할된 일을 다시 나눠야 하므로, 진행된 작업 중 일부는 재사용이 불가능해 날리게 될 것이다. 결국 인원을 늘려도 일정에 맞추는 것은 요원하기만 하다.  
	* 일정에 맞추지 못했기 때문에, 관리자는 더 많은 인원을 투입하려는 유혹에 빠지게 된다. 하지만 이는 다시 위의 문제를 일으키고, 프로젝트는 점점 더 악화된다.  
	* 이렇게 거듭되는 문제 끝에 나온 결과물은, 원래 인원을 유지하며 일정을 재수립했을 때보다 더 못하리라는 것은 자명하다.  
	* **늦어진 소프트웨어 프로젝트에 인력을 추가로 투입하면 더 늦어지게 된다.** 
* 프로젝트에 소요되는 기간은 순서대로 처리해야하는 내부 요소에 좌우되며, 필요한 최대 인원수는 독립된 하위 작업의 개수에 좌우된다. 무조건 인원이 많다고, 시간이 부족하단 이유로 재촉한다고 일이 잘되는 게 아니다.  
	* 이 두가지 수치를 파악해야지만 관리자는 더 적은 수의 사람과 더 긴 기간에 기초한 합리적인 일정을 수립할 수 있다.  
	* 그래도 제품이 시대에 뒤쳐지는 것은 어쩔 수 없지만…

## 3. 외과 수술 팀

* 작은 팀 vs 큰 팀, 어떤 것이 답일까?  
	1. 효율적 개념과 일관성을 위해서는 적은 인원으로 팀을 구성하는 게 훨씬 낫다.
	2. 하지만 아무리 뛰어난 프로그래머들을 모아놓아도 작은 팀이라면 큰 시스템을 의미있는 시간내에 만들어 내지 못한다. 큰 시스템은 원래 만드는 데 많은 작업이 필요한 법이다.  
* 할란 밀스(Halan Mills)의 해결책 : 커다란 전체 업무를 여러 팀에 나눠 맡기되, 각 팀을 외과 수술 팀 처럼 조직하라.  
	* 즉, 한 명이 주도적으로 문제를 해결해 가는 동안, 다른 사람은 그 사람의 효율과 생산성을 높이기 위해 지원하는 체제  
	* 이 방법이면 설계와 구축에 적은 인원이 들어가면서, 작업에는 많은 인원이 투입되게 된다.  
* 일을 어떻게 나누고, 어떤 역할을 부여할 것인가?  
	1. 외과의(수석 프로그래머) : 기능과 성능 명세를 직접 정의하며, 설계, 코딩,테스트, 문서화 등 모든 작업에 관여한다. 재능, 경력, 시스템 및 응용 분야에 대한 지식 등에서 상당한 수준이 요구된다.  
	2. 부조종사 : 외과의의 분신, 올라운더지만 경험이 많지는 않다. 주 역할은 설계 과정에 참여하여 같이 고민하고 토론하고 평가하는 것이다. 종종 팀을 대표하기도 하며, 모든 코드를 파악하고 대안적 설계에 대한 전략을 연구한다. 코드를 만들수도 있지만 책임은 지지 않는다.  
	3. 행정 담당 : 외과의를 대신해 행정 업무를 수행하는 사람. 다만, 꼭 필요한 경우에만(법률적, 계약적 중대 사안이 있는 경우, 보고를 강화해야 하거나, 재무적 이슈가 있을때) 전일제로 두어야 한명의 행정 담당이 여러 팀에 걸칠 수도 있다.  
	4. 편집자 : 외과의가 작성한 초안이나 구술 원고를 비평,수정,보충,관리하는 등의 역할  
	5. 비서 : 행정 담당과 편집자 각각 한 명씩, 총 두 명의 비서가 필요하다. 프로젝트 관련 우편물과 일반적인 업무 서류를 담당한다.  
	6. 프로그램 사무원 : 팀에서 생산되는 모든 기술적 산출물을 하나의 프로그래밍 제품 라이브러리로 관리할 책임을 진다. 기계가 읽을 파일과 사람이 읽기 위한 파일 모두 담당한다. 팀의 반복적인 사무 작업을 덜어주고 등한시되는 그런 작업들이 잘 진행되도록 하여, 작업 산출물을 향상 시킨다.  
	    * 핵심은 프로그래밍이라는 작업을 ‘개인적인 예술’에서 ‘공개적인 실행’으로 바꾸는 것이다.  
	7. 도구 담당 : 이전처럼 팀별로 자체적인 장비와 운영요원을 필요로 하지는 않는 시대지만, 외과의를 대신하여 팀 전체가 사용하는 도구들이 적합한지 확인해주고, 팀 자체적인 도구들을 구축하고 유지보수하는 사람은 반드시 필요하다.  
	8. 테스터 : 테스트 케이스를 만들고, 테스트 데이터를 제공한다. 또한 테스트 순서를 계획하고, 구성 요소를 테스트를 위한 얼개를 짜기도 한다.  
	9. 언어 마스터 : 새로운 언어를 익히고 복잡한 문제에 대해 특정 언어를 사용한 더 깔끔하고 효율적인 방법을 연구한다. 여러 팀에 걸쳐 자문역할을 하기도 한다.  
* 이러한 팀은 동등한 지위를 가지고 분업하는 팀과 다르게 다음과 같은 이유로 한 사람처럼 행동할 수 있게 된다.  
	1. 외과의와 부조종사 모두 전체 설계와 구현을 다 알고 있으므로, 서로 조율하는 수고가 줄어들고, 개념적 일관성 또한 보장된다.  
	2. 팀 안에서의 불가피한 의견 차이가 외과의에 의해 일방적으로 정리된다.  
* 대규모 작업에서는 10명 가지고는 안되지만, 여러 외과의 팀이 모이면 이러한 작업이 가능하다. 각 부분의 개념적 일관성이 보장이 되었기 때문에, 각 외과의들간의 조율 문제만 해결하면 되는 것이다.  
* 하지만 이 외과의들 간의 조율에는 또 다른 기법이 필요하다. 우선은 ‘전체 시스템 역시 개념적 일관성을 가져야 하고, 한명의 시스템 아키텍트가 시스템 전부를 하향식으로 설계할 필요가 있다’라고 요약된다.  
* 이를 위해서는 구현과 아키텍처를 명확히 구분해야 하고, 시스템 아키텍트는 자신의 역할을 철저히 아키텍처 쪽으로만 국한해야한다.  

## 4. 귀족 정치, 민주주의, 시스템 설계

* 시스템 설계에서 가장 중요하게 고려되어야 할 것은 바로 **개념적 일관성**이다. 아무리 좋더라도 연관성 없고 조율도 안된 기능들을 넣기보다, 일련의 설계사상을 고수하는 편이 낫다.  
* 개념적 일관성 얻기  
	* 프로그래밍 시스템은 컴퓨터를 쉽게 사용하게 하기 위함이기 때문에, 기능과 개념적 복잡성의 비율은 시스템 설계의 최종적 기준이 된다. 둘 중 하나만으로는 좋은 설계가 나올 수 없다.  
	* 즉, 일정 수준의 기능을 제공한다는 가정하에서, 최대한 단순하고 명확하게 사용할 수 있는 시스템이 최상이다.  
	* 단순함과 명확성은 개념적 일관성에서 온다.  
	* 사용의 용이성을 추구하는 것이 곧 설계의 통일성과 개념적 일관성을 가져오게 된다.  
* 개념적 일관성은 곧 시스템 설계를 한명 또는 생각을 같이하는 극소수가 하도록 유도한다.  
	* 하지만 일정 압박 때문에 시스템 구축에는 많은 사람이 필요하게 된다.  
		1. 아키텍쳐와 구현을 주의깊게 나누는 방법으로 해결  
		2. 프로그래밍 구현팀의 구성에 새로운 방식(외과의 팀)을 적용하는 것으로 해결  
* 아키텍쳐와 구현을 분리하라  
	* 아키텍쳐 : 사용자 인터페이스의 완전하고도 상세한 명세  
	* 아키텍트 : 사용자의 대리자로써 사용자의 이해만을 대변하기 위해 전문적이고 기술적인 지식을 동원하는 역할을 맡는다.  
	* 아키텍쳐가 ‘무슨 일이 일어날 지’ 정하는 것이라면, 구현은 그것이 ‘어떻게 현실화 되는지’를 정한다.  
	* 물론 아키텍트들만이 참신한 생각을 할 수 있다는 것은 아니다. 하지만, 아무리 훌륭한 기능이나 아이디어도 시스템의 기본 개념에 들어맞지 않는다면 배제하는 것이 상책이다. 이미 너무 많은 아이디어들이 기본 개념에 맞지 않게 들어가 있다면, 전체 설계를 폐기하고 기본 개념을 바꾸고 다시 시작하는게 낫다.  
	* 아키텍트는 소수여야 하고, 그들의 결과물은 구현자들의 것들보다 오래 지속되어야만 한다. 또한 모든 힘겨루기의 중심에서, 사용자의 이해를 대변하여 그 힘들을 중재할 사람은 결국 아키텍트다. 개념적 일관성을 위해서는 누군가가 개념을 통제해야 하며, 이것은 귀족 정치라고 비난받을 대상이 아니다.  
	* 그렇다고 아키텍트의 업무가 구현작업보다 더 창조적이지는 않다. 시스템의 외부 명세를 따라 구현 방안을 설계하는 것은, 외부 명세 설계 만큼이나 많은 창의력과 새로운 아이디어, 기술적 탁월성을 요구한다.  
	* 예술이나 공예 분야에서 절제가 미덕이라고 믿을 만한 사례가 다수 있다.
	> “형식이 자유롭게 한다.”  
	* 제약이 없으면 대부분의 고민과 토론이 아키텍쳐 결정에 관한 방향으로 흘러가며, 본래 의미의 구현 작업은 관심에서 멀어진다.  
* **구현자들의 반론과 이에 대한 반박**
	1. 명세에 너무 많은 기능이 포함될 것이며, 비용에 대한 현실적인 고려도 미비할 것이다.  
		* 정말로 위험한 상황이다. 이후 장에서 이에 대해 논의할 것이다.  
	2. 창조적인 즐거움은 모두 아키텍트 몫이 되고 구현자들의 독창성은 배제될 것이다.  
		* 구현 작업 역시 아키텍쳐 설계에 버금가는 창의적 행위이다. 오히려 명세에 맞춰 작업하는 것이 오히려 창조 수준이 높아질 수도 있다.  
	3. 아키텍쳐팀이 명세를 완성할 때 까지, 많은 구현자들은 하는 일 없이 앉아 있어야 할 것이다.  
		* 타이밍과 단계적 실행의 문제다. 명세가 완성되기 전까지는 구현자들을 배정하지 말아라.  
		* 하지만 이 분야는 일 진행이 빠르고 가능하면 일정을 많이 당기려고 한다. 즉, 병렬적으로 할 수 있는 일은 병렬적으로 해야만 한다.  
		* 창조적 작업은 아키텍처, 구현, 제품화의 단계를 거치는데, 이 과정은 같이 시작해서 동시에 진행이 가능함이 밝혀지고있다. 즉 각 단계는 다른 단계에 의존하지 않는 부분이 많이 있다.  
		* 폭넓게 수평적으로 나뉜 일이 수직적 분업에 의해 대폭 줄어들게 되고, 그 결과는 극단적으로 단순화 된 커뮤니케이션과 향상된 개념적 일관성으로 나타난다.  

## 5. 두번째 시스템 효과

* **기능 명세의 책임과 빠르고 저렴한 제품 구현의 책임이 분리되어 있다면 아키텍트의 창의적인 열정을 제어할 방법은 무엇인가?**
	* 근본적인 해법은 철저하고 주의 깊게 서로 공감하고 소통하는 것이지만, 더 세부적으로도 관심을 기울일 만한 해법들이 있다.  
* 시스템 아키텍트의 업무는 나름의 추정을 써서 예산에 맞추고, 이 것이 실제로 구현될 수 있도록 입찰자들과의 조율을 행한다는 점에서 건축계의 아키텍트와 업무적 유사성을 가진다.  
	* 차이점이라고 하면 설계 초반부터 원한다면 언제든지 입찰가를 받아볼 수 있다는 이점이 있고, 입찰자가 한 명밖에 없기 때문에 입찰 금액의 유동성이 크다는 단점도 있다.  
* 추청 비용이 너무 높게 나오는 경우?  
	1. 설계 자체를 축소한다.  
	2. 더 쉬운 구현으로 대응한다.  
		* 구현 담당자의 감정이 개입되게 만드는 행동이기 때문에 조심스럽게 접근해야 한다.  
			1. 구현 과정에서의 창의성을 발휘할 책임은 구현자에게 있기 때문에, 지시가 아닌 제안을 해야한다.  
			2. 명세에 대한 적어도 1가지 구현법을 제시할 수 있도록 준비하고, 같은 결과라면 다른 방법도 수용해야 한다. 사소한 기능이라도 실제 구현하다보면 의외로 비용이 많이 들 수 있기 때문이다.  
			3. 이러한 제안은 조용히 개인적으로 이야기 해야한다.  
			4. 개선안을 제시한 공을 인정받으려고 미련두지 말아야 한다.  
* 두 번째 시스템 효과를 주의하라.  
	* 첫 작품은 조심스럽고 자제하면서 만들어서 단출하고 깔끔한 반면, 두번째 작품은 첫 작품으로 자신감이 붙어 첫번째 때 미뤄두었던 온갖 아이디어야 장식을 도입하여 설계가 과도해지는 효과  
	* 기능이 비대해지는 것 뿐 아니라, 시스템에 대한 가정이 변하면서 존재 가치가 없어진 기술을 개선하려는 경향이 나타난다.  
* 두 번째 시스템 효과를 건너뛰고 넘어갈 도리는 없지만, 그것을 염두에 두고 자제할 수는 있을 것이다.  
	* 아키텍트의 눈을 뜨게 하는 훈련으로 세부기능 하나하나에 값을 부여하는 방법이 있다.  
	* 최소 두 개 이상의 시스템 개발 경험이 있는 사람을 선임 아키텍트로 고수한다.  
	* 두번째 시스템 효과를 생각하며 자신이 세운 철학과 목적이 완전히 반영되도록 하는 올바른 질문들을 던질 수 있을 것이다.  

## 6. 말을 전하다

* 아키텍트는 소수고 구현자는 다수인 경우에는 어떻게 개념적 일관성을 유지할 것인가?  
	1. 메뉴얼(문서화된 명세) : 충분하지 않더라도 필요한 도구  
		* 사용자와 구현자들로부터 계속 피드백을 받아서 매뉴얼을 개선해 나가야 한다.  
		* 너무 실시간으로 반영하지말고, 어느정도 분량을 모아서 반영해야 한다.  
		* 사용자가 보는 모든 것을 기술하고, 사용자가 보지 않는 부분은 기술을 자제해야 한다. 이 부분은 구현자의 재량으로 남겨 두어야 하며, 아키텍트가 이 부분의 구현 방안을 지시하려고 해서는 안된다.  
		* 메뉴얼을 꼼꼼하고 완전하며, 세부사항이 정확해야 한다.  
		* 사용자는 보통 항목 하나만 참조하는 경우가 많으므로, 필요한 내용을 빠짐없이 반복하되, 전체 내용이 일치되어야 한다.  
	2. 형식적 정의  
		* 완결적이고 정확한 정의를 위해 사용할 수 있다.  
		* 배우지 않으면 이해하기 쉽지 않다는 장점이 있다.  
		* 형식적 정의와 서술적 정의를 모두 사용하되, 둘 중 하나를 기준으로 삼아야 한다.  
		* 형식적 정의 역시 하나의 구현체기 때문에 아키텍쳐를 제한할 염려가 있다. 작성자는 이러한 형식적 정의가 외부적 측면에만 해당됨을 명시하고, 그것이 어느 부분인지도 일러둬야 한다.  
		* 반대로, 구현체가 형식적 정의로 사용될 수 있다. 기존의 구현이 호환되는 새로운 시스템을 만들 때 적용할 수 있다.  
			1. 장점 : 모든 의문은 실험에 의해 확실히 정리되고, 즉각적인 답을 얻을 수 있다. 그 답은 항상 정확하고 올바르다.  
			2. 단점 : 
				1. 외부적인 측면마저도 과도하게 규정할 우려가 있다.  
				2.  구현체의 세부사항에 의해 설계가 우아하지 못하게 될 수 있다.  
				3. 서술적 정의와 형식적 정의 어떤 것이 진짜 표준인지 혼동하기 쉽다.  
	3. 직접 포함하기 : 아키텍트가 인터페이스를 직접 선언해서 넘겨준다.  
	4. 회의와 법정  
		* 회의 : 모든 아키텍트, 구현 파트의 대표들, 마케팅 담당자들이 함께 참석하는 반나절 가량의 주간회의  
			* 누구든지 문제를 제기하거나 변경을 제청할 수 있지만, 보통 그 내용은 서면으로 미리 배포된다.  
			* 새로운 문제에 대해서는 시간을 들여 논의하되, 결정보다는 창의성 발현에 중점을 둔다.  
			* 이렇게 나온 해법들은 그 중 몇가지를 골라서 아키텍트가 메뉴얼 변경 제안서를 만든다.  
			* 이 제안서는 의사결정 안건이 되어 구현자와 사용자들에게 회람되어 신중한 검토가 이루어지며, 합의를 도출해본 뒤 합의되지 않는다면 수석 아키텍트가 결정한다.  
			* 이러한 회의 내용은 기록으로 남겨지고, 결정된 내용은 공식적으로 지체없이 널리 전파된다.  
			* 장점  
				1. 아키텍트, 사용자, 구현자로 구성된 동일 집단이 여러 달 동안 매주 만나므로 최신 정보 갱신의 시간을 들일 필요가 없다.  
				2. 모두가 생기 있고 능력 있는 사람들이며, 결론의 향방에 깊이 관여되어 있다. 즉, 꼭 필요한 사람들만 회의에 참여하게 된다.  
				3. 문제의 안쪽에 있는 사람들뿐 아니라 바깥에 있는 사람들도 해결책을 모색하게 된다.  
				4. 문서화된 제안서는 공식적이기 때문에, 주의가 자연스레 집중되고 결정에 영향을 미칠 수 있으며, 앞뒤가 맞지 않는 일도 없다.  
				5. 의사 결정권이 수석 아키텍트에게 있음을 명확히 함으로 타협과 시간 지연을 피할 수 있다.  
		* 법정 : 주간회의에서 다루지 못했거나, 시간이 지나면서 생긴 여러 불만들을 정리해 놓은 백로그를 정리하기 위한 모임  
			* 프리즈가 걸려 코드나 문서 변경이 어려워지기 직전에 개최되어야 한다.  
	5. 여러 벌 구현하기 : 구현체에 매뉴얼이 따라가는것을 막기 위해, 여러 구현체를 두는 것.  
	6. 통화일지 : 구현에서의 불명확한 점은 아키텍트에게 물어봐야하며, 아키텍트의 답변은 권위를 가지고 모두에게 공유되어야 한다. 이를 위해 통화 내역을 기록하고, 이를 모아 사용자 및 구현자들에게 배포한다.  
	7. 제품 테스트 : 설계와 동시에 초반부터 테스트 팀을 둠으로써 결함과 불일치를 지속적으로 집어내는 선의의 비판자 역할을 하게 한다. 이들은 궁극적인 감사인인 고객의 대리인으로써 존재하게 된다.  

## 7. 바벨탑은 왜 실패했는가

* 바벨탑을 엔지니어링 프로젝트로써 보면, 성공할 전제 조건을 얼마나 갖추고 있었을까?  
	1. 명확한 임무 - 불가능했지만, 존재했다. 하지만 그 태생적 한계를 보기 전부터 실패했다.  
	2. 인력 - 많았다.  
	3. 재료 - 풍부했다.  
	4. 시간 - 시간적 암시는 없었다.  
	5. 적절한 기술 - 존재했던 것으로 보인다. 하지만, 기술적 한계 이전에 실패했다.  
* 실패의 이유는 바로 ‘의사소통’, 거기서 귀결되는 ‘조직’이다. 의사소통이 불가능해지면서 작업을 조율할 수 없게되고, 논쟁을 해결할 수 없게 되면서 각 부족들은 고립을 택하게 된다.  
* 시스템이 구축되어 가면서 프로그램의 기능, 크기, 속도 등이 암시적, 명시적으로 바뀌게 되는데 이것이 제대로 전파되지 않음으로 모든 문제가 생기게 된다.  
* 그렇다면 어떻게 소통해야 할까?  
	1. 비공식적 소통 : 통신이 잘 되어 있고, 그룹간 의존관계가 명확하다면 빈번한 소통으로 공통된 해석을 이끌어낼 수 있다.  
	2. 회의 : 정기 프로젝트 회의를 통해 각 팀이 차례로 기술적 브리핑을 함으로 수많은 사소한 오해를 드러낸다.  
	3. 워크북 활용  
* 워크북 : 프로젝트를 진행하면서 어차피 생산될 문서들로 구성된 하나의 체계. 프로젝트의 ‘모든’ 문서는 여기에 포함되어야 한다.  
	* 왜 만들어야 하나?
		* 기술적인 글의 생명은 거의 영원하고, 새로운 문서가 나와도 언제나 기존 글을 참조하여 작성되기 때문에 처음부터 문서 산출물의 구조를 제대로 잡는 것이 아주 중요하다.  
		* 프로젝트 워크북의 구조를 초기부터 잡아두면 마구잡이로 문서화 되는 것을 막을 수 있고, 차후 작성될 문서들도 체계의 일부로 자연스레 흡수된다.  
		* 이 체계를 통해 정보를 목록화하면, 작업자는 필요한 문건을 쉽게 확인할 수 있다.  
		* 메모들을 계층화시켜서 배포 목록을 서브트리 단위로 관리할 수 있게 만들어 준다.  
	* 어떻게 운영하나?(과거편)  
		* 모든 프로그래머가 워크북의 사본을 1부씩 보유한다. 이 사본은 변경된 페이지를 교체하기 쉽게하기 위해 바인더 형태로 제작된다.  
		* 변경된 부분은 재빠르게 배포되며, 무엇이 변경되었는지 쉽게 알 수 있도록 하이라이팅과 변경 사항들 전체의 요약본을 함께 배포되어야 한다.  
		* 워크북 크기가 너무 커질경우 종이말고 다른 방법(microfiche 등)으로 물리적인 분량을 줄여야 한다.  
	* 어떻게 운영하나?(현재편)  
		* 워크북을 직접 접근식 파일에 두고 변경 표식과 개정 일자를 명기하는 방법이 좋을 것이다.  
		* 변경 사항은 계속 쌓이고, 프로그래머는 이 변경사항과 본문을 비교하면서 꾸준히 읽어 나가면 된다.  
	* 좋은 정보 시스템은 인터페이스상의 오류를 드러내기도 하지만, 그 오류의 정정 또한 고무시킨다.  
* 대규모 프로그래밍 프로젝트의 조직 구성  
	* 조직의 목적은 필요한 의사소통의 양과 팀 간 조율의 양을 줄이는 것이다.  
	* 일반적인 조직구조인 트리형태의 조직은 권한과 책임 구조로부터 파생된 것이기 때문에 그물망 형태인 의사소통 구조를 잘 반영하고 있지는 않다.  
	* 트리형 조직에서 의사소통을 줄이기 위한 방법 : 분업과 전문화  
	* 효율적 운영을 위해 하위 조직에서 반드시 갖춰야 할 핵심사항  
		1. 임무  
		2. 프로듀서  
		3. 기술 총괄 또는 아키텍트  
		4. 일정  
		5. 업무 분장  
		6. 각 파트 간 인테페이스 정의  
	* 프로듀서의 역할  
		1. 팀을 조직하고, 업무를 나누고 일정을 수립한다.  
		2. 필요한 자원을 지속적으로 확보하는 책임을 맡는다.  
		3. 팀 외부와 사방으로 소통하고, 팀 내의 의사소통 및 보고 체계를 수립한다.  
		4. 주위 환경의 변화에 대응하여 자원 투입과 조직 구성을 조정해가며 일정이 지켜질 수 있도록 한다.  
	* 기술 총괄의 역할  
		1. 설계를 구상하고, 하위요소를 결정하며, 시스템의 외부 구조를 명세하고, 내부 구조를 스케치한다.  
		2. 전체 설계에 통일성과 개념적 일관성을 부여하고, 시스템 복잡도를 관리한다.  
		3. 기술적 문제가 발생하면 해결책을 고안하거나, 설계를 변경한다.  
	* 프로듀서와 기술 총괄의 조합  
		1. 프로듀서와 기술 총괄이 같은 사람 : 3~6인 정도의 소규모 팀에 적합. 관리적 재능과 기술적 재능이 모두 뛰어난 사람은 찾기 힘들 뿐 아니라, 팀이 커지면 각 일이 한 사람이 맡을 규모가 아니게 된다.  
		2. 프로듀서가 수장, 기술 총괄이 오른팔 : 큰 규모의 조직에 적합. 기술 총괄을 명령 계통 상에 두어서 시간을 뺏기게 하지 않고도 기술적 결정에 대한 권위가 서도록 하는 것이 과제이다. 이것이 가능하려면 기본적인 기술적 철학에 대해 프로듀서와 기술 총괄이 같은 관점을 공유하고 있어야 한다. 효과적으로 운용될 수 있지만, 프로젝트 관리자가 관리능력 떨어지는 기술 분야 귀재를 잘 활용하는 경우는 드물다.  
		3. 기술 총괄이 수장, 프로듀서가 오른팔 : 기술 총괄이 기술적인 결정에 집중할 수 있도록 프로듀서가 보좌한다. 앞에서 말한 외과의 팀과 같은 중소규모 팀에 적합.
* **조직이란 현재 있는 사람들을 중심에 두고 구성하는 것이지, 이론적인 조직에다 사람을 끼워 맞추면 안된다.**

## 8. 예고 홈런

* 시스템 프로그래밍 작업에 들어가는 시간과 공수를 어떻게 추정할 수 있을까?  
* 추산 시의 주의점  
	1. 코딩 부분만을 추산한 뒤 전체 작업량을 추정해서는 안된다. 코딩이 전체에서 차지하는 비중은 낮다.  
	2. 독립된 소규모 프로그램에 대한 생산성 데이터로 시스템 전체를 추정하려고 하면 안된다.  
* 엄격히 비교는 곤란하지만, 작업에 드는 노력은 프로그램 크기의 거듭제곱에 비례하여 늘어나는 경향이 있다.  
* Nanus & Farr의 연구 : (투입공수) = (상수) * (명령문 개수)^1.5  
* 포트먼(Protman)의 데이터 : 개발팀이 일정을 절반 정도 밖에 지키지 못한다. 각 작업은 애초 추정보다 2배의 시간이 걸렸다. 이러한 일정 추정상의 오류는 기술적인 업무를 처리하는 시간에 대한 비현실적인 가정 때문에 일어난다.  
* 아론(Aron)의 데이터, 하(Harr)의 데이터, OS/360의 데이터 : 작업 자체의 복잡도 및 난이도와 관련된 생산성 차이가 현저하다.  
* 코르바토(Corbato)의 데이터 : 기본적인 문장 단위로 볼 때 생산성은 일정 수준으로 유지되는 경향이 있다. 또 적절한 고급 언어를 사용하면 생산성을 대략 5배까지도 끌어올릴 수 있다.  

## 9. 5파운드 자루에 담은 10파운드

* 프로그램의 크기 역시 비용이다. 따라서 꼭 필요한 만큼의 크기를 가질 수 있도록 목표치를 세우고 그것을 통제하여 크기를 줄일 수 있어야 한다.  
* 크기를 정하기 위해서는 각 요소 내의 절충 가능한 부분을 파악할 줄 알아야 하는 까다로운 일이다.  
	1. 메모리에 대한 목표치를 세우는 것만으로는 충분하지 않다. 상주 공간 뿐 아니라, ‘전체’공간의 크기를 가지고 예산을 배정하라. 또 보조 저장 장치 접근 빈도에도 제한을 두라.  
	2. 모듈의 크기를 정할 때는 그 모듈이 할 일도 명확히 하라.  
	3. 공간을 사용함에 있어서 전체적이고 사용자 중심적인 관점이 각 구현자 개인에게 필요하다.  
* 공간 절약에 관한 기법들  
	1. 기능과 크기 맞바꾸기
		* 사용자에게 선택의 여지가 많을수록 공간이 커진다. 사용자가 어느정도까지 세밀하게 할 수 있을지를 설계시에 결정해야 한다.  
		* 메모리가 제한된 시스템에서는 모듈의 크기도 제한되는데, 모듈이 너무 잘게 쪼개지면 속도에서 손해를 보게 된다. 그래서 소형 시스템에서 효율적인 시스템의 최대 크기는 제한을 받게 된다.  
	2. 메모리 공간과 실행 시간 사이의 적절한 타협 : 어떤 기능에 더 많은 공간을 할당한다면 더 빨리 수행될 수 있다.  
* 속도와 크기 사이에서 적절한 타협점을 찾도록 관리자가 팀을 돕는 법  
	1. 적절한 프로그래밍 기법에 대한 훈련을 받게 하고 이를 장려한다.  
	2. 프로그래밍에서의 기본적 구성요소들과 기법들을 개발하고 이를 공유하게 한다. 각 프로그램은 속도 우선 버전과 점유 공간 우선 버전으로 나누어져 기록되어야 한다.  
* 데이터 표현 방법만 바꿔도 속도와 공간면에서 획기적인 발전이 일어나는 경우가 많은데, 이 부분이 바로 프로그래밍의 정수라 할 수 있다.  

## 10. 기록물 가설

* 기록물 가설 : 온갖 서류의 홍수 속에서 몇몇 문서는 점차 모든 프로젝트 관리 업무가 그것을 중심으로 돌아가는 핵심적인 축이 된다. 이 문서들이 관리자의 주요한 개인 도구다.  
* 어떠한 관리 업무라도 그 관심사는 무엇은, 언제, 얼마나, 어디서, 누가 하느냐에 있다.  
* 소프트웨어 프로젝트의 문서들  
	1. 무엇을: 목표(요구사항, 최종 목표, 필요한 것, 제약 조건, 우선순위)  
	2.  무엇을: 제품 명세(제안서 -> 매뉴얼 및 내부 문서, 속도와 공간 명세가 핵심)  
	3. 언제 : 일정 
	4. 얼마나 : 예산  
	5. 어디서 : 공간 할당 
	6. 누가 : 조직도  
		* 시스템을 설계하는 조직은, 그 조직의 의사소통 구조를 본뜬 시스템을 만들어내게 되어있다.(Conway의 법칙)  
		* 최초의 조직도에는 첫 설계 내용이 반영되고, 그 설계가 제대로일 가능성은 낮으므로 조직은 언제나 변화에 대비해야한다.  
* 왜 형식을 갖춘 문서를 만드는가?  
	1. 글로 적는 과정이 필수불가결하기 때문이다. 글로 적는 과정에서 수많은 의사결정이 필요하고 이 과정을 통해 모순이 드러나고 정책이 더 분명해진다.  
	2. 결정된 내용을 다른이들에게 말보다 효과적으로 알릴 수 있기 때문이다.  
	3. 문서 자체가 데이터베이스와 체크리스트 역할을 하게 된다.  
* 소수의 핵심 문서가 관리자의 업무 대부분을 요약하고 있기 때문에, 관리자들은 이 문서의 유용성을 빠르게 간파하고, 문서들을 이용해야 한다.  

## 11. 버리기 위한 계획
* 대부분의 프로젝트에서 나온 첫 시스템은 쓸 수 없는 수준의 물건이다.
	* 답은 다시 설계해서 문제를 해결한 버전을 만드는 것 뿐이다.
	* 시스템의 재설계는 필연적이고, 미완성된 시스템을 납품한 댓가는 비싸다
* 변화를 하나의 생활 양식으로써 받아들여야 한다.
	* 하드웨어 제품은 변화가 쉽지 않기 때문에 변화에 대한 요구를 자제하게 되지만, 소프트웨어는 다루기 쉽고 형체가 없기 때문에 끝없는 변경 요구에 노출된다.
	* 목표와 요구 변경 사항을 모두 반영할 수 도, 할 필요도 없다. 반영하는 기준이 필요하고 개발이 진행될 수록 이 기준은 점점 높아져야 한다.
	* 하지만 목표가 얼마간은 변경되는 걸 피할 수 없기 때문에, 사전에 대비해 두는 편이 낫다.
* 변화에 대응하는 방법
	* 주의 깊은 모듈화
	* 광범위한 서브루틴의 사용
	* 모듈 간 인터페이스의 명확하고 완전한 정의
	* 모든 것에 대한 철저한 문서화
	* 표준 호출 절자 수립
	* 테이블 기반 기법 활용
	* 이외 여러가지 방법들…
* 중요한 것은 *고급 언어와 자체 문서화 기법을 사용하는 것* -> 변경 과정에서 비롯되는 오류를 줄일 수 있다.
* 변경 사항은 반드시 일정 묶음으로 처리되어야 한다.
	* 버전을 매겨야 한다.
	* 모든 버전은 고유 일정과 코드 프리즈 날짜를 가져야 한다
* 조직 전체가 기술적인 유연함을 가져야 한다. -> 관리자와 기술자가 임무를 교대할 수 있게 되어야 한다
	* 사회학적 장벽
		1. 선임자들을 실무에 투입하지 않으려 하는 경향
		2. 관리 쪽 직군이 더 중요시 되는 풍토
	* 해결책
		1. 관리직과 기술직에 단순히 급여 뿐 아니라 대등한 수준의 위신을 부여해야 한다. -> 현재의 경향상 기술쪽에 더 큰 보상을 해야 한다
		2. 관리자와 선임 기술자 모두 상대 직군의 훈련 과정을 이수하도록 할 필요가 있다.
		3. 재능이 허락하는 범위 안에서라면 선임자들이 관리, 기술적으로 직접 참여할 감정적,실력적인 준비가 되어야 한다. 
			* 외과의 팀을 꾸리는 것이 근본적 해답이다
			* 이러한 팀은 인터페이스 수를 최소화하게 된다.
* 프로그램 유지보수 측면에서도 기술적 유연함은 도움이 된다.
	* 유지보수의 근본적 문제 : 결함을 수정할 때 상당한 확률로 또 다른 결함이 유입된다.
		1. 시스템 전체에 미치는 결함도 국부적인 문제로 나타나기 때문에 진단이 쉽지 않다.
		2. 수리 담당자가 코드를 짠 당사자가 아니고, 직위도 낮은 경우가 많다.
	* 부작용을 없어내거 최소한 드러나도록 만드는 프로그램 설계 방법을 사용하고, 더 적은 인원이 인터페이스를 더 단순하게 구현한다면  유지보수에 이득을 볼 수 있을 것이다
		* 다만 시스템의 수정은 엔트로피를 상승시키는 행위이므로 결국 언젠가는 수리 불가능한 상태가 오고, 재설계하는 건 불가피하다.
## 12. 예리한 도구
* 숙련공들은 대부분 자신만의 도구들을 가지고 있다. 하지만 프로그래밍 프로젝트에서는 이것이 어리석은 짓일 수 있다
	1. 개별 도구는 의사소통을 방해한다.
	2. 장비나 언어가 바뀌면 도구가 바뀌므로 수명이 길지 않다.
	3. 범용 프로그래밍 도구를 공동으로 개발하고 유지 보수하는 편이 훨씬 더 효율적이다.
* 하지만 전문화된 요구와 개인적 선호라는 요소가 특화된 도구의 수요를 부추긴다.
* 팀에서의 도구 담당자의 역할
	1. 모든 공용 도구에 대한 숙련자가 된다.
	2. 상사에게 도구의 사용법을 가르쳐준다.
	3. 상사가 필요로 하는 특화된 도구들을 만든다.
* 프로젝트 관리자의 역할
	1.  공용 도구 제작과 관련된 정책을 세우고 자원을 확보해 둘 필요가 있다.
	2. 특화된 도구에 대한 필요를 인지하여 각 팀이 특화된 도구를 만드는 걸 못마땅하게 여기지 말아야 한다.
* 관리해야 할 도구
	1. 컴퓨터 장비
		1. 타깃장비 : 작성된 소프트웨어가 실행되는 장비
		2. 보조장비 : 시스템을 개발하는 과정에서 필요한 서비스를 제공하기 위한 장비
		3. 스케쥴링
	2. 보조장비와 데이터 서비스
		1. 시뮬레이터
		2. 컴파일러, 어셈블러
		3. 프로그램 라이브러리와 계정 관리
			1. 프로그램의 복사본이 관리자에게 속하며 해당 관리자만이 변경을 인가할 수 있다.
			2. 프로그래머 구역 -> 통합 -> 출시의 각 단계가 공식적으로 분리되어 단계적으로 진행된다.
		4. 프로그램 도구 -> 메모리 덤프, 스냅샷 덤프, 트레이스 등
		5. 문서화 시스템 
		6. 성능 시뮬레이터
* 오늘날 시스템 프로그래밍에서의 필수품 
	1. 고급 언어
	2. 대화식 프로그래밍

## 13. 전체 그리고 부분들

* 프로그램이 제대로 동작하도록 만들고, 테스트하고, 통합하려면 어떻게 해야할까?
	1. 버그를 줄이는 설계
		* 개념적 일관성을 갖춘 정의
		* 명세 테스트 : 코드 짜기 전에 충분한 검증을 거쳐 완전성과 명확성을 검토받아야 한다.
		* 하향식 설계 : 높은 추상화 단계부터 점점 내려가라
		* 구조적 프로그래밍
	2. 구성 요소 디버깅
		1. 온-머신 디버깅 : 디버깅 계획을 사전에 설계하여 정해진 세션 시간 내에 가능한  효율적으로 디버깅하게 함
		2. 메모리 덤프 : 오류 발생시 메모리 전체를 덤프하여 사후 분석을 시도
		3. 스냅샷 : 메모리 전체가 아닌 프로그램에 관련된 일부만 덤프
		4. 대화식 디버깅
		5. 테스트 케이스
	3. 시스템 디버깅
		* 디버깅 된 구성요소를 사용하라 : 검증되지 않은 구성요소를 사용함으로 얻는 혼란은 상당하다
		* 비계를 많이 만들라
		* 변경을 통제하라 : 모든 변경을 기록하고, 테스트와 문서화를 거친 수정사항과 응급조치를 구분해야 한다.
		* 구성 요소 추가는 한 번에 하나씩
		* 변경은 묶음으로 : 소소한 변화에 지속적으로 노출되지 않게 하라

## 14. 재앙의 알을 품다.

* 프로젝트에 엄청난 일정 지연이 일어났을 때, 그 원인은 큰 사건이 아니라 여러 자잘한 사건들의 누적이다.
* 마일스톤은 구체적이고 명확하고 측정 가능한 이벤트여야 하고, 분명하게 정의되어야 한다.
	* 불분명한 마일스톤은 일의 진행을 더욱 힘들게 하며, 잃어버린 시간을 어떻게 할 수 없는 지경까지  사람을 속여서 팀의 사기를 저하시킨다.
* 필요한 것 그 이상으로 열심히 하지 않으면 사소한 지연에 대비할 수 없다. (허슬) 또 이러한 사소한 지연은 재앙의 씨앗이 된다.
	* 하지만 모든 경우에 심각하게 반응할 수는 없기 때문에, 허슬이 깎이는 것을 감수하더라도, 어느 정도 계산된 반응은 필요하다.
	* 심각한 경우를 구분하기 위해서는 PERT차트, 임계 경로 계획법 등을 사용하는 것이 좋다.
* 일선 관리자는 사소한 문제를 덮어두려고 하고, 보스는 모든 팀의 상황을 파악하려 하는 점에서 갈등이 생기게 된다. 
	1. 역할 갈등 줄이기 : 행동이 필요한 정보와 상황 파악을 위한 정보를 구별하고, 관리자가 할 수 있는 일에 절대 나서지 않도록 스스로를 자제해야 한다. 
	2. 양탄자 젖히기 : 마일스톤과 실제 완료 시점을 나타내는 보고서를 통해 문제가 있음을 직접적으로 드러내게 한다.
		* 이 때 관리자들이 직접 보고하는 게 아니라 차트 작성과 보고를 전문적으로 담당하는 팀을 두어서 관리자들의 책무를 경감하고, 조기에 문제를 알리는 역할을  하게 하는 게 좋다.
		* 이 팀의 구성원은 숙련된 인원들로 두어 사소한 위험을 감지하고, 결정적인 요소를 강조할 수 있어야 한다.

## 15. 또 다른 면

* 프로그램은 인간이 기계에게 보내는 메세지이면서, 동시에 프로그램은 사용하는 인간에게 보내는 메세지이기도 하다. 때문에 문서화는 의사소통의 비용을 줄이기 위해 필수적이다.
* 어떤 문서가 필요한가?
	1. 프로그램 사용자 : 전체적인 개관 문서
		1. 목적
		2. 환경
		3. 정의역과 치역
		4. 구현된 기능들과 사용된 알고리즘
		5. 정확하고 빠짐없는 입출력 데이터 형식
		6. 작동 지침
		7. 옵션
		8. 실행시간
		9. 정밀도와 검증
	2. 프로그램 테스터 : 테스트 케이스 문서
		1. 통상 데이터로 이루어진 테스트 케이스
		2. 가장자리 조건을 검사하기 위한 유효한/무효한 테스트 케이스
	3. 프로그램 수정 담당자
		1. 순서도 또는 서브프로그램 구조 그래프
		2. 사용된 알고리즘에 대한 완전한 설명 또는 관련 문헌에 대한 참조 표시
		3. 사용된 모든 파일의 내부 레이아웃
		4. 데이터나 프로그램을 테이프 또는 디스크로부터 읽어들이는 순서의 개요, 각 단계의 설명
		5. 설계 원안에서 고려되었던 수정 사항에 대한 논의, 각종 후크와 종료 지점의 성질과 위치
		6. 바람직한 수정에 대한 소견
		7. 숨겨진 위험에 대한 소견
* 사실 순서도는 과거의 유물로 고급 언어를 체계적으로 쓴다면 없애버릴 수 있다.
* 코드와 문서를 따로 유지하는 것은 상당히 어려운 일이다. 따라서 문서의 내용이 코드안에 최대한 포함될 수 있도록 해야한다.
	1. 레이블, 선언문, 기호 등으로 코드에 최대한 많은 의미를 담는다.
	2. 가독성을 높이고 종속과 내포 구조를 드러내기 위해 공백과 서식을 활용한다.
	3. 상세 내용은 프로그램 안에 단락 형태의 주석문으로 삽입한다. 

## 16. 은탄환은 없다 - 소프트웨어 공학에 있어 본질과 부수성

* 소프트웨어 엔지니어가 하는 일의 본질은 소프트웨어를 이루는 개념적 구조를 설계하는 일이다. 그것을 코드로 옮기는 일은 부수적인 것이다
* 본질적인 일에 집중하기 위한 방법
	1. 구매할 수 있는 것이라면 직접 만들기보다 대량 판매용 제품을 활용하자
	2. 요구사항을 수립할 때는 계획된 반복 주기의 일부로 고속 프로토타이핑을 사용하자
	3. 새로운 기능은 테스트 이후에 시스템에 추가되도록 하여, 소프트웨어가 유기적으로 자라게 하자
	4. 떠오르는 세대에서 개념적 설계에 탁월한 이들을 찾아내 성장시키기
*   소프트웨어 제작의 본질적인 어려움 -> 이것을 한번에 해결해 줄 비법(은 탄환) 같은 건 없다.
	1. 복잡성 : 기술적, 관리적인 문제를 발생시키는 근본 원인이다. 
	2. 호환성 : 각 부분이 여러 사람에 의해 따로 설계되므로, 서로 맞추는 과정이 필수적이다.
	3. 변경 가능성 : 소프트웨어는 그것이 만들어진 문화적 환경보다 더 오래 살아남기 때문에, 환경의 변화에 따라 변경이 강제된다.
	4. 비가시성 : 소프트웨어의 구조를 아무리 한정짓고 단순화하더라도, 본질적으로 시각화 할 수는 없다.
* 부수적 어려움을 해결하는 과거의 성과들
	1. 고급언어 :부수적인 복잡성을 상당부분 제거한다.
	2. 시분할 방식 : 시스템의 응답시간을 낮춰서, 의식의 흐름이 끊어지는 것을 막는다.
	3. 통합된 프로그래밍 환경 : 여러 프로그램을 함께 사용하는 것이 쉬워지게 된다.
* 은 탄환에 대한 희망 -> 절대 근본적 해결책이 될 수 없다.
	1. 고급 언어로 인한 진보 : 이미 기계어에서 고급 언어로 넘어갔을 때 큰 덩어리의 부수적 어려움이 해결되었기 때문에 더 큰 진보를 기대할 수는 없다 -> 고급 언어가 주는 진보는 프로그래머들이 현대적인 소프트웨어 설계 기법을 연마하도록 하는 것이다.
	2. 객체 지향 프로그래밍 : 부수적 어려움을 없애는 데는 기여를 했지만,  본질적인 복잡성을 개선하는 데에는 기여하지 못한다.
	3. 인공지능 : 대부분의 성과가 문제에 특화되어 있어, 범용적으로 활용하기는 어렵다.
	4. 전문가 시스템 : 시스템 구축 이전에 전문가가 확보되어야 한다는 문제가 있다.  -> 미숙한 프로그래머가 최고의 프로그래머의 성과를 쉽게 이용할 수 있다는 측면에서 그 가치가 있다.
	5. 자동 프로그래밍 : 특정 응용에서는 효과적이나, 일반화되기는 어렵다.
	6. 그래픽 프로그래밍(시각적 프로그래밍) : 순서도의 근본적인 한계와, 한번에 볼 수 있는 정보량이 적다는 치명적인 문제가 존재한다. 그리고 시각화 자체가 어렵기도 하다.
	7. 프로그램 검증 : 검증에 드는 수고는 그 자체로도 큰 일이고, 검증 자체에도 오류의 가능성이 있다. 또, 아무리 완벽히 검증해도 그저 명세를 만족한다는 점만을 보장할 뿐이다.
		1. 개발 환경과 도구 : 이미 많은 부분들이 해결되어 있어, 큰 이득을 보기는 어렵다.
	8. 워크스테이션 : 컴파일 속도가 빨라져도 프로그래머가 생각하는 일이 줄어들지는 않는다.
* 개념적 본질을 겨냥한 유망한 시도들
	1. 살 것인가 만들 것인가 : 아무리 비싼 소프트웨어도 그것을 직접 만드는 비용보다 저렴하다.
	2. 요구 사항 상세화와 고속 프로토타이핑 
		* 소프트웨어 시스템 제작의 가장 어렵고, 잘못되었을 때 가장 치명적인 것은 기술적인 요구사항을 세세하게 수립하는 일이다.
		* 그래서 소프트웨어를 만들 때 가장 중요한 것은 제품 요구 사항을 반복적으로 추출하고 상세화하는 것이다. ->  고객도 사실 자기가 뭘 원하는 지 모른다. 그렇기 때문에 지속적으로 소통해야 한다.
		* 이 문제의 근본적 해결책은 빠른 프로토타이핑과 프로토타입과 실제 제품의 반복적 개발과 명세이다.
	3. 점진적 개발 : 오랜 시간 뒤의 완벽한 프로그램보다 지금 확인할 수 있는 단순한 프로그램이 낫다.
	4. 탁월한 설계자들 
		* 뛰어난 설계는 뛰어난 설계자들에게서 나온다. 평범한 설계자와 뛰어난 설계자의 차이는 어마어마하다.
		* 탁월한 설계자들은 매우 드물다. 따라서 자원을 들여 발굴하고 양성해내야 한다.
			* 체계적인 방식으로 가능한 한 일찍 찾아내야 한다.
			* 후보자의 개발을 책임질 멘토를 배정하고, 경력 파일을 주의 깊게 기록해야 한다.
			* 각 후보에 대한 경력 개발 계획을 수립하고 유지해야 한다. 
			* 성장하는 설계자들이 서로 소통하며 자극을 줄 수 있는 기회를 제공해야 한다.

## 17. ‘은 탄환은 없다’를 다시 쏘다.

*  본질적인 어려움이 해소될 가망은 없는가?
	* 복잡성이라 하면 단순히 프로그래밍 자체의 어려움 뿐 아니라, 응용 분야의 임의적인 복잡성 또한 포함한다.
	* 재사용, 호환성 있는 구성요소를 사용하면 소프트웨어 복잡성의 한 단계를 회피할 수 있다. 
	* 여러 층으로 된 모듈이나 객체들에 의한 계층적 복잡성, 시스템의 항시 동작을 위한 점진적 복잡성은 불가피한 복잡성이다.
* 지나치게 비관적이지 않았는가? : 오히려 이것마저도 낙관적이였음이 드러났다. 허황된 몽상은 발전을 저해하며 수고를 헛되게 한다.
* 자신이 ‘은 탄환’이라 주장한 여러 방법론들이 있지만, 그것은 절대 마법같은 것이 아니였다.
* 소프트웨어를 가시화하려는 노력은 좋은 시도지만, 이 역시 은 탄환은 아니다. 또 프로그래머들은 각자의 모델들을 가지고 있기 때문에 통일도 쉽지 않다.
* 생산성에 대한 주장들 
	* 품질을 추구하면 생산성은 자연스럽게 따라온다. -> 어느 정도는 맞는 말. 다만, 과도하게  품질을 추구하면 생산성이 떨어진다. 
		* 이는 소프트웨어 개발에 적용되 온 규율들이 생산성보다는 품질, 특히 대형 사
* 기존에는 맟춤 소프트웨어를 사용하던 분야들도 점점 커스터마이징이 자유로운 범용 패키지로 대체되고 있다.
* 객체지향은 충분히 좋은 방법론이지만, 선행 투자가 요구되고 그 이익이 늦게 온다는 점 때문에 결단하기 쉽지 않다. 
* 재사용은 표준화 정도에 따라 난이도가 달라진다. 또한 일반화의 필요성도 분야에 따라 달라진다.
* 프로그래밍에 사용되는 어휘는 점점 더 많아지고, 재사용을 위해서는 실제 자연어의 습득 방식과 유사한 과정을 통해 프로그래밍에 익숙해져야 한다.
* *결론 : 여전히 은탄환은 없다. 당면한 문제들을 점진적으로 해결해나가야 한다.*  

## 18. “맨먼스 미신”에 담긴 주장 : 진실 혹은 거짓

## 19. 맨먼스 미신, 20년 후

* 왜 “맨먼스 미신”이 20년 째 읽히고 있을까?
	1. 소프트웨어 개발 분야가 정상적으로 성장하지 않아서? -> 하드웨어 발전 속도가 이례적일 뿐이다.
	2. 소프트웨어에 대한 내용은 부수적일 뿐, 사람들이 팀을 이뤄 무언가를 만들기 위한 방법이 중심 주제이기 때문에? -> 어느정도 진실이다. 사람과 팀에 대한 내용을 담고 있는 한, 쉽사리 시대에 뒤떨어지지는 않을 것이다.
* 책의 내용에 대한 점검
	1. 개념적 일관성과 아키텍트 : 구현과 제품화로부터의 아키텍쳐 분리, 하위 아키텍트를 두는 구조들 -> 더욱 확신을 가지게 되었다.
	2. 두번째 시스템 효과 
		* 범용 도구를 설계하는 아키텍트는 별로 중요하지 않은 무거운 기능을 넣으려는 유혹에 빠지기 십상이다.
		* 사용자 규모가 크고 특징이 분명하지 않을 수록 개념적 일관성을 얻기 위해 사용자 군을 명시적으로 정의할 필요성이 더욱 커진다.(페르소나)
			* 그들은 누구인가?
			* 그들이 필요한 것은?
			* 그들이 필요하다고 생각하는 것은?
			* 그들이 원하는 것은?
		* 사용자 군의 전체 속성과 그 값 및 해당 빈도수는 아키텍처가 신중하게 ‘짐작’ 또는 ‘가정’해야 한다. 틀리더라도 명시적인 것이 훨씬 낫다.
	3.  WIMP(Window,Icon,Menu,Pointing device) 인터페이스의 대성공
		* 비유의 자연스러운 확장을 통해 개념적 일관성을 획득한 사용자 인터페이스의 훌륭한 사례 -> 현재 기술적 수준을 벗어나는 요구도 영리하게 해결
		* 하지만 양손을 사용하는 실제와 달리 커서는 하나밖에 없어 커서 하나가 양손의 역할을 모두 맡아야 하는 점은 비효율이다.
		* 키보드로 나머지 한 손을 대체할 수 있지만, 이러면 초보자가 사용하기는 어렵다.
		* 답은 이 두가지 체계를 모두 사용하게 하여, 초심자와 파워 유저를 모두 만족시키고 초심자가 파워 유저로 넘어갈 수 있게 하는 것이였다.
		* 특히 맥은 이러한 인터페이스를 미리 제공하고 사용하도록 장려해서 표준으로 자리잡게 해서, 개념적 일관성을 얻었다.
		* 하지만 동작 지정은 여전히 음성 인터페이스가 적합한 부분이기 때문에, 결국  WIMP도 대체될 것이다.
	4.  버리기 위해 만드는 것(폭포수 모델) : 확실하게 틀렸다!
		* 폭포수 모델의 오류 
			1. 프로젝트가 전체 과정을 한번만 거칠 것이라는 가정이 잘못되었다.
			2. 전체가 한번에 만들어 질 것이라는 가정이 잘못되었다.
		* 점진적 구현 모델이 훨씬 낫다!
			* 전체 과정을 담은 뼈대를 만들고, 살을 붙여나가는 방법
			* 소프트웨어를 가계도로 관리한다. 이때 별로 바뀌지 않을 것 같은 부분들을 최대한 루트 근처에 둔다.
			* 매일 밤 빌드를 실행하고, 빌드가 깨지면 더 이상 진행하지 않고 문제를 해결한다.
	5. 정보 은닉  : 기존에 주장했던 내용이 틀렸다고 인정한다
		* 밀스의 주장 : 프로그래밍이란 공개적인 과정이여야 하고, 모든 업무내용은 모두에게 공개되어야 한다.
		* 파르나스의 주장 : 코드의 모듈이 잘 정의된 인터페이스로 캡슐화 되어야 하며, 모듈 내부 구조는 담당한 프로그래머의 사유물로 외부에 노출되지 않아야 한다. -> 정보은닉, 소프트웨어 설계 수준을 높일 수 있는 유일한 방법
		* 밀스의 방법은 인터페이스에 담긴 상세한 의미를 파악하게 하는 장점이 있고, 파르나스의 방법은 변화에 강한 장점이 있다.
		* 파르나스의 방법은 이후 추상적 자료형, 상속 등을 추가한 객체 지향 프로그래밍으로 발전했다.
	6. 맨먼스는 어느 정도로 미신적인가?
		* 베리 보엠의 모델과 데이터(Software Engineering Economics) -> 인원수와 기간 사이의 절충은 전혀 선형적이지 않고, 맨먼스는 미신에 가깝다는 주장을 더욱 공고히 한다.
			*  첫 번째 출시에 대해 비용을 최적화 하는 일정, T = 2.5(MM)^(1/3)이 존재한다.
			* 계획된 일정이 최적치보다 길 경우 비용 곡선은 서서히 상승한다. 시간이 넉넉할 경우 작업이 더 천천히 이뤄진다.
			* 계획된 일정이 최적치보다 짧을 경우 비용 곡선은 급격히 상승한다.
			* 계산된 최적 일정의 3/4 이내에 성공적으로 끝난 프로젝트는 거의 없었고. 이것은 투입된 인원수와 무관하다.
		* 브룩스의 법칙(늦어진 소프트웨어 프로젝트에 인력을 투입하면 더욱 늦어진다)에 대한 평가
			* Software Project Dynamics - An Integrated Approach의 답
				* 언제나 비용을 증가시키지만 항상 더 늦게 완료되도록 하지는 않는다.
				* 일정 초반에 인원을 투입하는 것은 후반에 인원을 투입하는 것보다 훨씬 낫다
			* 슈투츠케(Stutzke)의 연구 -> 추가 투입 인원의 부정적 영향을 해소하기 위한 조치들에 대해 유용한 조언을 제공
				* 프로젝트에 뒤늦게 신규 투입되는 인원은 현재의 체계 안에서 기꺼이 협력하여 일하려는 팀 플레이어여야 하며, 기존 체계를 바꾸거가 개선하려 들면 안된다.
	7. 사람이 (거의) 전부다. 
		* 프로젝트 참여 인원들의 자질과 그 사람들을 어떻게 조직하고 관리하는 지가 다른 요소보다 훨씬 중요하다.
		* 프로젝트 이관은 대부분 원래 팀의 융합을 깨기 때문에 대부분 실패한다.
	8. 권력을 포기할 수 있는 권력 : 모든 것을 중앙에서 컨트롤하려 하지 말고 가능한 만큼 아래로 권력을 흘려 보내라. 팀은 발전할 수 있는 힘을 얻고, 중심부는 진짜 필요한 일만을 하며 권위를 얻을 수 있다.
	9. 마이크로컴퓨터 혁명
		* 컴퓨터 사용의 부수적 어려움을 제거함으로, 소프트웨어 개발 뿐 아니라 여러 분야의 업무 방식에 유동성을 가져다 주었다.
		* 기존에 시분할로 사용하던 시스템은 개인 워크스테이션으로 대체 되었고, 기존보다 더 편한 인터페이스를 통해 더 효과적으로 개발을 할 수 있게 되었다.
	10. 패키지 소프트웨어 시장의 등장
		* 고전적 소프트웨어 시장
			1. 자사 제품에 탑재할 운영체제, 컴파일러, 유틸리티 등을 제공하는 컴퓨터 제조사들
			2. 내부적으로 사용할 패키지를 만드는 응용프로그램 사용자
			3. 전용 패키지 제작
			4. 통계 분석, CAD 시스템 등 특수 시장 대상의 대규모 응용 프로그램을 개발하는 상용 패키지 개발자
		* 운영체제 분야는 개방형 시스템을 지향하며 점점 그 수가 적어진다.
		* 자유시장에 팔기 위한 패키지 소프트웨어는 자유분방함 속에서 개별 프로그래머의 능력에 의존하는 형태로 발전해왔고, 기여에 따른 더 큰 보상을 약속할 수 있어 새로운 프로그래머들을 끌어당기고 있다.
		*  패키지 사용자의 유형
			1. 있는 그대로 쓰기만 하는 사용자
			2. 패키지에서 제공하는 인터페이스를 이용한 메타 프로그래머
			3. 프로그램에 부가 함수를 직접 코딩해서 추가하는 외부 함수 제작자
			4. 패키지를 더 큰 시스템 내의 구성 요소로 사용하는 메타 프로그래머
* 소프트웨어 공학의 현황과 미래
	* 다른 공학에 비해 공학이라고 할만한 엄밀성을 찾기는 어렵다. 하지만 아직 미숙한 것이라고 생각한다.
	* 소프트웨어 시스템은 아마도 인류가 만들어 낸 가장 복잡한 창작물일 것이다.
	* 우리에게 요구되는 것
		* 끊임없는 업계의 발전
		* 더 큰 단위로 구성하기 위한 학습
		* 새로운 도구의 효과적인 활용
		* 검증된 공학적 관리 방법론의 도입
		* 상식의 자유로운 적용
		* 우리의 불완전함과 한계를 분별할, 신이 주신 겸손함