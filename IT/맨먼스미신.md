# 책 제목 : 맨먼스 미신

저자 : 프레더릭 브룩스  
역자 : 강중빈
출판사 : 인사이트  
출판년월 : 15/3  
페이지 : 362  

---  

- **프로그래밍을 관리하는 것은 왜 어려운가?**  
   1. 대규모 프로젝트는 업무 분배 때문에 소규모 프로젝트에는 없던 관리 문제가 생긴다.  
   2. 많은 사람의 의견이 모이기 때문에, 제품 자체의 개념적 일관성을 유지하기 어렵다.  

## 1. 타르 구덩이  

- 대규모 시스템 프로그래밍은 마치 타르 구덩이 같다.  
    1. 수많은 실력자들이 그 속에 빠져서 헤어나오기 힘들다.
    2. 어떻게 빠져 나오더라도 목표,일정,예산을 충족하는 경우는 드물다.  
    3. 타르 속에서는 멀쩡히 움직일 수 있는 것 처럼, 실패의 원인을 지목하기도 어렵지만, 여러 요인들이 동시 다발적이고 상호적으로 작용하면서 지나치게 복잡해진다.
        - 문제를 해결하기 위해서는 문제의 본질이 먼지 이해하려고 노력해야 한다.  
- 프로그래머(혹은 개발팀)이 만드는 것은 무엇인가?  
    1. 프로그램 : 자체적으로 완결적이고, 개발된 장비에서 개발한 사람에 의해 실행이 가능한 것  
        - 프로그래머 개인의 생산성 추정을 할 때 사용되는 것  
    2. 프로그래밍 제품 : 프로그램이 일반화 된 것. 누구든지 테스트,보수, 확장할 수 있고, 다양한 환경에서 여러 데이터에 적용될 수 있어야 한다.  
        - 일반화, 테스트, 문서화가 모두 철저히 이루어져야 한다.  
    3. 프로그래밍 시스템 : 상호 작용하는 여러 프로그램의 묶음, 다 합쳐진 상태에서 대규모 작업을 수행할 수 있게 만든 것  
        - 개별 프로그램은 시스템에서 정의한 인터페이스를 반드시 따라야만 한다.  
        - 규정된 자원만 사용하도록 섬세하게 설계되어야 한다.  
        - 다른 구성요소들과 조합 가능한 모든 경우에 대해 테스트 되어야 하며, 테스트가 제대로 되었다 해도 예기치 못한 상호작용으로 인한 문제가 일어날 수 있기 때문에 테스트에 드는 시간도 많이 든다.  
    4. 프로그래밍 시스템 제품 : 프로그래밍 시스템 + 프로그래밍 제품  
        - 대다수 시스템 프로그래밍이 목표로 하는 결과물  
- 프로그래밍은 왜 재미있는가?  
    1. 무언가를 만드는 데서 오는 순전한 기쁨  
    2. 다른 이들에게 쓸모있는 사물을 만드는 데서 오는 기쁨  
    3. 복잡한 퍼즐같은 것들이 그 안에 있는 법칙들에 따라 미묘한 순환을 이루며 돌아가는 것을 보는 매혹적인 경험  
    4. 지속적인 배움에서 오는 기쁨  
    5. 너무나도 유연하고 다루기 쉬운 표현 수단으로 작업하는 데서 오는 기쁨  
- 프로그래밍은 왜 고달픈가?  
    1. 완벽함이 요구된다.  
    2. 다른 사람들이 내 목표를 설정하고 자원과 정보를 제공한다.
    3. 다른 사람이 만든 프로그램에 대한 의존성을 해결하느라 시간이 허비된다  
    4. 장대한 개념을 설계하는 것은 재밌지만, 버그 잡는 것은 그저 일일 뿐이다.  
    5. 힘들게 만든 제품이 완성되었을 때, 혹은 완성되기도 전에 한 물 가서 퇴출되버린다.  
- 우리의 도전과 임무는 가용한 자원으로 실질적인 일정 내에서 현실의 문제에 대한 현실적인 해법을 찾는 데 있다.  

## 2. 맨먼스 미신  

- 부족한 시간 탓에 망가진 소프트웨어 프로젝트 수는 다른 이유로 그렇게 된 경우보다 훨씬 많다.  
    1. 우리의 추정 능력은 형편없다. 거기에 사실에 기반하지 않은 지나친 낙관이 반영되어 있기까지 하다.  
    2. 투입 공수(맨먼스)와 작업 진척도를 혼동한다. 즉 사람을 많이 투입하면 일이 빨리 끝날거라 생각한다.  
    3. 추정에 대한 자기 확신이 없기에, 정중한 고집이 결여되어 있다.  
    4. 일정 진척도가 제대로 모니터링 되고 있지 않다.  
    5. 일정이 어긋나는 것을 감지했을 때의 자연스러운 대응 방법이 인원 충원이다.  
- 프로그래머들은 다들 낙관성을 가지고 있다. 이러한 낙관론은 모든 작업이 예정내에 완료될 것이다'란 잘못된 가정의 원인이 된다.  
  - 아이디어는 그 자체가 결함이 있더라도, 구현되지 않으면 그 결함이 드러나지 않는다. 그래서 실제로 구현을 해보는 것은 필수적이다.
  - 프로그래밍의 재료는 다른 창작활동의 재료보다 다루기가 훨씬 쉽기 때문에, 구현도 쉬울 것이라고 오해한다. 하지만 아이디어 자체의 결함이 있을 수 있기에 버그는 필연적이고, 이러한 낙관주의는 정당성이 없어진다.  
  - 한 작업이 제대로 되더라도 다른 작업이 모두 일정에 맞출 가능성은 한없이 낮다
- 맨먼스는 비용 추산 지표일 뿐, 이것으로 작업 진척도를 잰다는 것은 위험하고 기만적인 미신이다.  
  - 사람과 일정이 교환 가능하기 위해서는 분업이 용이하고, 서로 소통할 필요가 없는 경우다. 시스템 프로그래밍은 이 두가지 모두 해당하지 않는다.  
    - 분업이 용이하지 않은 경우 : 각 작업 간에 의존성이 존재한다.  
    - 소통할 필요가 있는 경우 : 소통에 들어가는 비용 또한 전체 작업 계산에 포함되어야 한다. 소통은 훈련이 필요하고, 소통 자체에 들어가는 부담은 분업을 통해 얻을 수 있는 이득을 상회하기도 한다.  
  - 소프트워어 개발은 원래가 복잡한 상호 연관성을 가진 활동이기 때문에 사람을 더 투입하면 오히려 일정을 늘어지게 만든다.  
- 시스템에 대한 테스트는 쉽게 간과되기 때문에, 일정 예측이 빗나가는데 가장 큰 지분을 차지한다.  
  - 시스템 테스트에 충분한 시간을 배정하지 않으면, 결국 그 배정하지 않은 시간만큼 일정을 지연시키게 된다. 따라서 테스트에는 충분한 시간을 할애해야 한다.  (저자는 구성 요소 테스트&초기 테스트에 1/4, 전체 시스템 테스트에 1/4로 총 1/2의 시간을 할당하고, 1/3을 계획수립, 1/6의 시간만 코딩에 할당)  
  - 특히 프로젝트 말미에는 여러가지 관련 작업이 동시에 돌아가야 하기 때문에, 일정이 지연되면 2차적인 비용이 더 커지게 된다.  
- 고객의 긴급한 요청등에 의해 일정이 앞당겨 질 수도 있다. 하지만 그렇다고 그만큼 일이 빨리 진행되는 것은 아니고, 앞당겨진 일정만큼의 업무는 하지 않은 상태로 남아버린다.  
  - 이는 정량적인 추정을 하지않고, 이 추정을 뒷받침할 데이터가 없고 대부분 관리자들의 예감과 경험에 의존하기 때문에 이 추정을 적극적으로 방어할 수 없기 때문이다.  
  - 이를 해결하기 위해서는 생산성 수치, 버그 발생률, 추정 원칙등을 도입해 추정의 기반이 견고해져야 하고, 관리자들은 그 기반이 견고해질 때까지는 스스로가 당당하게 추정치를 방어해야 한다.  
- 어떤 프로젝트가 일정에 뒤쳐지고 있을 때, 원래의 계획에 맞추기 위해 섣불리 인력을 투자하는 행위는 무조건 원하는 결과를 얻어내지 못한다.  
  - 새로 투입된 멤버가 바로 일할 수는 없다. 기존 멤버에게 훈련을 받아야하고, 그 기간동안은 기존 멤버도 일을 제대로 할 수 없다. 또 기존 인원에 맞게 분할된 일을 다시 나눠야 하므로, 진행된 작업 중 일부는 재사용이 불가능해 날리게 될 것이다. 결국 인원을 늘려도 일정에 맞추는 것은 요원하기만 하다.  
  - 일정에 맞추지 못했기 때문에, 관리자는 더 많은 인원을 투입하려는 유혹에 빠지게 된다. 하지만 이는 다시 위의 문제를 일으키고, 프로젝트는 점점 더 악화된다.  
  - 이렇게 거듭되는 문제 끝에 나온 결과물은, 원래 인원을 유지하며 일정을 재수립했을 때보다 더 못하리라는 것은 자명하다.  
  - **늦어진 소프트웨어 프로젝트에 인력을 추가로 투입하면 더 늦어지게 된다.**  
- 프로젝트에 소요되는 기간은 순서대로 처리해야하는 내부 요소에 좌우되며, 필요한 최대 인원수는 독립된 하위 작업의 개수에 좌우된다. 무조건 인원이 많다고, 시간이 부족하단 이유로 재촉한다고 일이 잘되는 게 아니다.  
  - 이 두가지 수치를 파악해야지만 관리자는 더 적은 수의 사람과 더 긴 기간에 기초한 합리적인 일정을 수립할 수 있다.  
  - 그래도 제품이 시대에 뒤쳐지는 것은 어쩔 수 없지만...

## 3. 외과 수술 팀  

- 작은 팀 vs 큰 팀, 어떤 것이 답일까?  
  1. 효율적 개념과 일관성을 위해서는 적은 인원으로 팀을 구성하는 게 훨씬 낫다.
  2. 하지만 아무리 뛰어난 프로그래머들을 모아놓아도 작은 팀이라면 큰 시스템을 의미있는 시간내에 만들어 내지 못한다. 큰 시스템은 원래 만드는 데 많은 작업이 필요한 법이다.  
- 할란 밀스(Halan Mills)의 해결책 : 커다란 전체 업무를 여러 팀에 나눠 맡기되, 각 팀을 외과 수술 팀 처럼 조직하라.  
  - 즉, 한 명이 주도적으로 문제를 해결해 가는 동안, 다른 사람은 그 사람의 효율과 생산성을 높이기 위해 지원하는 체제  
  - 이 방법이면 설계와 구축에 적은 인원이 들어가면서, 작업에는 많은 인원이 투입되게 된다.  
- 일을 어떻게 나누고, 어떤 역할을 부여할 것인가?  
  1. 외과의(수석 프로그래머) : 기능과 성능 명세를 직접 정의하며, 설계, 코딩,테스트, 문서화 등 모든 작업에 관여한다. 재능, 경력, 시스템 및 응용 분야에 대한 지식 등에서 상당한 수준이 요구된다.  
  2. 부조종사 : 외과의의 분신, 올라운더지만 경험이 많지는 않다. 주 역할은 설계 과정에 참여하여 같이 고민하고 토론하고 평가하는 것이다. 종종 팀을 대표하기도 하며, 모든 코드를 파악하고 대안적 설계에 대한 전략을 연구한다. 코드를 만들수도 있지만 책임은 지지 않는다.  
  3. 행정 담당 : 외과의를 대신해 행정 업무를 수행하는 사람. 다만, 꼭 필요한 경우에만(법률적, 계약적 중대 사안이 있는 경우, 보고를 강화해야 하거나, 재무적 이슈가 있을때) 전일제로 두어야 한명의 행정 담당이 여러 팀에 걸칠 수도 있다.  
  4. 편집자 : 외과의가 작성한 초안이나 구술 원고를 비평,수정,보충,관리하는 등의 역할  
  5. 비서 : 행정 담당과 편집자 각각 한 명씩, 총 두 명의 비서가 필요하다. 프로젝트 관련 우편물과 일반적인 업무 서류를 담당한다.  
  6. 프로그램 사무원 : 팀에서 생산되는 모든 기술적 산출물을 하나의 프로그래밍 제품 라이브러리로 관리할 책임을 진다. 기계가 읽을 파일과 사람이 읽기 위한 파일 모두 담당한다. 팀의 반복적인 사무 작업을 덜어주고 등한시되는 그런 작업들이 잘 진행되도록 하여, 작업 산출물을 향상 시킨다.  
      - 핵심은 프로그래밍이라는 작업을 '개인적인 예술'에서 '공게적인 실행'으로 바꾸는 것이다.  
  7. 도구 담당 : 이전처럼 팀별로 자체적인 장비와 운영요원을 필요로 하지는 않는 시대지만, 외과의를 대신하여 팀 전체가 사용하는 도구들이 적합한지 확인해주고, 팀 자체적인 도구들을 구축하고 유지보수하는 사람은 반드시 필요하다.  
  8. 테스터 : 테스트 케이스를 만들고, 테스트 데이터를 제공한다. 또한 테스트 순서를 계획하고, 구성 요소를 테스트를 위한 얼개를 짜기도 한다.  
  9. 언어 마스터 : 새로운 언어를 익히고 복잡한 문제에 대해 특정 언어를 사용한 더 깔끔하고 효율적인 방법을 연구한다. 여러 팀에 걸쳐 자문역할을 하기도 한다.  
- 이러한 팀은 동등한 지위를 가지고 분업하는 팀과 다르게 다음과 같은 이유로 한 사람처럼 행동할 수 있게 된다.  
  1. 외과의와 부조종사 모두 전체 설계와 구현을 다 알고 있으므로, 서로 조율하는 수고가 줄어들고, 개념적 일관성 또한 보장된다.  
  2. 팀 안에서의 불가피한 의견 차이가 외과의에 의해 일방적으로 정리된다.  
- 대규모 작업에서는 10명 가지고는 안되지만, 여러 외과의 팀이 모이면 이러한 작업이 가능하다. 각 부분의 개념적 일관성이 보장이 되었기 때문에, 각 외과의들간의 조율 문제만 해결하면 되는 것이다.  
- 하지만 이 외과의들 간의 조율에는 또 다른 기법이 필요하다. 우선은 '전체 시스템 역시 개념적 일관성을 가져야 하고, 한명의 시스템 아키텍트가 시스템 전부를 하향식으로 설계할 필요가 있다'라고 요약된다.  
- 이를 위해서는 구현과 아키텍처를 명확히 구분해야 하고, 시스템 아키텍트는 자신의 역할을 철저히 아키텍처 쪽으로만 국한해야한다.  

## 4. 귀족 정치, 민주주의, 시스템 설계  

