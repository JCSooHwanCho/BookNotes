# 책 제목 : 클린 아키텍처 - 소프트웨어 구조의 설계와 원칙

저자 : 로버트 C. 마틴
역자 : 송준이 
출판사 : 인사이트  
출판년월 : 2019/8  
페이지 : 406  

---

## 소개 

* 설계와 아키텍처
	* 설계 : 주로 저수준의 구조 또는 결정사항등을 의미할 때가 많다.
	* 아키텍처: 저수준의 세부사항과는 분리된 고수준의 무언가
	* 설계와 아키텍처는 개별로 존재할 수 없고, 이 둘을 구분짓는 경계도 뚜렷하지 않다. 단지 고수준에서 저수준으로 향하는 의사결정의 연속일 뿐.
  
* 의사결정의 목표 : 필요한 시스템을 만들고 유지보수하는 데 필요한 인력과 비용을 최소화하기 위해서이다. -> 그 어떤 경우에도 지저분한 코드는 받아들여서는 안된다.
	* 빨리 가는 유일한 방법은 제대로 가는 것이다.
  
* 소프트웨어가 제공하는 가치
	* 행위: 특정 문제를 해결하기 위한 소프트웨어의 동작. 요구사항을 구체화해가는 과정을 통해 이루어진다 -> 대부분의 프로그래머가  중요히 여기는 것
	* 아키텍처(구조): 행위를 하기 위한 작업구조. -> Software의 특성상 변경이 쉬워야만 한다. 그렇지 않으면 시간이 지날수록 변경 비용이 상승한다.
		* 변경에 드는 비용은 변경의 범위(Scope)에 비례해야 하며, 형태에 대해서는 독립적이다.
		* 아키텍처가 요구사항의 형태에 독립적일수록 더욱 실용적이다.
  
*  행위와 아키텍처 중 뭐가 중요한가? -> 동작하지 않더라도 변경이 쉬운 프로그램이 낫다. 고쳐쓸 수 있기 때문에.
	* 개발자는 다른 이해관계자들과의 씨름에서, 소프트웨어를 안전하게 지킬 책임이 있다.

## 프로그래밍 패러다임

* 프로그래밍 패러다임의 종류
	* 구조적 프로그래밍: 제어흐름의 직접적인 전환(goto문)에 대한 규칙을 부과한다 
	* 객체 지향 프로그래밍: 제어흐름의 간접적인 전환(함수 포인터)에 규칙을 부과한다(함수 호출 스택 프레임을 힙으로 옮기는 것)
	* 함수형 프로그래밍: 할당문에 규칙을 부여한다.(불변성)
	* 이외의 프로그래밍 패러다임은 나올 수 있을까? -> 패러다임은 프로그래머에게 제약을 가하는 것.  goto문, 함수 포인터,  할당문 이외에 더 제약해서 얻을게 없는 이상은 새로운 게 나올 수 없고 나오지 않을 가능성이 높다.
  
* 구조적 프로그래밍: 프로그램을 순차, 분기, 반복의 3가지만으로 표현할 수 있다. 이렇게 만들어진 프로그램은 입증이 가능하다.
	* goto문은 아예 없거나 있더라도 제한적으로만 쓰이게 되었다.
	* 모듈을 재귀적으로 분해하고, 이렇게 분해된 모듈은 구조적 프로그래밍의 제어구조로 만들 수 있다.
	* 유클리드 계층구조를 구성해 수학적인 증명을 하려 했던 노력은 실패했다. 이를 대신해서 과학적 방법(Scientific Method)가 사용되게 되었다. -> 거짓임을 밝힐 수는 있지만, 참임을 밝힐 수는 없다.
	* 소프트웨어 개발은 수학적 구조를 다루는 듯 보이지만, 오히려 과학에 더 가깝다. 
	* 아키텍트는 모듈, 컴포넌트, 서비스가 쉽게 반증 가능하도록(테스트가 가능하도록) 만들어야 한다.
  
* 객체 지향 프로그래밍: (아키텍트 입장에서) 다형성을 이용하여 전체 시스템 모든 소스 코드 의존성에 대한 절대적인 제어 권한을 획득할 수 있는 능력
	* 캡슐화가 OOP? - C에서도 캡슐화는 가능, 오히려 OOP 언어가 캡슐화를 엄밀히 하지 않는 경우가 많다. -> 접근 제어는 이 깨진 캡슐화를 보완하기 위한 방책일 뿐
	* 상속이 OOP? - 단일 상속은 이미 C에서도 사용하던 기법. 다만 좀 더 편리한 방법을 제공할 뿐
	* 다형성이 OOP? -  C언어도 다형성 구현 가능, 다만 함수 포인터를 써야 하기 때문에 위험하다. OOP언어는 이를 안전하게 사용하는 방법을 제공한다.
	* 결론: OOP는 구조적 프로그래밍 언어(대표적으로 C언어)가 줄 수 없는 강력한 안정성을 제공해준다.
	* 그 중에서도 중요한 건 다형성 -> 기존 제어 흐름에 따른 의존성을 역전시켜준다!
		* 비즈니스 로직 이외의 부분들(부가적인 부분들)이 비즈니스 로직에 의존하고, 비즈니스 로직은 독립적으로 유지할 수 있다.
  
* 함수형 프로그래밍: 불변성과 참조 투명한 함수만을 사용하는 방법 -> 순수 함수형이 아닌 경우는 가변 변수를 사용할 수도 있다. 
	* 애플리케이션의 불변 영역과 가변 영역을 나눈다. -> 가변 변수 영역을 최대한 줄이고, 가변 변수를 보호할 수단을 갖춰야 한다.
	* 이벤트 소싱: 상태가 아닌 트랜잭션 자체를 무한히 저장하는 것(CRUD에서 CR만 한다) -> 저장 공간이 많이 필요하다는 단점이 있다. 하지만 완전한 불변성을 구현할 수 있다는 장점이 있다. (버전 관리 시스템을 생각하면 된다)

* 소프트웨어는 급격히 발전하는 기술이 아니다. -> 도구와 하드웨어는 달라졌지만, 소프트웨어의 핵심은 그대로다
	* 소프트웨어의 구성요소: 순차(sequence), 분기(selection), 반복(Iteration), 참조(indirection)

## 설계 원칙 - SOLID 
* 목적 : 중간 수준(모듈 수준)의 소프트웨어 구조를 다음과 같이 만들기 위함
	* 변경에 유연하다.
	* 이해하기 쉽다
	* 많은 소프트웨어 시스템에 사용될 수 있는 컴포넌트의 기반이 된다.

* 원칙의 종류
  * SRP(Single Responsibility Principle, 단일 책임 원칙) : '콘웨이의 법칙'에서 유도된 법칙으로, 최적의 구조는 시스템을 만드는 조식의 사회적 구조에 큰 영향을 받는다. 따라서 각 소프트웨어의 모듈은 변경의 이유가 오직 하나여야 한다.
	* OCP(Open-Closed Principle, 개방 패쇄 원칙): 기존 코드를 수정하지 않고, 새로운 코드를 추가하는 방식으로 시스템의 행위를 변경할 수 있도록 만들어야 한다. (추가에는 열려있고, 수정에는 닫혀있다)
	* LSP(Liskov Substitution Principle, 리스코프 치환 원칙): 상호 대체 가능한 구성요소를 이용해 소프트웨어 시스템을 만들 수 있으려면, 이들 구성 요소는 반드시 서로 치환 가능해야 한다.
	* ISP(Interface Segregation Principle, 인터페이스 분리 원칙): 소프트웨어 설계자는 사용하지 않은 것에 의존하지 않아야 한다.
	* DIP(Dependency Inversion Principle, 의존성 역전 원칙): 고수준 정책을 구현하는 코드는 저수준 세부사항에 의존하면 안된다. 오히려 세부사항이 정책에 의존해야 한다.

* SRP: 하나의 모듈은 오직 하나의 액터에 대해서만 책임쳐야 한다.
	* 모듈: 소스 파일, 혹은 함수와 데이터 구조로 구성된 응집된 집합.
		* 응집성(cohesion): SRP를 암시하며, 단일 액터를 책임지는 코드를 함께 묶어주는 힘
	* 액터: 변경을 요청하는 한 명 이상의 사람
	* SRP 위반 징후
		* 우발적 중복: 한 클래스의 메서드가 2가지 이상의 액터에 의해 사용된다. 둘 중 한쪽에서만 이를 변경하고 싶은 경우에 문제가 된다.
		* 병합: 수정에 영향을 받는 영역이 너무 넓어서, 충돌이 잦다.
	* 해결책: 메소드들을 별도 클래스로 분리한다. 
		* 데이터만 담는 객체를 만들고, 분리된 메소드들이 담긴 클래스들이 각자 이를 참조하도록 한다.
		* 클래스가 너무 많아 관리가 어렵다면 퍼사드(Facade) 기법을 적용할 수 있다.
		* 모든 메소드를 빼지 않고, 가장 중요한 메소드는 원래 클래스에 남겨 놓을 수도 있다.
	* 상위 수준에서 SRP는 다른 형태로 나타난다.
		* 컴포넌트 수준: 공동 폐쇄 원칙(Common Closure Principle)
		* 아키텍처 수준: 아키텍처 경계(Architectural Boundary)의 생성을 책임지는 변경의 축(Axis of Change)이 된다.

* OCP: 소프트웨어 개체(artifact)는 확장에는 열려있어야 하고, 변경에는 닫혀있어야 한다. -> 소프트웨어 아키텍처를 공부하는 가장 근본적인 이유
	* 시스템을 확장하기 쉬운 동시에 변경으로 인해 너무 많은 영향을 받지 않도록 하는데 그 목적이 있다.
	* 시스템을 컴포넌트 단위로 분리하고, 저수준 컴포넌트의 변경이 고수준 컴포넌트에게 영향을 미치지 않을 수 있는 의존성 계층구조가 만들어지도록 해야한다.
  
* LSP: 프로그램의 구성요소(여기서는 특정 타입의 서브클래스)는 서로 간의 치환이 가능해야 한다. -> 치환이 불가능하다면 이에 대처하기 위한 별도 매커니즘이 덕지덕지 붙어 아키텍처가 오염된다.

* ISP: 필요이상으로 많은 것을 가진 모듈에 의존해서는 안된다. -> 연관없는 부분때문에 재컴파일의 필요가 생길 수 있다.

* DIP: 소스 코드 의존성이 추상(abstraction)에 의존하며, 구체(concretion)에 의존하면 안된다. -> 뒷부분에서 의존성 규칙(Dependency Rule)로 불린다.
	* 운영체제나 플랫폼에서 제공하는 모듈은 변경이 거의 없고, 이를 예측할 수 있기 때문에 이는 예외로 둔다. -> DIP가 적용되어야 하는 모듈은 자주 변경되는 모듈이다.
	* 변동성이 큰 구체 클래스를 참조하지 말라 -> 객체 생성 방식을 강하게 제한하며, 추상팩토리가 일반적으로 사용된다.
	* 변동성이 큰 구체 클래스로부터 파생하지 말라 -> 상속은 강력한 의존성을 불러온다.
	* 구체 함수를 오버라이드 하지 말아라 -> 구체함수를 오버라이드 하면 의존성을 줄일 수가 없게 된다. 추상 함수로 선언하고 구현체들에서 각자의 용도에 맞게 구현해야 한다.

## 컴포넌트 원칙

* 컴포넌트: 시스템의 구성요소로 배포할 수 있는 가장 작은 단위 ->  jar, gem, dll 등
	* 컴파일형 언어에서는 바이너리 파일의 결합체, 인터프리터 언어에서는 소스파일의 결합체
	* 여러 컴포넌트를 서로 링크하여, 실행가능한 단일 파일로 만들거나, 여러 컴포넌트를 묶어 단일 아카이브로 만들거나, 컴포넌트 각각을 독립적으로 배포할 수도 있다.
	* 어떤 형태로 배포되던, 잘 설계된 컴포넌트는 반드시 독립적으로 배포 가능한, 즉, 독립적으로 개발 가능한 능력을 갖춰야 한다.

* 컴포넌트 응집도 관련 원칙
	* REP(Reuse/Release Equivalence Principle): 릴리즈가 추적 관리되지 않거나, 릴리즈 번호가 부여되지 않으면 해당 컴포넌트는 재사용 될 수 없다.
		* 단일 컴포넌트는 응집성 높은 클래스와 모듈로 구성되어야 한다 -> CCP,CRP와 연관된다.
	* CCP(Common Closure Principle): 동일한 이유로 동일한 시점에 변경되는 클래스는 같은 컴포넌트로, 서로 다른 시점에 다른 이유로 변경되는 클래스는 다른 컴포넌트로 분리해야 한다. -> SRP의 컴포넌트 버전, OCP와도 관련이 있다.
	* CRP(Common Reuse Principle): 컴포넌트 사용자들이 필요하지 않은 것에 의존하게 강요하지 말라 -> ISP의 컴포넌트 버전
	* 세가지 원리는 서로 상충하며, 현재 개발 상황에 따라 주의를 기울이는 부분이 달라져야 한다. (재사용성과 유지보수성의 균형)

* 컴포넌트 결합 관련 원칙
	* ADP(Acyclic Dependency Principle): 컴포넌트 의존성 그래프에 순환이 있어서는 안된다. -> 순환이 있으면 컴포넌트 하나의 변경이 수많은 컴포넌트의 변경을 가져오고, 영원히 끝나지 않는 굴레에 빠지게 된다.
		* 주 단위 빌드(Weekly Build): 5일 중 4일은 각자 작업하고, 금요일에 통합빌드를 한다 -> 4일은 편하지만, 금요일에 막대한 비용을 치뤄야한다. 이 비용은 점차 커지며, 점점 주 단위 빌드를 어렵게 한다.
		* 개발 환경을 릴리스 가능한 컴포넌트 단위로 분리하기
			*  컴포넌트는 한 명의 개발자 혹은 한 개발팀이 책임지는 작업 단위. 개발팀은 별도의 작업 공간에서 작업하고 이를 릴리스하며, 다른 팀을 릴리스 된 것을 사용하고 새로운 버전을 사용할 지 아닐지에 대한 판단을 한다.
			* 통합은 작고 점진적으로 이루어진다.
			* 이 절차가 성공적으로 동작하려면, 반드시 컴포넌트 사이의 의존성을 관리해야 한다.  -> 의존성에 순환이 생기면 이 자율성이 사라진다.
				* DIP 적용
				* 새로운 컴포넌트를 만들어서 순환의 원인이 되는 클래스들을 새로운 컴포넌트로 이동시킨다.
			* 컴포넌트 구조는 계속해서 변해야 하기 때문에, 처음에 설계하고 갈 수 있는 것이 아니고 시스템의 성장과 변경에 맞춰 진화하는 것이다.
	* SDP(Stable Dependency Principle) : 더 안정된 쪽에 의존하라
		* 아무리 변동이 쉽게 만들어진 컴포넌트도, 다른 컴포넌트가 자신에게 의존하면 변경이 어려워진다.
		* 안정적이다: 변경이 어렵다. 또 변경의 필요성도 크지 않다. -> 여러 요인이 있지만, 여기서는 의존성에 촛점을 둔다. 자신을 의존하는 컴포넌트가 많을수록 변화가 힘들어 안정적이다. 또 자신이 의존하는 컴포넌트가 있다면, 의존하는 컴포넌트의 변화에 맞춰 자신도 맞춰야 하는 강제성이 생긴다.
		* 안정적인 컴포넌트가 불안정한 컴포넌트를 의존하게 되면 수정이 잦아지면서 덩달아 불안정해진다.
	* SAP(Stable Abstraction Principle): 컴포넌트는 안정된 정도만큼만 추상화되어야 한다.
		* 안정적인 컴포넌트라면 반드시 인터페이스와 추상 클래스로 구성되어 쉽게 확장할 수 있어야 한다.
		* 반대로 불안정한 컴포넌트는 반드시 구체 컴포넌트로 구성되어 쉽게 수정할수 있어야 한다.
		* 피해야할 구조
			* 고통의 구역: 안정적이며 구체적이다.  확장도 어렵고, 변경도 어렵다. -> 일부 소프트웨어 엔티티는 여기 속할 수 밖에 없기도 하다(데이터베이스 스키마, 구체적인 유틸리티 라이브러리 등), 그래도 변동성이 없는 컴포넌트는 여기 있어도 해롭지 않다.
			* 쓸모없는 구역: 변동성이 높고, 추상적이다 -> 아무도 쓰지 않는 추상 클래스. 
		* 바람직한 구조: 피해야 할 구조에서 가장 먼 구역 -> 주계열(Main Sequence -> 원래는 천문학 용어)
			* 주계열에서의 거리를 기반으로 설계를 통계적으로 분석해 볼 수 있다. -> 다만 지표를 절대적으로 신봉하지는 말것