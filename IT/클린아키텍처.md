# 책 제목 : 클린 아키텍처 - 소프트웨어 구조의 설계와 원칙

저자 : 로버트 C. 마틴
역자 : 송준이 
출판사 : 인사이트  
출판년월 : 2019/8  
페이지 : 406  

---

## 소개 

* 설계와 아키텍처
	* 설계 : 주로 저수준의 구조 또는 결정사항등을 의미할 때가 많다.
	* 아키텍처: 저수준의 세부사항과는 분리된 고수준의 무언가
	* 설계와 아키텍처는 개별로 존재할 수 없고, 이 둘을 구분짓는 경계도 뚜렷하지 않다. 단지 고수준에서 저수준으로 향하는 의사결정의 연속일 뿐.
* 의사결정의 목표 : 필요한 시스템을 만들고 유지보수하는 데 필요한 인력과 비용을 최소화하기 위해서이다. -> 그 어떤 경우에도 지저분한 코드는 받아들여서는 안된다.
	* 빨리 가는 유일한 방법은 제대로 가는 것이다.
* 소프트웨어가 제공하는 가치
	* 행위: 특정 문제를 해결하기 위한 소프트웨어의 동작. 요구사항을 구체화해가는 과정을 통해 이루어진다 -> 대부분의 프로그래머가  중요히 여기는 것
	* 아키텍처(구조): 행위를 하기 위한 작업구조. -> Software의 특성상 변경이 쉬워야만 한다. 그렇지 않으면 시간이 지날수록 변경 비용이 상승한다.
		* 변경에 드는 비용은 변경의 범위(Scope)에 비례해야 하며, 형태에 대해서는 독립적이다.
		* 아키텍처가 요구사항의 형태에 독립적일수록 더욱 실용적이다.
*  행위와 아키텍처 중 뭐가 중요한가? -> 동작하지 않더라도 변경이 쉬운 프로그램이 낫다. 고쳐쓸 수 있기 때문에.
	* 개발자는 다른 이해관계자들과의 씨름에서, 소프트웨어를 안전하게 지킬 책임이 있다.

## 프로그래밍 패러다임

* 프로그래밍 패러다임의 종류
	* 구조적 프로그래밍: 제어흐름의 직접적인 전환(goto문)에 대한 규칙을 부과한다 
	* 객체 지향 프로그래밍: 제어흐름의 간접적인 전환(함수 포인터)에 규칙을 부과한다(함수 호출 스택 프레임을 힙으로 옮기는 것)
	* 함수형 프로그래밍: 할당문에 규칙을 부여한다.(불변성)
	* 이외의 프로그래밍 패러다임은 나올 수 있을까? -> 패러다임은 프로그래머에게 제약을 가하는 것.  goto문, 함수 포인터,  할당문 이외에 더 제약해서 얻을게 없는 이상은 새로운 게 나올 수 없고 나오지 않을 가능성이 높다.
* 구조적 프로그래밍: 프로그램을 순차, 분기, 반복의 3가지만으로 표현할 수 있다. 이렇게 만들어진 프로그램은 입증이 가능하다.
	* goto문은 아예 없거나 있더라도 제한적으로만 쓰이게 되었다.
	* 모듈을 재귀적으로 분해하고, 이렇게 분해된 모듈은 구조적 프로그래밍의 제어구조로 만들 수 있다.
	* 유클리드 계층구조를 구성해 수학적인 증명을 하려 했던 노력은 실패했다. 이를 대신해서 과학적 방법(Scientific Method)가 사용되게 되었다. -> 거짓임을 밝힐 수는 있지만, 참임을 밝힐 수는 없다.
	* 소프트웨어 개발은 수학적 구조를 다루는 듯 보이지만, 오히려 과학에 더 가깝다. 
	* 아키텍트는 모듈, 컴포넌트, 서비스가 쉽게 반증 가능하도록(테스트가 가능하도록) 만들어야 한다.
* 객체 지향 프로그래밍: (아키텍트 입장에서) 다형성을 이용하여 전체 시스템 모든 소스 코드 의존성에 대한 절대적인 제어 권한을 획득할 수 있는 능력
	* 캡슐화가 OOP? - C에서도 캡슐화는 가능, 오히려 OOP 언어가 캡슐화를 엄밀히 하지 않는 경우가 많다. -> 접근 제어는 이 깨진 캡슐화를 보완하기 위한 방책일 뿐
	* 상속이 OOP? - 단일 상속은 이미 C에서도 사용하던 기법. 다만 좀 더 편리한 방법을 제공할 뿐
	* 다형성이 OOP? -  C언어도 다형성 구현 가능, 다만 함수 포인터를 써야 하기 때문에 위험하다. OOP언어는 이를 안전하게 사용하는 방법을 제공한다.
	* 결론: OOP는 구조적 프로그래밍 언어(대표적으로 C언어)가 줄 수 없는 강력한 안정성을 제공해준다.
	* 그 중에서도 중요한 건 다형성 -> 기존 제어 흐름에 따른 의존성을 역전시켜준다!
		* 이는 비즈니스 로직 이외의 부분들(부가적인 부분들)이 비즈니스 로직에 의존하고, 비즈니스 로직은 독립적으로 유지할 수 있다.
* 함수형 프로그래밍: 불변성과 참조 투명한 함수만을 사용하는 방법 -> 순수 함수형이 아닌 경우는 가변 변수를 사용할 수도 있다. 
	* 애플리케이션의 불변 영역과 가변 영역을 나눈다. -> 가변 변수 영역을 최대한 줄이고, 가변 변수를 보호할 수단을 갖춰야 한다.
	* 이벤트 소싱: 상태가 아닌 트랜잭션 자체를 무한히 저장하는 것(CRUD에서 CR만 한다) -> 저장 공간이 많이 필요하다는 단점이 있다. 하지만 완전한 불변성을 구현할 수 있다는 장점이 있다. (버전 관리 시스템을 생각하면 된다)
* 소프트웨어는 급격히 발전하는 기술이 아니다. -> 도구와 하드웨어는 달라졌지만, 소프트웨어의 핵심은 그대로다
	* 소프트웨어의 구성요소: 순차(sequence), 분기(selection), 반복(Iteration), 참조(indirection)

## 설계 원칙 - SOLID 
* 목적 : 중간 수준(모듈 수준)의 소프트웨어 구조를 다음과 같이 만들기 위함
	* 변경에 유연하다.
	* 이해하기 쉽다
	* 많은 소프트웨어 시스템에 사용될 수 있는 컴포넌트의 기반이 된다.
* 원칙의 종류
  * SRP(Single Responsibility Principle, 단일 책임 원칙) : '콘웨이의 법칙'에서 유도된 법칙으로, 최적의 구조는 시스템을 만드는 조식의 사회적 구조에 큰 영향을 받는다. 따라서 각 소프트웨어의 모듈은 변경의 이유가 오직 하나여야 한다.
	* OCP(Open-Closed Principle, 개방 패쇄 원칙): 기존 코드를 수정하지 않고, 새로운 코드를 추가하는 방식으로 시스템의 행위를 변경할 수 있도록 만들어야 한다. (추가에는 열려있고, 수정에는 닫혀있다)
	* LSP(Liskov Substitution Principle, 리스코프 치환 원칙): 상호 대체 가능한 구성요소를 이용해 소프트웨어 시스템을 만들 수 있으려면, 이들 구성 요소는 반드시 서로 치환 가능해야 한다.
	* ISP(Interface Segregation Principle, 인터페이스 분리 원칙): 소프트웨어 설계자는 사용하지 않은 것에 의존하지 않아야 한다.
	* DIP(Dependency Inversion Principle, 의존성 역전 원칙): 고수준 정책을 구현하는 코드는 저수준 세부사항에 의존하면 안된다. 오히려 세부사항이 정책에 의존해야 한다.

* SRP: 하나의 모듈은 오직 하나의 액터에 대해서만 책임쳐야 한다.
	* 모듈: 소스 파일, 혹은 함수와 데이터 구조로 구성된 응집된 집합.
		* 응집성(cohesion): SRP를 암시하며, 단일 액터를 책임지는 코드를 함께 묶어주는 힘
	* 액터: 변경을 요청하는 한 명 이상의 사람
	* SRP 위반 징후
		* 우발적 중복: 한 클래스의 메서드가 2가지 이상의 액터에 의해 사용된다. 둘 중 한쪽에서만 이를 변경하고 싶은 경우에 문제가 된다.
		* 병합: 수정에 영향을 받는 영역이 너무 넓어서, 충돌이 잦다.
	* 해결책: 메소드들을 별도 클래스로 분리한다. 
		* 데이터만 담는 객체를 만들고, 분리된 메소드들이 담긴 클래스들이 각자 이를 참조하도록 한다.
		* 클래스가 너무 많아 관리가 어렵다면 퍼사드(Facade) 기법을 적용할 수 있다.
		* 모든 메소드를 빼지 않고, 가장 중요한 메소드는 원래 클래스에 남겨 놓을 수도 있다.
	* 상위 수준에서 SRP는 다른 형태로 나타난다.
		* 컴포넌트 수준: 공동 폐쇄 원칙(Common Closure Principle)
		* 아키텍처 수준: 아키텍처 경계(Architectural Boundary)의 생성을 책임지는 변경의 축(Axis of Change)이 된다.

* OCP: 소프트웨어 개체(artifact)는 확장에는 열려있어야 하고, 변경에는 닫혀있어야 한다. -> 소프트웨어 아키텍처를 공부하는 가장 근본적인 이유
	* 시스템을 확장하기 쉬운 동시에 변경으로 인해 너무 많은 영향을 받지 않도록 하는데 그 목적이 있다.
	* 시스템을 컴포넌트 단위로 분리하고, 저수준 컴포넌트의 변경이 고수준 컴포넌트에게 영향을 미치지 않을 수 있는 의존성 계층구조가 만들어지도록 해야한다.
  
* LSP: 프로그램의 구성요소(여기서는 특정 타입의 서브클래스)는 서로 간의 치환이 가능해야 한다. -> 치환이 불가능하다면 이에 대처하기 위한 별도 매커니즘이 덕지덕지 붙어 아키텍처가 오염된다.

* ISP: 필요이상으로 많은 것을 가진 모듈에 의존해서는 안된다. -> 연관없는 부분때문에 재컴파일의 필요가 생길 수 있다.

* DIP: 소스 코드 의존성이 추상(abstraction)에 의존하며, 구체(concretion)에 의존하면 안된다. -> 뒷부분에서 의존성 규칙(Dependency Rule)로 불린다.
	* 운영체제나 플랫폼에서 제공하는 모듈은 변경이 거의 없고, 이를 예측할 수 있기 때문에 이는 예외로 둔다. -> DIP가 적용되어야 하는 모듈은 자주 변경되는 모듈이다.
	* 변동성이 큰 구체 클래스를 참조하지 말라 -> 객체 생성 방식을 강하게 제한하며, 추상팩토리가 일반적으로 사용된다.
	* 변동성이 큰 구체 클래스로부터 파생하지 말라 -> 상속은 강력한 의존성을 불러온다.
	* 구체 함수를 오버라이드 하지 말아라 -> 구체함수를 오버라이드 하면 의존성을 줄일 수가 없게 된다. 추상 함수로 선언하고 구현체들에서 각자의 용도에 맞게 구현해야 한다.