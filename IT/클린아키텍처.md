# 클린 아키텍처
* 설계와 아키텍처
	* 설계 : 주로 저수준의 구조 또는 결정사항등을 의미할 때가 많다.
	* 아키텍처: 저수준의 세부사항과는 분리된 고수준의 무언가
	* 설계와 아키텍처는 개별로 존재할 수 없고, 이 둘을 구분짓는 경계도 뚜렷하지 않다. 단지 고수준에서 저수준으로 향하는 의사결정의 연속일 뿐.
* 의사결정의 목표 : 필요한 시스템을 만들고 유지보수하는 데 필요한 인력과 비용을 최소화하기 위해서이다. -> 그 어떤 경우에도 지저분한 코드는 받아들여서는 안된다.
	* 빨리 가는 유일한 방법은 제대로 가는 것이다.
* 소프트웨어가 제공하는 가치
	* 행위: 특정 문제를 해결하기 위한 소프트웨어의 동작. 요구사항을 구체화해가는 과정을 통해 이루어진다 -> 대부분의 프로그래머가  중요히 여기는 것
	* 아키텍처(구조): 행위를 하기 위한 작업구조. -> Software의 특성상 변경이 쉬워야만 한다. 그렇지 않으면 시간이 지날수록 변경 비용이 상승한다.
		* 변경에 드는 비용은 변경의 범위(Scope)에 비례해야 하며, 형태에 대해서는 독립적이다.
		* 아키텍처가 요구사항의 형태에 독립적일수록 더욱 실용적이다.
*  행위와 아키텍처 중 뭐가 중요한가? -> 동작하지 않더라도 변경이 쉬운 프로그램이 낫다. 고쳐쓸 수 있기 때문에.
	* 개발자는 다른 이해관계자들과의 씨름에서, 소프트웨어를 안전하게 지킬 책임이 있다.
* 프로그래밍 패러다임의 종류
	* 구조적 프로그래밍: 제어흐름의 직접적인 전환(goto문)에 대한 규칙을 부과한다 
	* 객체 지향 프로그래밍: 제어흐름의 간접적인 전환(함수 포인터)에 규칙을 부과한다(함수 호출 스택 프레임을 힙으로 옮기는 것)
	* 함수형 프로그래밍: 할당문에 규칙을 부여한다.(불변성)
	* 이외의 프로그래밍 패러다임은 나올 수 있을까? -> 패러다임은 프로그래머에게 제약을 가하는 것.  goto문, 함수 포인터,  할당문 이외에 더 제약해서 얻을게 없는 이상은 새로운 게 나올 수 없고 나오지 않을 가능성이 높다.
* 구조적 프로그래밍: 프로그램을 순차, 분기, 반복의 3가지만으로 표현할 수 있다. 이렇게 만들어진 프로그램은 입증이 가능하다.
	* goto문은 아예 없거나 있더라도 제한적으로만 쓰이게 되었다.
	* 모듈을 재귀적으로 분해하고, 이렇게 분해된 모듈은 구조적 프로그래밍의 제어구조로 만들 수 있다.
	* 유클리드 계층구조를 구성해 수학적인 증명을 하려 했던 노력은 실패했다. 이를 대신해서 과학적 방법(Scientific Method)가 사용되게 되었다. -> 거짓임을 밝힐 수는 있지만, 참임을 밝힐 수는 없다.
	* 소프트웨어 개발은 수학적 구조를 다루는 듯 보이지만, 오히려 과학에 더 가깝다. 
	* 아키텍트는 모듈, 컴포넌트, 서비스가 쉽게 반증 가능하도록(테스트가 가능하도록) 만들어야 한다.
* 객체 지향 프로그래밍: (아키텍트 입장에서) 다형성을 이용하여 전체 시스템 모든 소스 코드 의존성에 대한 절대적인 제어 권한을 획득할 수 있는 능력
	* 캡슐화가 OOP? - C에서도 캡슐화는 가능, 오히려 OOP 언어가 캡슐화를 엄밀히 하지 않는 경우가 많다. -> 접근 제어는 이 깨진 캡슐화를 보완하기 위한 방책일 뿐
	* 상속이 OOP? - 단일 상속은 이미 C에서도 사용하던 기법. 다만 좀 더 편리한 방법을 제공할 뿐
	* 다형성이 OOP? -  C언어도 다형성 구현 가능, 다만 함수 포인터를 써야 하기 때문에 위험하다. OOP언어는 이를 안전하게 사용하는 방법을 제공한다.
	* 결론: OOP는 구조적 프로그래밍 언어(대표적으로 C언어)가 줄 수 없는 강력한 안정성을 제공해준다.
	* 그 중에서도 중요한 건 다형성 -> 기존 제어 흐름에 따른 의존성을 역전시켜준다!
		* 이는 비즈니스 로직 이외의 부분들(부가적인 부분들)이 비즈니스 로직에 의존하고, 비즈니스 로직은 독립적으로 유지할 수 있다.
* 함수형 프로그래밍: 불변성과 참조 투명한 함수만을 사용하는 방법 -> 순수 함수형이 아닌 경우는 가변 변수를 사용할 수도 있다. 
	* 애플리케이션의 불변 영역과 가변 영역을 나눈다. -> 가변 변수 영역을 최대한 줄이고, 가변 변수를 보호할 수단을 갖춰야 한다.
	* 이벤트 소싱: 상태가 아닌 트랜잭션 자체를 무한히 저장하는 것(CRUD에서 CR만 한다) -> 저장 공간이 많이 필요하다는 단점이 있다. 하지만 완전한 불변성을 구현할 수 있다는 장점이 있다. (버전 관리 시스템을 생각하면 된다)
* 소프트웨어는 급격히 발전하는 기술이 아니다. -> 도구와 하드웨어는 달라졌지만, 소프트웨어의 핵심은 그대로다
	* 소프트웨어의 구성요소: 순차(sequence), 분기(selection), 반복(Iteration), 참조(indirection)
* 설계 원칙 - SOLID 
	* 목적 : 중간 수준(모듈 수준)의 소프트웨어 구조를 다음과 같이 만들기 위함
		* 변경에 유연하다.
		* 이해하기 쉽다
		* 많은 소프트웨어 시스템에 사용될 수 있는 컴포넌트의 기반이 된다.
	* SRP(Single Responsibility Principle, 단일 책임 원칙) : '콘웨이의 법칙'에서 유도된 법칙으로, 최적의 구조는 시스템을 만드는 조식의 사회적 구조에 큰 영향을 받는다. 따라서 각 소프트웨어의 모듈은 변경의 이유가 오직 하나여야 한다.
	* OCP(Open-Closed Principle, 개방 패쇄 원칙): 기존 코드를 수정하지 않고, 새로운 코드를 추가하는 방식으로 시스템의 행위를 변경할 수 있도록 만들어야 한다. (추가에는 열려있고, 수정에는 닫혀있다)
	* LSP(Liskov Substitution Principle, 리스코프 치환 원칙): 상호 대체 가능한 구성요소를 이용해 소프트웨어 시스템을 만들 수 있으려면, 이들 구성 요소는 반드시 서로 치환 가능해야 한다.
	* ISP(Interface Segregation Principle, 인터페이스 분리 원칙): 소프트웨어 설계자는 사용하지 않은 것에 의존하지 않아야 한다.
	* DIP(Dependency Inversion Principle, 의존성 역전 원칙): 고수준 정책을 구현하는 코드는 저수준 세부사항에 의존하면 안된다. 오히려 세부사항이 정책에 의존해야 한다.
* SRP: 하나의 모듈은 오직 하나의 액터에 대해서만 책임쳐야 한다.
	* 모듈: 소스 파일, 혹은 함수와 데이터 구조로 구성된 응집된 집합.
		* 응집성(cohesion): SRP를 암시하며, 단일 액터를 책임지는 코드를 함께 묶어주는 힘
	* 액터: 변경을 요청하는 한 명 이상의 사람
	* SRP 위반 징후
		* 우발적 중복: 한 클래스의 메서드가 2가지 이상의 액터에 의해 사용된다. 둘 중 한쪽에서만 이를 변경하고 싶은 경우에 문제가 된다.
		* 병합: 수정에 영향을 받는 영역이 너무 넓어서, 충돌이 잦다.
	* 해결책: 메소드들을 별도 클래스로 분리한다. 
		* 데이터만 담는 객체를 만들고, 분리된 메소드들이 담긴 클래스들이 각자 이를 참조하도록 한다.
		* 클래스가 너무 많아 관리가 어렵다면 퍼사드(Facade) 기법을 적용할 수 있다.
		* 모든 메소드를 빼지 않고, 가장 중요한 메소드는 원래 클래스에 남겨 놓을 수도 있다.
	* 상위 수준에서 SRP는 다른 형태로 나타난다.
		* 컴포넌트 수준: 공동 폐쇄 원칙(Common Closure Principle)
		* 아키텍처 수준: 아키텍처 경계(Architectural Boundary)의 생성을 책임지는 변경의 축(Axis of Change)이 된다.
* OCP: 소프트웨어 개체(artifact)는 확장에는 열려있어야 하고, 변경에는 닫혀있어야 한다. -> 소프트웨어 아키텍처를 공부하는 가장 근본적인 이유
	* 시스템을 확장하기 쉬운 동시에 변경으로 인해 너무 많은 영향을 받지 않도록 하는데 그 목적이 있다.
	* 시스템을 컴포넌트 단위로 분리하고, 저수준 컴포넌트의 변경이 고수준 컴포넌트에게 영향을 미치지 않을 수 있는 의존성 계층구조가 만들어지도록 해야한다.
* LSP: 프로그램의 구성요소(여기서는 특정 타입의 서브클래스)는 서로 간의 치환이 가능해야 한다. -> 치환이 불가능하다면 이에 대처하기 위한 별도 매커니즘이 덕지덕지 붙어 아키텍처가 오염된다.
* ISP: 필요이상으로 많은 것을 가진 모듈에 의존해서는 안된다. -> 연관없는 부분때문에 재컴파일의 필요가 생길 수 있다.
* DIP: 소스 코드 의존성이 추상(abstraction)에 의존하며, 구체(concretion)에 의존하면 안된다. -> 뒷부분에서 의존성 규칙(Dependency Rule)로 불린다.
	* 운영체제나 플랫폼에서 제공하는 모듈은 변경이 거의 없고, 이를 예측할 수 있기 때문에 이는 예외로 둔다. -> DIP가 적용되어야 하는 모듈은 자주 변경되는 모듈이다.
	* 변동성이 큰 구체 클래스를 참조하지 말라 -> 객체 생성 방식을 강하게 제한하며, 추상팩토리가 일반적으로 사용된다.
	* 변동성이 큰 구체 클래스로부터 파생하지 말라 -> 상속은 강력한 의존성을 불러온다.
	* 구체 함수를 오버라이드 하지 말아라 -> 구체함수를 오버라이드 하면 의존성을 줄일 수가 없게 된다. 추상 함수로 선언하고 구현체들에서 각자의 용도에 맞게 구현해야 한다.
---
* 컴포넌트: 시스템의 구성요소로 배포할 수 있는 가장 작은 단위 ->  jar, gem, dll 등
	* 컴파일형 언어에서는 바이너리 파일의 결합체, 인터프리터 언어에서는 소스파일의 결합체
	* 여러 컴포넌트를 서로 링크하여, 실행가능한 단일 파일로 만들거나, 여러 컴포넌트를 묶어 단일 아카이브로 만들거나, 컴포넌트 각각을 독립적으로 배포할 수도 있다.
	* 어떤 형태로 배포되던, 잘 설계된 컴포넌트는 반드시 독립적으로 배포 가능한, 즉, 독립적으로 개발 가능한 능력을 갖춰야 한다.
* 컴포넌트 응집도 관련 원칙
	* REP(Reuse/Release Equivalence Principle): 릴리즈가 추적 관리되지 않거나, 릴리즈 번호가 부여되지 않으면 해당 컴포넌트는 재사용 될 수 없다.
		* 단일 컴포넌트는 응집성 높은 클래스와 모듈로 구성되어야 한다 -> CCP,CRP와 연관된다.
	* CCP(Common Closure Principle): 동일한 이유로 동일한 시점에 변경되는 클래스는 같은 컴포넌트로, 서로 다른 시점에 다른 이유로 변경되는 클래스는 다른 컴포넌트로 분리해야 한다. -> SRP의 컴포넌트 버전, OCP와도 관련이 있다.
	* CRP(Common Reuse Principle): 컴포넌트 사용자들이 필요하지 않은 것에 의존하게 강요하지 말라 -> ISP의 컴포넌트 버전
	* 세가지 원리는 서로 상충하며, 현재 개발 상황에 따라 주의를 기울이는 부분이 달라져야 한다. (재사용성과 유지보수성의 균형)
* 컴포넌트 결합 관련 원칙
	* ADP(Acyclic Dependency Principle): 컴포넌트 의존성 그래프에 순환이 있어서는 안된다. -> 순환이 있으면 컴포넌트 하나의 변경이 수많은 컴포넌트의 변경을 가져오고, 영원히 끝나지 않는 굴레에 빠지게 된다.
		* 주 단위 빌드(Weekly Build): 5일 중 4일은 각자 작업하고, 금요일에 통합빌드를 한다 -> 4일은 편하지만, 금요일에 막대한 비용을 치뤄야한다. 이 비용은 점차 커지며, 점점 주 단위 빌드를 어렵게 한다.
		* 개발 환경을 릴리스 가능한 컴포넌트 단위로 분리하기
			*  컴포넌트는 한 명의 개발자 혹은 한 개발팀이 책임지는 작업 단위. 개발팀은 별도의 작업 공간에서 작업하고 이를 릴리스하며, 다른 팀을 릴리스 된 것을 사용하고 새로운 버전을 사용할 지 아닐지에 대한 판단을 한다.
			* 통합은 작고 점진적으로 이루어진다.
			* 이 절차가 성공적으로 동작하려면, 반드시 컴포넌트 사이의 의존성을 관리해야 한다.  -> 의존성에 순환이 생기면 이 자율성이 사라진다.
				* DIP 적용
				* 새로운 컴포넌트를 만들어서 순환의 원인이 되는 클래스들을 새로운 컴포넌트로 이동시킨다.
			* 컴포넌트 구조는 계속해서 변해야 하기 때문에, 처음에 설계하고 갈 수 있는 것이 아니고 시스템의 성장과 변경에 맞춰 진화하는 것이다.
	* SDP(Stable Dependency Principle) : 더 안정된 쪽에 의존하라
		* 아무리 변동이 쉽게 만들어진 컴포넌트도, 다른 컴포넌트가 자신에게 의존하면 변경이 어려워진다.
		* 안정적이다: 변경이 어렵다. 또 변경의 필요성도 크지 않다. -> 여러 요인이 있지만, 여기서는 의존성에 촛점을 둔다. 자신을 의존하는 컴포넌트가 많을수록 변화가 힘들어 안정적이다. 또 자신이 의존하는 컴포넌트가 있다면, 의존하는 컴포넌트의 변화에 맞춰 자신도 맞춰야 하는 강제성이 생긴다.
		* 안정적인 컴포넌트가 불안정한 컴포넌트를 의존하게 되면 수정이 잦아지면서 덩달아 불안정해진다.
	* SAP(Stable Abstraction Principle): 컴포넌트는 안정된 정도만큼만 추상화되어야 한다.
		* 안정적인 컴포넌트라면 반드시 인터페이스와 추상 클래스로 구성되어 쉽게 확장할 수 있어야 한다.
		* 반대로 불안정한 컴포넌트는 반드시 구체 컴포넌트로 구성되어 쉽게 수정할수 있어야 한다.
		* 피해야할 구조
			* 고통의 구역: 안정적이며 구체적이다.  확장도 어렵고, 변경도 어렵다. -> 일부 소프트웨어 엔티티는 여기 속할 수 밖에 없기도 하다(데이터베이스 스키마, 구체적인 유틸리티 라이브러리 등), 그래도 변동성이 없는 컴포넌트는 여기 있어도 해롭지 않다.
			* 쓸모없는 구역: 변동성이 높고, 추상적이다 -> 아무도 쓰지 않는 추상 클래스. 
		* 바람직한 구조: 피해야 할 구조에서 가장 먼 구역 -> 주계열(Main Sequence -> 원래는 천문학 용어)
			* 주계열에서의 거리를 기반으로 설계를 통계적으로 분석해 볼 수 있다. -> 다만 지표를 절대적으로 신봉하지는 말것
 
---
## 아키텍처
* 아키텍처란?: 시스템을 구축했던 사람들이 만들어낸 시스템의 형태
	* 형태를 결정하는 요소들
		* 시스템을 컴포넌트로 분할하는 방법
		* 분할된 컴포넌트를 배치하는 방법
		* 컴포넌트가 서로 의사소통하는 방법
	* 아키텍처는 그 안의 소프트웨어 시스템이 쉽게 개발, 배포, 운영, 유지보수 되도록 만들어진다. -> 이를 쉽게 하기 위해서는 가능한 많은 선택지를, 가능한 오래 남겨둘 수 있어야 한다.
	* 아키텍처의 궁극적인 목표: 시스템의 수명과 관련된 비용은 최소화하고, 프로그래머의 생산성은 최대화한다. -> 동작하게 만드는 것도 중요하지만, 이것이 아키텍처의 본질적인 것은 아니다.
* 아키텍트: 아키텍처를 만드는 개발팀의 리더
	* 프로그래머이며, 앞으로도 프로그래머여야 한다. -> 코드에서 탈피해서 고수준의 문제에 집중해야 한다는 거짓말에 넘어가면 안된다.
	* 자신도 프로그래밍 작업을 하면서, 나머지 팀원들이 생산성을 극대화하는 설계를 하도록 방향을 이끌어준다.
* 아키텍처의 고려사항
	* 개발 : 개발팀이 개발을 쉽게 개발할 수 있도록 만들어야 한다.
		* 일부러 아키텍처를 잘 만들지 않으면, 최적이 아닌 채로 고착될 수 있다.
	* 배포: 한번에 쉽게 배포할 수 있도록 만들어야 한다.
		* 초기에 이를 고려하지 않으면 배포가 어려워진다
	* 운영: 운영상의 요구들이 잘 드러나도록 만들어야 한다. -> 
		* 다만 하드웨어를 추가하는 것만으로도 운영이 쉬워지는 효과가 있다보니 비용관점에서는 운영의 비중이 크지 않다.
		* 유스케이스, 기능,시스템의 필수행위를 '일급 엔티티'로 격상시키고, 개발자에게 이들이 주요 목표로 인식되도록 해야한다. -> 이를 통해 시스템을 이해하기 쉬워지고, 개발과 유지보수에 큰 도움이 된다.
	* 유지보수: 새로운 기능을 추가하는데 드는 비용과 이에 따른 결함과 수정비용을 최소화해야 한다.
		* 유지보수에 가장 큰 비용이 드는 것은 탐사(Spelunking)와 이에 따른 위험부담이다. -> 따라서 주의를 기울여 신중하게 시스템을 컴포넌트로 분리하고, 안정된 인터페이스로 서로를 격리해야 한다.
	* 선택사항 열어두기 -> 정책(Policy)과 세부사항(Detail)로 구분해서, 세부사항의 결정을 최대한 미룬다.
		* 세부 사항을 미룰수록, 더 많은 정보를 통해 제대로 된 결정을 내릴 확률이 높아진다.
		* 장치 독립적이여야 한다.
* 좋은 아키텍처 - 독립성 측면
	* 시스템의 유즈케이스 -> 시스템의 의도를 지원해야 한다.(아키텍트의 최우선 관심사)
		* 가장 중요한 것은 행위를 명확히 하고, 외부로 드러내며, 이를 통해 시스템이 지닌 의도를 아키텍처 수준에서 알아볼 수 있게 만드는 것
	* 시스템의 운영 -> 시스템의 요구 사항에 맞는 형태를 만들되, 세부사항에 대한 확정은 최대한 미뤄야 한다.
	* 시스템의 개발 -> 콘웨이의 법칙이 적용되는 지점. 각 팀이 독립적으로 행동하기 편한 아키텍쳐를 반드시 확보해서, 개발하는 동안 팀이 서로를 방해하지 않도록 해야한다.
	* 시스템의 배포 -> '즉각적인 배포'가 가능하게 만들어야 한다 -> 컴포넌트 단위로 적절하게 분할하고 격리시켜야 하며, 메인 컴포넌트(마스터 컴포넌트)도 포함된다.
		* 메인 컴포넌트는 시스템 전체를 하나로 묶고, 각 컴포넌트가 올바르게 구동하고 통합하고 관리한다.
	* 선택사항 열어놓기 -> 말로 쓰는 건 쉽지만 현실에서 균형 잡는 건 어렵다.  따라서 선택사항을 열어놓고 유연하게 대처할 수 있어야 한다.
		* 모든 유즈케이스를 알수도 없고, 운영 제약, 팀 구조, 배포 요구사항도 알 수가 없기 때문, 심지어 이것들은 시간이 지나면서 변한다.
	* 계층 결합 분리 -> 모든 유즈케이스는 몰라도, 시스템의 기본 의도는 알기 때문에 여기에 SRP와 OCP를 적용해 내부 요소들을 분리해서 수평적으로 분할한다.
		* UI, 애플리케이션 특화 업무 규칙, 애플리케이션 독립 업무 규칙, 데이터베이스 등
	* 유즈케이스 결합 분리 -> 유즈케이스 자체도 시스템을 분할하는 매우 자연스러운 방법
		* 수평적으로 나눈 계층을 다시 유즈케이스 별로 나눠준다.
		* 이렇게 되면 새로운 유즈케이스를 추가할때, 다른 관점(Aspect, AOP와 관련된다)을 사용해 기존 유즈케이스에 영향을 주지 않을 수 있다.
	* 중복 문제
		* 진짜 중복: 한 인스턴스가 변경되면 나머지 인스턴스도 맞춰 변경해야 하는 중복 -> 제거 대상
		* 거짓된(우발적인) 중복: 비슷해보여도 후에는 다르게 발전할 가능성이 있는 중복 -> 제거하지 않는 게 좋다.
	* 결합 분리 모드 -> 시간에 따라 바뀔 수 있고, 이러한 변경을 예측하여 큰 무리없이 반영할 수 있어야 한다.    
		* 소스 수준 분리
		* 배포 수준 분리
		* 서비스 수준 분리
* 좋은 아키텍처 - 경계: 선 긋기
	* 나쁜 아키텍처를 만드는 요인: 너무 일찍 내려진 결정에 의한 결합(coupling) -> 오버 엔지니어링을 초래하고, 비효율성을 증대시킨다.
	* 선 긋기 원칙: 관련성을 기준으로 선을 긋는다.(GUI, DB, 비즈니스 로직)
		* GUI, DB는 부차적인 것으로 반드시 비즈니스 로직에 의존해야 하며, 비즈니스 로직은 이 둘에게 의존적이면 안된다. -> 플러그인 아키텍처(핵심 컴포넌트와 나머지 컴포넌트로 분리, 나머지 컴포넌트가 플러그인), 의존성 역전 원칙, 안정된 추상화 원칙
		* 경계는 변경의 축이 있는 지점에 그어진다. -> 단일 책임 원칙
* 경계 해부학 
	* 시스템 아키텍처: 일련의 S/W 컴포넌트 + 컴포넌트들을 분리하는 경계
	* 경계를 횡단한다 : 경계 한쪽에 있는 기능에서 반대편 기능을 호출해서 반대편 기능을 호출한다.
	* 적절한 경계 횡단의 비결: 소스코드 의존성 관리 -> 한 모듈의 변경이 다른 모듈의 변경 혹은 재컴파일을 발생시키지 않도록 관리한다.
	* 경계 정하기
		* 단일체(Monolith): 경계를 넘어갈 때는 제어흐름에 반대되도록 넘어가야 한다.(저수준 -> 고수준)
			* 통신 비용이 매우 저렴함
		* 배포형 컴포넌트: 배포 방법만 다를 뿐 단일체와 동일하다(정적 다형성을 사용할 수는 없다)
		* 스레드: 경계 혹은 물리적 배포 대상이 아니다.
		* 로컬 프로세스: 단일체, 배포 컴포넌트와 동일(고수준 프로세스가 저수준 프로세스에 의존하면 안된다)
			* 다만 통신 비용이 비교적 비싸므로 통신을 제한해야 한다.
		* 서비스: 원칙은 동일하나, 통신 비용이 매우 비싸므로 지연문제를 고수준에서 처리해야 한다. 
* 정책과 수준
	* 수준: 입력과 출력 까지의 거리. 입력과 출력 모두로부터 멀수록 높은 수준을 가진다.
	* 데이터 흐름과 소스코드 의존성이 동일하면 안된다.
* 업무 규칙: 사업적으로 수익을 얻거나 비용을 줄일 수 있는 규칙 또는 절차 -> 전산화 여부와는 관계 없다.
	* 핵심 업무 규칙 + 핵심 데이터 = 엔티티(엔터프라이즈 업무 규칙)
	* 유스케이스: 자동화된 시스템이 사용되는 방법을 기술한 것. 시스템이 사용자에게 어떻게 보이는 지는 나타내지 않는다.(애플리케이션 업무 규칙)
	* 유스케이스는 엔티티에 의존, 하지만 엔티티는 유스케이스의 의존하지 않는다.
* 소리치는 아키텍처: 아키텍처는 애플리케이션의 유스케이스에 대해 소리쳐야 한다.
	* 프레임워크나 어떤 매커니즘이 아키텍처에 영향을 주어선 안된다. 이들에 대한 결정은 최대한 뒤로 미뤄야 한다.
* 클린 아키텍처
	* 목표: 관심사의 분리
	* 특징
		* 프레임워크 독립성
		* 테스트 용이성
		* UI 독립성
		* 데이터베이스 독립성
		* 모든 외부 에이전시에 대한 독립성
	* 기본적인 구조: (고) 엔티티 - 유스 케이스 - 인터페이스 어댑터(프레젠터, 뷰, 컨트롤러 등) - 프레임워크&드라이버(저) 
	* 항상 저수준의 요소가 고수준의 요소를 참조하도록 해야 한다.
* 부분적 경계
	* 완벽한 경계를 만드는 건 비용이 많이 들고 관리도 힘들다. -> YAGNI(You Aren't Going Need it) 원칙에 위배된다.
	* 부분적 경계를 만들기
		* 설계는 그대로 하되, 실제로 쪼개지 않고 하나의 모듈에 모아두기 -> 배포 관리가 편해지나, 이후에 분리하게 될 때 재사용성이 떨어질 수 있고, 분리하기도 어려워진다.
		* 일차원 경계: 전략 패턴을 이용해서 간단하게 경계를 만든다. -> 완벽한 경계를 만들기 전의 임시 상태로, 그만큼 깨지기도 쉽다.
		* 퍼사드: 아주 간단한 경계 생성 -> 직접 참조는 안해도 모든 서비스 클래스에 추이 종속성을 가지게 된다.
* 계층과 경계 : 아키텍쳐 경계는 어디에나 존재하며, 이를 만드는 것도 비용이 들고, 무시하는 것도 나중에 큰 비용으로 돌아올 수 있다. 아키텍트는 이를 가지고 어디에 경계를 둘지, 경계를 어느정도 수준으로 구현할지를 결정해야 한다.
	* 이를 미리 결정하는 것은 안된다. 조짐이 보일 때에 이를 고려하여 결정하고, 자주 검토한다. -> 빈틈없이 지켜봐야 한다.
* Main 컴포넌트 - 프로그램의 엔트리 포인트, 동시에 가장 저수준의 모듈로 아키텍처 경계 가장 바깥에 위치한다.
	* 초기 조건과 설정을 구성한 뒤, 고수준 모듈로 제어권을 넘긴다.
	* 메인도 애플리케이션의 플러그인으로 생각해서, 여러개 두고 설정에 따라 골라 쓸 수도 있다.
* 서비스 아키텍처? 그런 건 없다. 
	* 서비스를 쓰면 결합 분리가 잘 된다? -> 네트워크의 공유 자원 때문에 결합이 단단해질 수도 있는 것이다.
		* 서비스 인터페이스가 함수 인터페이스보다 더 엄밀해야 되는 건 아니다.
	* 서비스를 쓰면 개발 및 배포 독립성을 가질 수 있다? 
		* 모놀리틱 시스템이나 컴포넌트 기반으로도 충분히 할 수 있다.
		* 데이터나 행위 단위로 어느정도 결합성을 가질 수 있다.
	* 아키텍처는 서비스 사이에 있지않고, 서비스를 관통하여 컴포넌트 단위로 분할한다. -> 서비스 자체는 아키텍처의 중요한 요소가 아니다.
* 테스트: 시스템 가장 바깥 경계로써 아키텍처의 일부 
	* 처음부터 테스트를 고려해서 설계해야 한다. -> 변동성 높은 것에 의존하지 말라
	* 테스트용 API를 통해 보안 제약, DB등의 값비싼  자원 등을 제외하고 시스템을 테스트 가능한 상태로 만들 수 있어야 한다.
	* 테스트 API의 역할 : 애플리케이션의 구조를 테스트로부터 숨기는 것
		* 테스트의 진화 방향과 애플리케이션의 진화방향은 반대로 간다 -> 구조적 결합이 이들의 개별적인 진화를 막는다.
		* 테스트 API는 강력하기 때문에 운영 시스템에 묶여들어가면 안된다.
* 임베디드에서의 클린 아키텍처: 소프트웨어는 더 많이, 펌웨어는 더 적게
	* 펌웨어는 하드웨어에 의존적인 코드(저장 위치에 관계없이)
	* 소프트웨어는 하드웨어 독립적인 코드
	* 왜 임베디드 분야에서는 펌웨어가 많은가? -> 돌아가는 데에만 중점을 두기 때문
	* 임베드가 특수하긴 하지만, 클린 아키텍처를 적용하지 못할만큼 특별하지는 않다.
		* 하드웨어 세부사항에 직접 접근하게 하지 말라
		* 인터페이스를 통하고 대체 가능성을 높이는 방법으로 프로그래밍하라 