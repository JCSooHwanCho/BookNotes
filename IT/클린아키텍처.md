# 책 제목 : 클린 아키텍처 - 소프트웨어 구조의 설계와 원칙

저자 : 로버트 C. 마틴
역자 : 송준이 
출판사 : 인사이트  
출판년월 : 2019/8  
페이지 : 406  

---

* 설계와 아키텍처
	* 설계 : 주로 저수준의 구조 또는 결정사항등을 의미할 때가 많다.
	* 아키텍처: 저수준의 세부사항과는 분리된 고수준의 무언가
	* 설계와 아키텍처는 개별로 존재할 수 없고, 이 둘을 구분짓는 경계도 뚜렷하지 않다. 단지 고수준에서 저수준으로 향하는 의사결정의 연속일 뿐.
* 의사결정의 목표 : 필요한 시스템을 만들고 유지보수하는 데 필요한 인력과 비용을 최소화하기 위해서이다. -> 그 어떤 경우에도 지저분한 코드는 받아들여서는 안된다.
	* 빨리 가는 유일한 방법은 제대로 가는 것이다.
* 소프트웨어가 제공하는 가치
	* 행위: 특정 문제를 해결하기 위한 소프트웨어의 동작. 요구사항을 구체화해가는 과정을 통해 이루어진다 -> 대부분의 프로그래머가  중요히 여기는 것
	* 아키텍처(구조): 행위를 하기 위한 작업구조. -> Software의 특성상 변경이 쉬워야만 한다. 그렇지 않으면 시간이 지날수록 변경 비용이 상승한다.
		* 변경에 드는 비용은 변경의 범위(Scope)에 비례해야 하며, 형태에 대해서는 독립적이다.
		* 아키텍처가 요구사항의 형태에 독립적일수록 더욱 실용적이다.
*  행위와 아키텍처 중 뭐가 중요한가? -> 동작하지 않더라도 변경이 쉬운 프로그램이 낫다. 고쳐쓸 수 있기 때문에.
	* 개발자는 다른 이해관계자들과의 씨름에서, 소프트웨어를 안전하게 지킬 책임이 있다.
* 프로그래밍 패러다임의 종류
	* 구조적 프로그래밍: 제어흐름의 직접적인 전환(goto문)에 대한 규칙을 부과한다 
	* 객체 지향 프로그래밍: 제어흐름의 간접적인 전환(함수 포인터)에 규칙을 부과한다(함수 호출 스택 프레임을 힙으로 옮기는 것)
	* 함수형 프로그래밍: 할당문에 규칙을 부여한다.(불변성)
	* 이외의 프로그래밍 패러다임은 나올 수 있을까? -> 패러다임은 프로그래머에게 제약을 가하는 것.  goto문, 함수 포인터,  할당문 이외에 더 제약해서 얻을게 없는 이상은 새로운 게 나올 수 없고 나오지 않을 가능성이 높다.
* 구조적 프로그래밍: 프로그램을 순차, 분기, 반복의 3가지만으로 표현할 수 있다. 이렇게 만들어진 프로그램은 입증이 가능하다.
	* goto문은 아예 없거나 있더라도 제한적으로만 쓰이게 되었다.
	* 모듈을 재귀적으로 분해하고, 이렇게 분해된 모듈은 구조적 프로그래밍의 제어구조로 만들 수 있다.
	* 유클리드 계층구조를 구성해 수학적인 증명을 하려 했던 노력은 실패했다. 이를 대신해서 과학적 방법(Scientific Method)가 사용되게 되었다. -> 거짓임을 밝힐 수는 있지만, 참임을 밝힐 수는 없다.
	* 소프트웨어 개발은 수학적 구조를 다루는 듯 보이지만, 오히려 과학에 더 가깝다. 
	* 아키텍트는 모듈, 컴포넌트, 서비스가 쉽게 반증 가능하도록(테스트가 가능하도록) 만들어야 한다.
* 객체 지향 프로그래밍: (아키텍트 입장에서) 다형성을 이용하여 전체 시스템 모든 소스 코드 의존성에 대한 절대적인 제어 권한을 획득할 수 있는 능력
	* 캡슐화가 OOP? - C에서도 캡슐화는 가능, 오히려 OOP 언어가 캡슐화를 엄밀히 하지 않는 경우가 많다. -> 접근 제어는 이 깨진 캡슐화를 보완하기 위한 방책일 뿐
	* 상속이 OOP? - 단일 상속은 이미 C에서도 사용하던 기법. 다만 좀 더 편리한 방법을 제공할 뿐
	* 다형성이 OOP? -  C언어도 다형성 구현 가능, 다만 함수 포인터를 써야 하기 때문에 위험하다. OOP언어는 이를 안전하게 사용하는 방법을 제공한다.
	* 결론: OOP는 구조적 프로그래밍 언어(대표적으로 C언어)가 줄 수 없는 강력한 안정성을 제공해준다.
	* 그 중에서도 중요한 건 다형성 -> 기존 제어 흐름에 따른 의존성을 역전시켜준다!
		* 이는 비즈니스 로직 이외의 부분들(부가적인 부분들)이 비즈니스 로직에 의존하고, 비즈니스 로직은 독립적으로 유지할 수 있다.
* 함수형 프로그래밍: 불변성과 참조 투명한 함수만을 사용하는 방법 -> 순수 함수형이 아닌 경우는 가변 변수를 사용할 수도 있다. 
	* 애플리케이션의 불변 영역과 가변 영역을 나눈다. -> 가변 변수 영역을 최대한 줄이고, 가변 변수를 보호할 수단을 갖춰야 한다.
	* 이벤트 소싱: 상태가 아닌 트랜잭션 자체를 무한히 저장하는 것(CRUD에서 CR만 한다) -> 저장 공간이 많이 필요하다는 단점이 있다. 하지만 완전한 불변성을 구현할 수 있다는 장점이 있다. (버전 관리 시스템을 생각하면 된다)
* 소프트웨어는 급격히 발전하는 기술이 아니다. -> 도구와 하드웨어는 달라졌지만, 소프트웨어의 핵심은 그대로다
	* 소프트웨어의 구성요소: 순차(sequence), 분기(selection), 반복(Iteration), 참조(indirection)