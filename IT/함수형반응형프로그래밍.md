
# 함수형 반응형 프로그래밍(Functional Reactive Programming)  

저자 : 스티븐 블랙히스, 앤서니 존스  
역자 : 오현석  
출판사 : 매닝출판사, 한빛미디어  
출판년월 : 2017/8  
페이지 : 492  

---

## __Chapter 1. 듣기를 멈추자!__  

---  

- FRP? 표준 프로그래밍 언어에서 간단한 라이브러리 형태로 적용되며, 관찰자 패턴에서 사용되는 리스너(listener, 혹은 callback)을 대신함.->관찰자 패턴 자체를 대치  
- 프로젝트의 복잡도가 너무 높아질 때의 근본적 해결법 = __리팩토링__ , FRP는 제어할 수 없는 복잡도를 예방하거나 고칠 때 도움이 되기 때문에 리팩토링과 잘 어우러진다.  
- 표시적(denotative)이고 시간 연속적(temporally continuous)  
- 표시적이란? 정확,간결,구현독립적,합성가능한 semantic으로 프로그램이 이루어져야 한다.
- FRP - 함수형 프로그래밍과 반응형 프로그래밍의 교집합
  - 함수형
        1. 수학적 의미의 함수에 기반함  
        2. 공유된 변경 가능상태를 의도적으로 피함 -> 불변 데이터 구조 사용  
        3. 합성성 강조 -> FRP의 복잡도를 효율적으로 처리할 수 있는 원동력  
    - 반응형  
        1. 프로그램을 제어의 흐름으로써가 아니라 이벤트 기반, 입력에 반응하는 데이터 흐름으로 이해하는 광범위한 용어  
        2. 프로그램 구성요소 간의 느슨한 결합을 허용하여 코드가 더 모듈화 된다.  
    - 함수형 반응형 프로그래밍 : 반응형 프로그래밍을 달성하기 위해 함수형 프로그래밍의 규칙을 따르도록 강제하는 구체적인 방법. 합성성 강조  

- 반응형 프로그래밍으로 설명되는 시스템은 분산처리를 강조하지만 FRP는 더 세밀한 단위를 사용해 일관성을 강조. 분산 시스템에서 규모 확장성을 위해서는 일관성이 완화되어야만 하기 때문에 FRP는 분산 시스템을 위한 것이 아니다. ex) Akka는 반응형 프로그래밍으로 분류되는데, 분산 시스템을 위한 것으로 FRP가 아닌 actor모델을 사용한다.  

- Rx는 아카와 FRP 중간 어느 지점에 위치. Rx는 이벤트 핸들러를 사슬처럼 엮는데 관심이 있다. FRP는 작업 방식을 더 엄격히 제한하며, 더 많은 것을 보장한다.  

- 두 가지 프로그래밍 모델  
    1. 스레드 : 상태 변화를 제어 흐름으로 모델링 -> FSM,I/O에 잘 어울림  
    2. 이벤트 : 이산적이고 비동기적으로 전파되는 메시지 -> GUI,비디오게임  

- 모든 프로그램은 상태 기계, 상태 기계는 분석이 어렵고, 그래서 프로그래밍이 어렵다. 프로그래머는 이 어려운 프로그래밍을 구조화해서 분석하고 관리하기 쉽게 만드는 것, 즉 추상화 능력이다.  
- 이벤트 기반 프로그램에도 다양한 버그가 있다. 하지만 __이 중 대다수는 예방할 수 있다.__  
- 기존 코드 : 생산자가 소비자에 의존, 관찰자 패턴 : 소비자가 생산자에 의존  
  - 장점 : 프로그램의 확장이 쉽고, 구성요소 간의 연결이 느슨해짐  
- 리스너 버그의 근원  
    1. 예측 불가능한 순서  
    2. 첫 번째 이벤트 소실  
    3. 지저분한 상태  
    4. 스레드 문제  
    5. 콜백 누수  
    6. 의도치 않은 재귀  
  - 이것들을 고치기 위해 관찰자 패턴을 연구하다 보면 자연스레 FRP에 도달하게 될 것이다.  
- FRP로 재시작이 필요없는 프로그램을 만들 수 있다. 일반적인 변경 가능한 변수 대신 변경 통지와 실행순서 관리를 자동으로 해주는 컨테이너에 상태를 저장한다. (여기서는 Cell)  
- 복잡도를 다루는 핵심 - __합성성__  
- FRP의 작동방식 : 데이터 입력 - 비즈니스 로직으로 데이터 검증 - 상태 변화  
- FRP의 두가지 기본적 데이터 타입  
    1. 셀 : 시간에 따라 변화하는 값을 표현 -> 변수의 추상화된 형태  
    2. 스트림 : 이벤트의 흐름  
- FRP의 구조  
    1. FRP 로 작성된 문장들을 해석하여 방향성 그래프로 초기화  
    2. 방향성 그래프를 FRP엔진에 보내 입력이 들어왔을 때 방향성 그래프가 지정하는 의존성 관계대로 처리하게 만듬(스프레드시트와 같은 방식으로 작동한다!) -> GUI 라이브러리의 동작 방식과 유사  
- FRP의 패러다임  
  - 패러다임은 참이라고 여기는 몇가지 가정을 근거로 하며 이는 사람마다 다르다. 이 가정이 상당히 다를 경우 서로 통약불가능(incommensurable)하다고 한다.  
  - 패러다임은 천천히, 또는 어떤 깨달음에 의해 한순간에 바뀐다. FRP는 간단한 아이디어지만, 그것을 이해하기까지의 과정은 도전이다.  
- 스레드는 시퀀스 표현에, 이벤트는 의존성 표현에 사용된다. 의존성을 스레드로 표현하거나 이벤트를 시퀀스로 표현하려면 쉽게 복잡해진다. FRP는 시퀀스 중심의 프로그래밍을 문제 설명에 더 가까운 방식으로 바꾼다.  

- 선언적 프로그래밍 : 어떻게(How)보다 무엇(What)을 하는 프로그램인지를 서술하는 방식의 프로그래밍 - operation 보다는 concept, 훨씬 이해가 쉽다.  

- FRP의 기반 철학 : 프로그램은 입력을 출력으로 변환하는 것  

- 대부분의 프로그래머는 조작적인 사고에 익숙하지만 FRP에서는 오히려 지양해야할 것이다. FRP는 내부적으로 이것들을 가린다. 내부 작동은 성능에만 영향을 줄 뿐이다. -> 내부 구현보다 개념에 더 집중하라.  

- FRP에서 함수형 프로그래밍은 로직을 기술하는 언어의 문장을 조작하는 메타언어의 성격을 가진다. -> 규칙을 서술하고, 이 규칙을 합성하여 새로운 규칙을 만든다.  

## Chapter 2. FRP의 핵심  

---  

1. 타입 : Stream, Cell  
2. 기본 연산 : map, merge, hold, snapshot, filter, lift, never, constant  
3. StreamLoop와 CellLoop를 전방 참조  
4. hold와 snapshot을 사용한 누적기  

- Cell : 시간에 따라 변할 수 있는 값  
- Stream : 이벤트의 흐름, (유의어 : 이벤트[이 경우, 이벤트안에 이벤트 발생이 들어있다라고 표현], 이벤트 스트림, 관찰자, 시그널), 이벤트가 스트림을 통해 전달되는 경우, 스트림을 '발사한다(fire)' 혹은 내보낸다 표현  
  - stream은 자신을 통해 전달될 수 있는 값의 타입을 가짐.  
- Unit : '아무것도 아닌 값'을 나타내는 타입. 인자의 개수를 동일하게 맞추기 위해 사용. -> OOP방식이면 아무것도 안 받는 핸들러를 하나 더 만들것.  
- Payload : 발생한 이벤트(혹은 메시지)에 들어있는 값.  
- map : 한 스트림을 같은 타입이나 다른 타입의 새로운 스트림으로 변환  
  - 원래의 스트림과 변환된 스트림은 개념적으로는 동시에 발사됨.  
        - 물론 실제로는 그렇지 않지만, Transactional context를 이용해 그렇게 보이게 만듬  
- Cell(유의어 : behavior, property, siganl)  
  - Cell이 함수형에서 기피하는 지역적이지 않은 변경 가능한 변수인 것은 아닌가?  
        - 맞다. 다만 이벤트 처리는 태생적으로 상태를 동반하고, 이를 바꿀 수 있는 것은 없다.  
        - 그래서 이를 FRP에서 사용하기 위해서는 이를 FRP의 방법으로 다루기 위해 Cell과 Stream을 사용한다.  
        - Cell의 내부 값은 변경이 가능하지만, Stream이나 Cell 자체는 불변 값이기 때문에 참조 투명성이 있는 함수 내부에서도 사용 가능하다.  
        - 이는 합성성을 해치지 않게 만들어 준다.  
        - 다만 이는 FRP 기본 연산에 넘기는 함수가 참조 투명성을 만족해야만 유효하다.  
- FRP에서의 연산 : 스트림이나 셀을 다른 스트림이나 셀로 변환하는 함수나 코드  
  - 기본 연산(primitive) : 다른 연산자를 조합하여 표현할 수 없는 연산. FRP에서 모든 연산의 근본 재료가 됨  
- I/O와 로직은 분리되어야 한다. 보통 I/O는 시퀀스 방식으로 이루어지기 때문에, I/O 부분을 분리한 후, FRP 시스템에 연결하는 방식을 권장한다. -> 방법은 추후 설명  
- FRP가 제대로 작동하기 위한 조건 : __참조 투명성__ , 혹은 순수(pure)  
    1. I/O수행 금지  
    2. 함수 내부에서 발생한 예외는 내부에서 처리해야 한다.  
    3. 변경 가능한 외부 변수를 함수 내부로 끌어오면 안된다. 단, 상수는 가능하며 오히려 권장된다.  
    4. 외부에서 보이는 변수의 상태 변경이 금지된다.  
    5. 함수 호출과 호출 사이에 지속되는 상태를 유지해서는 안된다.  
  - 요약: side-effect가 없어야 하고, 인자 값 이외의 외부 상태에 반환값이 영향을 받아도 안된다.  
  - 예외 : 진단 메시지를 찍을 때 -> 프로그램에 논리적 영향을 끼치지는 않으나, 실행순서가 예상과 달라질 수는 있다.  
- Stream과 Cell을 어떻게 구분하여 쓸 것인가?  
  - 사용자나 프로그램이 모두 이벤트를 발생시키는 경우는 Stream  
  - 프로그램만이 이벤트를 발생시키며, 시간에 따라 변화하는 값을 표현할때는 Cell  
- Cell은 변수일 수도 있지만 상수일 수도 있음.  
- 기본 연산 설명  
  1. map : 위 설명 참조  
  2. merge : 두 개의 Stream을 합친 Stream을 반환. 이렇게 해서 하나의 Stream을 받는 곳에서 두 개의 Stream의 값 변화를 모두 감지 가능  
      - 동시에 발생할 경우의 정책  
        - 두개의 이벤트를 하나로 합쳐서 발사, 이 경우 합치는 함수를 제공해야 함  
        - 두 이벤트 중 하나를 버림. 이 때 우선순위가 낮은 이벤트가 버려짐  
        - 두 개의 이벤트를 합치지 않고 한 스트림에서 두 개 이상의 이벤트를 발사하기도 함.  
          - 단순화를 위해서는 권장하지 않음  

      - 일부 유사 FRP 시스템에는 이러한 동시 이벤트라는 개념 자체가 없기도 한데,  이는 합성성을 깨는 원인이 된다.  
      - merge의 동작방식  

        1. 개념적으로는 이벤트의 순서를 감지할수 없지만, 조작적으로 보면 이벤트는 바람직한 순서의 반대로 일어남.  
        2. 더 이상의 입력이 들어오지 않는다는 확신이 들 때까지 임시 저장고에 이벤트를 보관  
        3. 더 이상 입력이 없으면 이벤트를 출력. 이 때 동시에 두 이벤트르 받았다면 제공받은 함수를 사용해 두 이벤트를 합친다.  

  3. hold : Stream의 결과를 Cell에 저장함. 즉 Stream을 Cell로 바꿔줌.  
      - Cell의 값은 Stream에서 가장 최근에 받은 값  
      - Cell은 항상 값을 가지고 아무때나 값을 추출할 수 있어야 한다. 따라서 hold를 사용할 때는 최초로 이벤트가 도착할 때까지 Cell에 담아둘 기본값을 지정해야 한다.  
      - Stream은 이벤트를 발사하는 순간만 값을 가진다.  

  4. snapshot : Stream이벤트가 발생된 시점의 Cell 값을 캡쳐함.이후 제공받은 함수를 통해  스트림 이벤트의 값과 셀 값을 합친다. (유의어 : withLatest, attach, tag)  
      - 작동 방식  
          1. Stream 이벤트가 발생하면 지정된 Cell의 값을 캡쳐해옴.  
          2. 캡쳐해온 값에 f를 적용하여 새로운 이벤트를 만듬. f가 없는 버전에서는 그냥 Cell의 값만 캡쳐해 옴  
          3. 해당 이벤트를 스트림을 통해 내보냄  
      - 전방 참조(Forward reference) 문제 : 선언 전에 식별자를 사용하게 되는 문제.  
