
# 함수형 반응형 프로그래밍(Functional Reactive Programming)  

저자 : 스티븐 블랙히스, 앤서니 존스  
역자 : 오현석  
출판사 : 매닝출판사, 한빛미디어  
출판년월 : 2017/8  
페이지 : 492  

---

## __Chapter 1. 듣기를 멈추자!__  

---  

- FRP? 표준 프로그래밍 언어에서 간단한 라이브러리 형태로 적용되며, 관찰자 패턴에서 사용되는 리스너(listener, 혹은 callback)을 대신함.->관찰자 패턴 자체를 대치  
- 프로젝트의 복잡도가 너무 높아질 때의 근본적 해결법 = __리팩토링__ , FRP는 제어할 수 없는 복잡도를 예방하거나 고칠 때 도움이 되기 때문에 리팩토링과 잘 어우러진다.  
- 표시적(denotative)이고 시간 연속적(temporally continuous)  
- 표시적이란? 정확,간결,구현독립적,합성가능한 semantic으로 프로그램이 이루어져야 한다.
- FRP - 함수형 프로그래밍과 반응형 프로그래밍의 교집합
  - 함수형
        1. 수학적 의미의 함수에 기반함  
        2. 공유된 변경 가능상태를 의도적으로 피함 -> 불변 데이터 구조 사용  
        3. 합성성 강조 -> FRP의 복잡도를 효율적으로 처리할 수 있는 원동력  
    - 반응형  
        1. 프로그램을 제어의 흐름으로써가 아니라 이벤트 기반, 입력에 반응하는 데이터 흐름으로 이해하는 광범위한 용어  
        2. 프로그램 구성요소 간의 느슨한 결합을 허용하여 코드가 더 모듈화 된다.  
    - 함수형 반응형 프로그래밍 : 반응형 프로그래밍을 달성하기 위해 함수형 프로그래밍의 규칙을 따르도록 강제하는 구체적인 방법. 합성성 강조  

- 반응형 프로그래밍으로 설명되는 시스템은 분산처리를 강조하지만 FRP는 더 세밀한 단위를 사용해 일관성을 강조. 분산 시스템에서 규모 확장성을 위해서는 일관성이 완화되어야만 하기 때문에 FRP는 분산 시스템을 위한 것이 아니다. ex) Akka는 반응형 프로그래밍으로 분류되는데, 분산 시스템을 위한 것으로 FRP가 아닌 actor모델을 사용한다.  

- Rx는 아카와 FRP 중간 어느 지점에 위치. Rx는 이벤트 핸들러를 사슬처럼 엮는데 관심이 있다. FRP는 작업 방식을 더 엄격히 제한하며, 더 많은 것을 보장한다.  

- 두 가지 프로그래밍 모델  
    1. 스레드 : 상태 변화를 제어 흐름으로 모델링 -> FSM,I/O에 잘 어울림  
    2. 이벤트 : 이산적이고 비동기적으로 전파되는 메시지 -> GUI,비디오게임  

- 모든 프로그램은 상태 기계, 상태 기계는 분석이 어렵고, 그래서 프로그래밍이 어렵다. 프로그래머는 이 어려운 프로그래밍을 구조화해서 분석하고 관리하기 쉽게 만드는 것, 즉 추상화 능력이다.  
- 이벤트 기반 프로그램에도 다양한 버그가 있다. 하지만 __이 중 대다수는 예방할 수 있다.__  
- 기존 코드 : 생산자가 소비자에 의존, 관찰자 패턴 : 소비자가 생산자에 의존  
  - 장점 : 프로그램의 확장이 쉽고, 구성요소 간의 연결이 느슨해짐  
- 리스너 버그의 근원  
    1. 예측 불가능한 순서  
    2. 첫 번째 이벤트 소실  
    3. 지저분한 상태  
    4. 스레드 문제  
    5. 콜백 누수  
    6. 의도치 않은 재귀  
  - 이것들을 고치기 위해 관찰자 패턴을 연구하다 보면 자연스레 FRP에 도달하게 될 것이다.  
- FRP로 재시작이 필요없는 프로그램을 만들 수 있다. 일반적인 변경 가능한 변수 대신 변경 통지와 실행순서 관리를 자동으로 해주는 컨테이너에 상태를 저장한다. (여기서는 Cell)  
- 복잡도를 다루는 핵심 - __합성성__  
- FRP의 작동방식 : 데이터 입력 - 비즈니스 로직으로 데이터 검증 - 상태 변화  
- FRP의 두가지 기본적 데이터 타입  
    1. 셀 : 시간에 따라 변화하는 값을 표현 -> 변수의 추상화된 형태  
    2. 스트림 : 이벤트의 흐름  
- FRP의 구조  
    1. FRP 로 작성된 문장들을 해석하여 방향성 그래프로 초기화  
    2. 방향성 그래프를 FRP엔진에 보내 입력이 들어왔을 때 방향성 그래프가 지정하는 의존성 관계대로 처리하게 만듬(스프레드시트와 같은 방식으로 작동한다!) -> GUI 라이브러리의 동작 방식과 유사  
- FRP의 패러다임  
  - 패러다임은 참이라고 여기는 몇가지 가정을 근거로 하며 이는 사람마다 다르다. 이 가정이 상당히 다를 경우 서로 통약불가능(incommensurable)하다고 한다.  
  - 패러다임은 천천히, 또는 어떤 깨달음에 의해 한순간에 바뀐다. FRP는 간단한 아이디어지만, 그것을 이해하기까지의 과정은 도전이다.  
- 스레드는 시퀀스 표현에, 이벤트는 의존성 표현에 사용된다. 의존성을 스레드로 표현하거나 이벤트를 시퀀스로 표현하려면 쉽게 복잡해진다. FRP는 시퀀스 중심의 프로그래밍을 문제 설명에 더 가까운 방식으로 바꾼다.  

- 선언적 프로그래밍 : 어떻게(How)보다 무엇(What)을 하는 프로그램인지를 서술하는 방식의 프로그래밍 - operation 보다는 concept, 훨씬 이해가 쉽다.  

- FRP의 기반 철학 : 프로그램은 입력을 출력으로 변환하는 것  

- 대부분의 프로그래머는 조작적인 사고에 익숙하지만 FRP에서는 오히려 지양해야할 것이다. FRP는 내부적으로 이것들을 가린다. 내부 작동은 성능에만 영향을 줄 뿐이다. -> 내부 구현보다 개념에 더 집중하라.  

- FRP에서 함수형 프로그래밍은 로직을 기술하는 언어의 문장을 조작하는 메타언어의 성격을 가진다. -> 규칙을 서술하고, 이 규칙을 합성하여 새로운 규칙을 만든다.  

## Chapter 2. FRP의 핵심  

---  

1. 타입 : Stream, Cell  
2. 기본 연산 : map, merge, hold, snapshot, filter, lift, never, constant  
3. StreamLoop와 CellLoop를 전방 참조  
4. hold와 snapshot을 사용한 누적기  

- Cell : 시간에 따라 변할 수 있는 값  
- Stream : 이벤트의 흐름, (유의어 : 이벤트[이 경우, 이벤트안에 이벤트 발생이 들어있다라고 표현], 이벤트 스트림, 관찰자, 시그널), 이벤트가 스트림을 통해 전달되는 경우, 스트림을 '발사한다(fire)' 혹은 내보낸다 표현  
  - stream은 자신을 통해 전달될 수 있는 값의 타입을 가짐.  
- Unit : '아무것도 아닌 값'을 나타내는 타입. 인자의 개수를 동일하게 맞추기 위해 사용. -> OOP방식이면 아무것도 안 받는 핸들러를 하나 더 만들것.  
- Payload : 발생한 이벤트(혹은 메시지)에 들어있는 값.  
- Cell(유의어 : behavior, property, siganl)  
  - Cell이 함수형에서 기피하는 지역적이지 않은 변경 가능한 변수인 것은 아닌가?  
        - 맞다. 다만 이벤트 처리는 태생적으로 상태를 동반하고, 이를 바꿀 수 있는 것은 없다.  
        - 그래서 이를 FRP에서 사용하기 위해서는 이를 FRP의 방법으로 다루기 위해 Cell과 Stream을 사용한다.  
        - Cell의 내부 값은 변경이 가능하지만, Stream이나 Cell 자체는 불변 값이기 때문에 참조 투명성이 있는 함수 내부에서도 사용 가능하다.  
        - 이는 합성성을 해치지 않게 만들어 준다.  
        - 다만 이는 FRP 기본 연산에 넘기는 함수가 참조 투명성을 만족해야만 유효하다.  
- FRP에서의 연산 : 스트림이나 셀을 다른 스트림이나 셀로 변환하는 함수나 코드  
  - 기본 연산(primitive) : 다른 연산자를 조합하여 표현할 수 없는 연산. FRP에서 모든 연산의 근본 재료가 됨  
- I/O와 로직은 분리되어야 한다. 보통 I/O는 시퀀스 방식으로 이루어지기 때문에, I/O 부분을 분리한 후, FRP 시스템에 연결하는 방식을 권장한다. -> 방법은 추후 설명  
- FRP가 제대로 작동하기 위한 조건 : __참조 투명성__ , 혹은 순수(pure)  
    1. I/O수행 금지  
    2. 함수 내부에서 발생한 예외는 내부에서 처리해야 한다.  
    3. 변경 가능한 외부 변수를 함수 내부로 끌어오면 안된다. 단, 상수는 가능하며 오히려 권장된다.  
    4. 외부에서 보이는 변수의 상태 변경이 금지된다.  
    5. 함수 호출과 호출 사이에 지속되는 상태를 유지해서는 안된다.  
  - 요약: side-effect가 없어야 하고, 인자 값 이외의 외부 상태에 반환값이 영향을 받아도 안된다.  
  - 예외 : 진단 메시지를 찍을 때 -> 프로그램에 논리적 영향을 끼치지는 않으나, 실행순서가 예상과 달라질 수는 있다.  
- Stream과 Cell을 어떻게 구분하여 쓸 것인가?  
  - 사용자나 프로그램이 모두 이벤트를 발생시키는 경우는 Stream  
  - 프로그램만이 이벤트를 발생시키며, 시간에 따라 변화하는 값을 표현할때는 Cell  
- Cell은 변수일 수도 있지만 상수일 수도 있음.  
- 기본 연산 설명  
  1. map : 한 스트림을 같은 타입이나 다른 타입의 새로운 스트림으로 변환  
      - 원래의 스트림과 변환된 스트림은 개념적으로는 동시에 발사됨.  
        - 물론 실제로는 그렇지 않지만, Transactional context를 이용해 그렇게 보이게 만듬  

  2. merge : 두 개의 Stream을 합친 Stream을 반환. 이렇게 해서 하나의 Stream을 받는 곳에서 두 개의 Stream의 값 변화를 모두 감지 가능  
      - 동시에 발생할 경우의 정책  
        - 두개의 이벤트를 하나로 합쳐서 발사, 이 경우 합치는 함수를 제공해야 함  
        - 두 이벤트 중 하나를 버림. 이 때 우선순위가 낮은 이벤트가 버려짐  
        - 두 개의 이벤트를 합치지 않고 한 스트림에서 두 개 이상의 이벤트를 발사하기도 함.  
          - 단순화를 위해서는 권장하지 않음  

      - 일부 유사 FRP 시스템에는 이러한 동시 이벤트라는 개념 자체가 없기도 한데,  이는 합성성을 깨는 원인이 된다.  
      - merge의 동작방식  

        1. 개념적으로는 이벤트의 순서를 감지할수 없지만, 조작적으로 보면 이벤트는 바람직한 순서의 반대로 일어남.  
        2. 더 이상의 입력이 들어오지 않는다는 확신이 들 때까지 임시 저장고에 이벤트를 보관  
        3. 더 이상 입력이 없으면 이벤트를 출력. 이 때 동시에 두 이벤트르 받았다면 제공받은 함수를 사용해 두 이벤트를 합친다.  

  3. hold : Stream의 결과를 Cell에 저장함. 즉 Stream을 Cell로 바꿔줌.  
      - Cell의 값은 Stream에서 가장 최근에 받은 값  
      - Cell은 항상 값을 가지고 아무때나 값을 추출할 수 있어야 한다. 따라서 hold를 사용할 때는 최초로 이벤트가 도착할 때까지 Cell에 담아둘 기본값을 지정해야 한다.  
      - Stream은 이벤트를 발사하는 순간만 값을 가진다.  

  4. snapshot : Stream이벤트가 발생된 시점의 Cell 값을 캡쳐함.이후 제공받은 함수를 통해  스트림 이벤트의 값과 셀 값을 합친다. (유의어 : withLatest, attach, tag)  
      - 작동 방식  
        1. Stream 이벤트가 발생하면 지정된 Cell의 값을 캡쳐해옴.  
        2. 캡쳐해온 값에 f를 적용하여 새로운 이벤트를 만듬. f가 없는 버전에서는 그냥 Cell의 값만 캡쳐해 옴  
        3. 해당 이벤트를 스트림을 통해 내보냄  
      - 전방 참조(Forward reference) 문제 : 정의하기 전에 식별자를 사용하게 되는 문제.  
        - 값 루프(Value Loop) :  함수형 프로그래밍에서 어떤 값이 자기 자신을 사용해 직접 정의되거나 다른 변수를 통해 간접적으로 정의되는 것  
          - 값 루프는 조작형 언어에서는 사용할 수 없다.  
          - 이를 해결하기 위해서 CellLoop라는 것을 추가, 값을 대입하기 전에 미리 해당 변수를 참조할 수 있게 만든다.  
            - 이와 비슷하게 StreamLoop도 있다.  
      - FRP 코드 안에는 시퀀스라는 것이 존재하지 않는다. 임의대로 각 줄을 뒤섞고 필요에 따라 CellLoops나 StreamLoops를 삽입해도 코드는 동일하게 동작한다.  
        - 다만 현실의 제약이 있어서 Loop의 선언과 그 안에 값을 삽입하는 것은 반드시 같은 트랜잭션에서 실행되어야 한다.  
      - snapshot이 보는 값은 과거의 값인가 변경된 값인가?  
        - 어떤 이벤트가 촉발하는 변화는 원자적이기 때문에, 두 가지 상태가 동시에 존재할 수는 없다.  
        - 이에 대한 접근 방법  
          1. 무조건 예전의 값을 본다. 트랜잭션이 끝나야지만이 값이 갱신된다. -> 이 책에서 사용하는 방법  
          2. 무조건 새로운 값을 본다. 이 경우 루프 안에 있으면 결과를 예측할 수 없다.  
          3. 새로운 값을 보지만, delay라는 연산을 통해 명시적으로 이전 값을 볼 수 있다.  
          4. 루프를 허용하지 않으며, 고수준의 accum 스타일로만 사용해야 한다.  

  5. filter : Stream 값이 정해진 경우만 흘러가게 만든다.  
      - filter에 사용되는 함수 역시 참조 투명성을 만족해야 한다.  

  6. lift : 두 개 이상의 Cell을 하나로 조합하는 것. map과 유사하지만 map은 단일 Cell에 작용한다는 점이 다름  
      - 함수형 프로그래밍에서 lift는 값에 대한 함수를 그 타입이 들어있는 컨테이너에 대한 함수로 만들어 주는 것이다. (A->B => C< A > -> C< B >)  
      - FRP에서 lift라 하는 이유는 값에 작용하는 함수를 Cell에 작용하는 함수로 끌어올려 주기 때문이다.  
      - lift의 출력 Cell은 입력 중 하나가 변경되면 자동으로 갱신된다.  
      - map과 lift는 종종 같은 의미로 혼용된다.  
        - 이 책에서는 단일 Stream이나 Cell에 대해서는 map, 둘 이상의 Cell에 대해서는 lift 사용.  

  7. never : 이벤트를 절대 발사하지 않는 스트림을 만든다.  
      - FRP의 상태변화는 모두 외부 I/O로 부터 시작된 이벤트로 인해 일어난다.  
          - 따라서 never 스트림과 결합된 요소는 앞으로도 상태 변화에 아무런 영향을 주지 못한다.  

  8. constant : 특정 Cell의 값을 고정시킴  
      - 엄밀히 말하면 never와 hold의 조합으로 표현할 수 있으므로 기본 연산이 아니다.  

  - 그 외 기본 연산 : sample, switch  

## Chapter3. 간단한 위젯 만들기  

---  
2장에서 배운 내용에 대한 실습. 실습 코드는 [Swidget](https://github.com/SodiumFRP/sodium/tree/master/book/swidgets) 참조  

## Chapter4. 실제 애플리케이션 작성하기  

---  

- 전체 소스 코드 : [주유 펌프](https://github.com/SodiumFRP/sodium/tree/master/book/petrol-pump)  

- 관찰  
  - 기본  
    1. Input 과 Output으로 캡슐화된 인터페이스. 각각 Cell 또는 Stream 이다.  
        - Input은 외부세계 또는 Output으로부터 입력을 받는다.  
        - Output은 결과를 Input또는 외부 세계로 흘려보낸다.  

    2. 모든 Input과 Output은 불변성을 유지하기 위해 상수로 선언.  
        - 컨테이너만 상수니까 내용은 바꿀 수 있음.  
        - 이는 FRP에서 가장 중요한 **합성성**을 유지하기 위함.  

    3. set 메서드의 선언  
        - 해당 부분만 바뀐 전체 객체를 새로 만들어 반환  
        - 이 역시 불변성을 유지하기 위해서이다.  
        - 보기에는 비효율적일 수도 있지만, 생각보다 비효율적이진 않다.  
        - 오히려 지나치게 성능만 고려하면 좋지 못한 결과가 나오기도 한다.  
        - 성능에 대한 결정은 항상 프로파일링 결과를 바탕으로 이루어져야 한다.  
  - 구현  
    1. 주유 로직(Life Cycle)  
        - 입력 : 노즐 3개  
        - 출력 : sStart, sEnd, fillActive.  
            - sStart와 sEnd는 fillActive에 의존하고, fillActive는 다시 sStart와 sEnd에 의존한다.  
            - 이럴 때 Loop를 사용한다.  
        - 코드가 오히려 더 장황해지는 것은 아닌가?  
            1. FRP는 프로그램이 클 수록 그 위력을 발휘함  
            2. 일반적인 프로그래밍 언어로 직접 표현하면 투박해짐  
                - 전처리기 등으로 하면 더 개선될 여지가 많음.  
                - 다만 아직 전처리기 개발이 잘 이루어지지는 않았다.  
    2. 연료량 계산(accumulate)
        - 입력 : sClearAccumulator, sDelta, Callibration  
        - 출력 : litersDelivered  
        - 매 펄스를 누적시키는 Cell, 펄스에 매 펄스당 나오는 연료량을 나타내는 Calibration 값을 곱해 반환  
        - 별도 클래스로 구현하지는 않고, Pump 클래스에서 정적 메서드로 구현  
    3. 연료의 가격 표시
        1. 주유시점의 가격 고정(capturePrice)  
            - 입력 : price1, price2, price3, sStart  
            - 출력 : price  
            - Fill class의 정적 메서드로 구현  
        2. 주유량과 가격 표시(Fill)  
            - accumulate 메서드와 capturePrice의 조합  
            - 출력 : litersDelivered, dollarsDelivered  
            - 자바 기준으로, 출력이 하나면 정적 메서드가 쉽고 두 개 이상이면 클래스가 더 쉽다.  
    4. POS 시스템과의 통신, 그 이후 초기화  
        1. 통신은 주유와 별개의 영역이므로 다른 클래스로 구현한다.  
        2. 통신은 오래 걸리기 때문에 중간에 일어나서는 안되는 이벤트가 일어날 수도 있다. 그것을 막기 위해 gate 연산을 적용한다.  
            - gate연산 : 인자로 지정한 Cell의 값이 참인 경우에만 이벤트가 흘러가게 허용한다.  
                - snapshot과 filter의 조합이기 때문에 기본연산은 아니다.  
    5. 키패드 모듈을 구현한다.  
        - 컴파일러 기능을 최대한 활용하여 버그를 방지하자  
            - 이 경우에서는 if-else 대신 ?:(삼항 연산자)를 이용한 것  
        > ### 모듈성에 대한 노트
        > - 모듈의 형태  
        >   1. 모든 필드를 public한 상수형태로 정의한다.  
        >       - 필드의 유일한 목적은 Stream이나 Cell을 사용 가능하게 하는 것 뿐  
        >       - private한 필드를 원한다면 생성자 안에서 지역변수를 사용하라  
        >       - 객체의 내부 상태 변경은 문제를 야기할 뿐이다. 따라서 모두 상수로 선언한다.  
        >   2. 클래스의 유일한 메서드는 생성자뿐이다.  
        >      - 상수를 초기화 할 수 있는 기회는 생성자 뿐이다.  
        >   3. 당연히 이것은 OOP가 아니다.  
        >       - OOP의 목적은 객체의 상태 관리  
        >       - FRP에서는 이를 Stream과 Cell을 이용해 다룬다.  
        >   4. 출력이 하나뿐인 모듈이 필요하면 정적 메서드를 쓰라.  
        >       - 모든 것이 불변이기 때문에 public으로 해도 문제가 없다.  
        >       - 지역적으로만 사용해도 된다면 private도 무방하다.  
        > - 여러 값을 반환하는 방식이 튜플인지 클래스인지는 해당 언어에서 널리 쓰이는 방식을 적용하면 된다.  
        >   - 자바에서는 튜플보다 클래스  
        > - FRP의 특징은 모듈의 입력과 출력이 명시적이라는 것  
        >   - FRP 모듈은 상태로만 이루어진 로직이고, 호출하는 쪽에서 그 모듈을 잘 연결해서 일하도록 만들어야 한다.  
        >   - 이러한 방식은 우리가 작성한 코드가 올바르다는 것을 컴파일러가 증명할 수 있게 만드는 것.  
        > - FRP 모듈의 입력과 출력이 너무 많이지는 경우가 종종 있다.  
        >   - 대부분의 프로그래밍 상황에서는 코드 냄새이지만, FRP에서는 정도가 약간 덜하다.  
        >   - FRP에서는 프로그램이 서로 통신하는 부분을 감출 방법이 없어서 더 많은 입출력을 명시적으로 써야하다보니, 이전보다 입출력이 많이 보일 수는 있다.  
        >   - 그럼에도 너무 많다면, 컨테이너 클래스를 만들어 그 안에 감추는 방법을 쓰면 된다. 이는 매우 강력하다.  
        > - FRP는 버그의 대부분을 미연에 방지한다. 하지만 버그의 가능성은 여전히 남아있다.  
        >   1. 정해진 입력과 출력을 사용하는 것을 잊어버릴 수도 있다.  
        >      - 선언해놓고 사용하지 않는 값이 있다면 그것은 거의 확실히 버그다.(물론 의도적으로 무시하는 경우는 예외다)  
        >      - 컴파일러의 경고를 주의깊게 보라  
        >   2. 입력값을 공급하는 것을 잊을 수 있다.  
        >      - 다만 대부분 컴파일러가 경고를 할 것이다  
        >      - 제공할 게 없으면 never Stream이라도 제공해야 한다  
        >   3. 타입이 동알한 값을 실수로 혼용하는 경우가 있다.  
        >      - 혼동할 수 있는 타입을 단독으로 담는 컨테이너로 감싸도록 하라.  
        >      - 이렇게 하면 값의 의미를 타입명에 반영할 수 있어서 의미가 더 명확해진다.  
        >      - 이러한 패턴은 함수형 프로그래밍에서 흔하게 일어나는데, 이것을 하스켈에서의 키워드인 newtype을 따와서 뉴타입 패턴이라 하자.  
    6. 현재 주유 금액 추가하기  
        - 입력 : 미리 지정한 금액, 연료 가격, 주유한 연료의 양(리터), 주유중인 연료, 주유 활성화  
        - 출력 : 주유, 키패드 활성화  
        - 로직  
            - 0은 미리 지정한 최대 주유금액이 없다는 뜻  
            - 미리 지정한 금액 바로 직전에만 주유 속도를 늦춰서 천천히 주유한다.  
            - 미리 지정한 금액에 도달하면 주유를 멈춘다.  
            - 주유 속도가 느려지기 전까지 주유금액 변경 가능, 느려지면 입력 금지  
        - 입력, 출력, 로직을 정하면, 그것을 FRP 방식으로 표현하면 프로그램이 완성된다.  
- 결론  
  - 코드의 절반은 주고받을 값을 정하기 위한 오버헤드  
  - 나머지 대부분은 상태가 있는 로직이다.  
  - 이렇게 값을 전달하는 이유는 변수의 영역을 제한해서 코드를 깔끔하게 유지하는 것이다.  
  - FRP 코드에 없는 것  
    - 명시적인 순서가 없다. 이해를 돕기 위해 순차적으로 보이게 썼을 뿐이다.  
    - 상태 갱신에 가장자리 조건에 들이는 실질적 관심이 없다. 대부분은 그냥 사라져 버린다.(다는 아니다)  
    - 일반적인 변경 가능한 변수에 상태를 저장하지 않고 Cell을 사용한다.  
    - 스레드 등 제어 흐름 비슷한 것은 사용하지 않는다.  
    - 상태 변경을 코드에서 직접적으로 시작하지 않는다. Cell이나 Stream은 언제나 정보의 소스다.  
      - 정보가 도달해야 하는 Sink의 개념이 FRP에는 없다.  
      - 상태를 변경하는 유일한 방법은 Stream의 이벤트이며, 직접 만들 수 있는 Stream은 never 뿐이다.  
      - 따라서 상태를 변경하는 요인들은 FRP 시스템 외부에서 밖에 없다. 그래서 이런 방식을 반응형(Reactive)라 한다.  

## Chapter5. 새로운 개념  

---  

### 왜 프로그래밍이 점점 복잡해지는가  

- 원하는 성능을 위해서 하드웨어 아키텍처는 점점 복잡해져 왔으며, 이에 맞춰 소프트웨어 아키텍쳐도 더 복잡해졌다.  
- 우리가 써온 대부분의 프로그래밍 언어들은 폰 노이만 기계에서 동작하기 위해 설계되었으나, 실제로는 그렇지 않다. 또한 폰 노이만 구조는 병렬성을 달성하기 어렵다.
- 다양한 아키텍쳐가 존재하고 미래에도 새로운 아키텍쳐가 나올 수 있는데, 지금까지의 프로그래밍 언어는 폰 노이만 구조 하나에만 최적화되어 있다.  
- 근본 원인 : 문제 자체가 아닌, 특정 기계에만 잘 들어맞는 프로그램을 작성하고 있기 때문!  

### FRP는 이 문제를 어떻게 다루는가  

- 특정 아키텍쳐에 의존적이지 않고, 문제 그 자체에 집중한 프로그램을 작성하고, 그 정보를 컴파일러(FRP 시스템)에 넘겨 대상 기계에 최적화인 코드를 만들어 내는 것!  
- 프로그래밍이 병렬성을 얻게 되면 훨씬 적은 전력으로 동일한 스루풋을 달성할 수 있다.  
  - 이 병렬성이야 말로 기계가 아닌 문제에 촛점을 맞춘 프로그래밍 기법을 채택하도록 이끌어 갈 것이다.  
    - 다만 현재의 구현은 병렬성을 많이 살리지는 못한다. 그렇지만 근본적으로 FRP는 전통적인 방법과는 다른 방식으로 병렬성을 달성할 수 있다.  

### - FRP가 복잡성 문제를 해결하는 법 : **합성성**  

- 프로그램의 복잡도는 지수적으로 증가한다.  
  - 기존에는 리팩토링을 해서 균형을 잡아주었다.  
- FRP에서는 복잡도가 선형적으로 증가한다.  
  - FRP의 합성성은 수학적으로 증명될 수 있기 때문에 어떤 FRP 코드라도 합성성이 보장된다.  

- 엔지니어링은 기본적으로 환원주의(reduction)을 기반으로 한다.  
  - 이는 문제를 작은 부분으로 나눠 해결한 뒤 합치는 방법이다.  
  - 각각의 작은 문제들의 합성성이 보장되지 않으면 환원주의는 실패한다.  
- FRP는 합성성을 강제함으로 환원주의가 성립할 수 있도록 하고, 그런 식으로 작업하도록 강제한다.  
- 프로그래머들이 당면한 문제는 점점 더 병렬적이고 분산적이며 더 복잡해지고 있다. 이러한 문제를 해결하는데 필요한 것은 합성성이다.  
- FRP는 합성성을 위해 많은 부분을 강제한다. 하지만 이러한 것에서 오는 어려움을 이겨내면 많은 버그를 해결할 수 있다.  
- FRP 시스템에서는 Cell이나 Stream에 있는 값이 코드의 여러 군데에서 참조되므로 처리과정에서 변하지 않는 것이 중요하다. 즉, 불변성이다.  
- FRP에서는 의존관계가 명확하기 때문에 리팩토링도 쉽고, 그로 인해 적절한 추상화를 기존보다 쉽게 이뤄낼 수 있다. 이는 곧 프로그램의 의도를 명확히 하게 된다.  
  - '누군가 버그를 보고하면 프로그램을 돌려보지 않아도 버그를 찾을 수 있을 정도가 되어야 한다.'  
- 추상화는 이해에 더 시간이 들어가기 때문에 분명히 비용이다. 하지만 FRP는 추상화에 의한 비용보다 유용성이 높은 경우가 많이 있다.  

## Chapter6. 웹에서의 FRP  

---  

- FRP가 특히 잘 어울리는 영역  
  1. 이벤트 기반 UI  
  2. 네트워크  
  -> 웹 애플리케이션에 적용하기 적절하다.  

- RxJS- FRP 기능을 가지는 시스템. 웹 어플리케이션에서 널리쓰임  

- Rx vs Sodium  
  - Sodium :  '진정한 FRP'라는 핵심 개념을 실용적이고 최소한으로 구현하는 것을 목표로 함.  
    - 버그 발생을 최소화하기 위해 제약을 많이 가함  
  - Rx : 실제 세계의 문제를 푸는 것을 돕기 위해 설계.  
    - 종종 FRP가 아닌 코드들을 함께 조합해서 사용  
    - 이는 FRP 기본 요소들을 직접 만들어 내는 것에 해당하며, 합성성을 유지하기 어렵게 만든다.  
- Rx에는 '표시적 의미론'이 부족하다. 즉, 각 부분들 중 합성성이 부족한 분야가 았다는 것으로, Rx를 '진정한 FRP'로 인정받지 못하게 한다.  

### Rx의 특징들  

1. Observable : Sodium의 Stream에 대응하는 것.  
    - Stream은 한 가지 이벤트 타입만 지원하지만, Observable은 onNext, onError, onComplete의 세가지 이벤트 타입 지원  
    - 값의 시퀀스를 표현하며, 값을 얻기 위해서는 Observable을 구독해야 함.  
    - 구독한 값은 각 이벤트마다 지정된 콜백 함수를 통해 전달받게 됨.  
2. 뜨거운 Observable과 차가운 Observable  
    - 차가운 Observable : 구독하면 처음부터 모든 정보를 순차적으로 얻을 수 있다.  
      - 함수형 프로그래밍에서의 리스트와 비슷함.  
      - Rx의 목표중 일부가 일반적인 함수형 프로그래밍을 위한 하부 구조를 함수형이 아닌 언어에 제공하는 것이기 때문에 이러한 것을 지원.  
    - 뜨거운 Observable : 구독한 시점 이후에 발생하는 이벤트를 받을 수 있다.  
      - Sodium의 Stream에 해당  
3. 상태 관리  
    - Rx에는 Cell에 해당하는 요소는 없지만, 다른 방법을 통해 비슷한 효과를 얻을 수 있다.  
    - scan() : 마지막으로 이벤트를 처리한 시점의 상태값을 유지하여 상태가 있는 누적기 제공  
        - 제공된 함수에 상태와 새로운 값이 전달되며, 이를 바탕으로 새로운 상태를 반환  
        - sodium의 accum()과 동등하며, 이는 hold-snapshot으로 구현할 수 있다.  
    - withLatestFrom() : 인자로 넘긴 Observable의 가장 최근 값을 가져옴.  
        - Observable을 Cell처럼 취급한 것, 명시적 변환 없이도 처리 가능하다는 특징이 있음  
        - 이전에 이벤트가 발생한 적이 없다면 아무것도 반환하지 않는다.  
    - BehaviorSubject : Sodium의 Cell에 대응하는 것으로 '현재 값'이라는 개념을 포함한다.  
        - 구독하면 현재 값이 즉시 콜백에 전달됨.  
        - 첫 값을 받은 이후에는 뜨거운 Observable로 전환.  
            > Rx에서의 전방참조  
            > - sodium에서 Cell의 전방참조는 Rx의 BehaviorSubject로 구현가능  
            > - Stream의 전방참조는 Subject로 가능  
    - startWith() : 구독하는 순간 초깃값 전달  
        - BehaviorSubject와 비슷하지만 '현재 값'이라는 개념이 없음  
        - 구독하면 항상 정해진 초기값을 전달함  
    - combineLatest() : 두 Observable로부터 현재 값을 조합  
        - sodium의 lift에 해당한다.  

### Rx의 오류들  

1. 글리치(glitch)문제 : FRP시스템에서 정의한 관계와 출력에서 관찰할 수 있는 내용이 다른 경우  
    - 동시 이벤트에서 관계가 복잡해질 때 이러한 문제가 나타난다.  
    - Rx는 이 글리치에서 자유롭지 못하다. Sodium은 이 문제를 해결했다.  
    - 프로젝트에서 어떤 시스템을 사용하기로 하고 자원 투자가 이루어졌다면, 해당 시스템의 글리치는 절대 수정할 수 없다.  
2. merge가 동시성 이벤트를 일관성 있게 다루지 못함.  
    - 이는 합성성의 부재로 인한 문제이다.  

> - Rx가 없애주는 리스너의 재앙들  
>    1. 예측 불가능한 순서 - 미해결  
>    2. 첫번째 이벤트 소실 - 해결  
>    3. 지저분한 상태 - 해결  
>    4. 스레드 문제 - 미해결(단, JS에는 스레드가 없으므로 아예 이런 문제가 없음)  
>    5. 콜백 누수 - 해결  
>    6. 의도치 않은 재귀 - 미해결  
>        - 콜백 내에서 이벤트를 Observable에 넣을 수 있도록 허용하기 때문에 재귀 발생 가능성이 있음  

### Rx로 I/O하기  

- 자신만의 뜨거운 Observable을 만들어낸다.  
    1. Observable을 만들고, 구독자에게 제공할 값을 처리할 함수를 넘긴다.  
    2. 비동기적인 I/O코드를 작성한 다음 onNext()로 값을 내보낸다.  
    3. publish()는 출력을 단일 출력 Stream으로 브로드캐스팅한다. 따라서  인스턴스가 1개만 존재하게 되며 구독자들은 같은 이벤트의 복제본은 받게 된다.
    4. connect()로 명시적으로 Observable을 시작해야 한다.  
- 직접 만든 뜨거운 Observable을 상태가 있는 로직이나 FRP 기본 요소 구현에 사용하지 말라.  
  - 합성성을 보장받기 위해서이다.  
- I/O 코드는 FRP 시스템 외부의 존재로 인식되어야 하며, 섞이지 않도록 특별한 주의를 기울여야 한다.  

### 기타 주의점  

- FRP가 하는 일 중 대부분은 정적 타입 지정(Static typing)의 능력을 활용한다.  
  - 동적 타입 지정에 얽메이지 않고 타입 추론을 잘해주는 정적 타입 언어를 적용해보자  

## Chapter7. 스위치 연산  

- 2장에서 언급하지 않은 나머지 기본 연산 2가지 : switch, sample  
  - sample : 셀의 값을 얻어냄  
    - Cell 내부의 값을 부득이하게 직접 넘겨야 할 때 사용  
    - Cell의 값은 시간에 따라 달라지므로 sample 연산은 참조 투명성을 만족하지 않는다.  
    - 다만 하나의 이벤트 안에서는 동일한 트랜잭션이므로 sample 또는 커스텀 FRP 로직을 사용할 수 있다.  
    - Cell을 직접 반환하는 lift, Cell.map 연산 안에서 sample을 사용하면 안된다.  
  - switch : 프로그램이 실행되는 동안 방향성 그래프를 동적으로 바꾸게 해 줌(유의어 : flatten, join)  
    - FRP 로직을 변경하기 위해 FRP 로직을 사용할 수 있게 해줌  
    - Stream 또는 Cell을 바꿔치기 할 수 있다.  
    - Switch할 때 바꿔치기 된 로직이 계속 참조되고 있다면 바꿔치기 된 로직이 메모리 누수의 원인이 된다.  
      - StreamLoop로 새로운 구현으로 바꿔치기 한다.  
      - once() 메소드를 이용해 Stream에서 이벤트가 1번만 발생하도록 한 뒤에, 이벤트가 발생하면 해제되도록 한다.  
    - 로직이 필요할 때마다 생성해주고, 필요 없어지면 제거할 수 있다. 이는 잘못된 상태를 만들지 않는데 도움이 된다.  
    - 이전 상태를 다른 곳에 Hold해놓음으로 상태간의 전환을 꾀할 수도 있다.  
- FRP가 기존의 방식에 비해 제약하는 것이 많다고 느껴질 수 있다.  
  - 하지만 기존의 프로그래밍 언어도 FRP와는 다르지만 제약이 있었다.  
  - FRP의 제약은 '우리가 사용하는 기계는 폰 노이만 구조이다'라는 가정을 하지 못하게 막는다.  
  - FRP는 우리에게 필요한 것을 제공하지만 우리가 원하는 방식대로 제공하지 않을 뿐이다.  
- FRP는 정적 타입을 사용하여 언어의 타입 시스템을 한계까지 몰아붙인다.  
  - 이러한 코드 정보는 컴파일하는 동안에 사라져서 기계는 아무런 추가 부하가 없다.  
  - 오히려 소스 코드에 더 많은 정보를 넣음으로써 사람에게 더 많은 정보를 제공한다.  
  - 다만 짧은 코드안에 많은 정보가 들어가므로 읽기가 어려울 수 있다.  
  - 중간 변수를 인라이닝 하거나, 타입 추론을 사용하면 좀 더 이해하기 쉽게 만들 수 있다.  
- merge의 효율  
  1. 순차적 merge - O(N)의 시간 복잡도  
  2. 재귀적인 merge(리스트를 계속 반으로 나눠 merge) - O(lg(N))의 시간 복잡도, 갱신이 잦으면 오버헤드가 큼  
  3. switch를 이용해 부분적으로만 재귀 merge  

## Chapter8. 조작적인 기본연산  

- 프로그래밍 과정 중에는 FRP의 핵심 개념과 잘 들어맞지 않는 부분이 존재한다.
  - 이 부분을 해결하기 위해 FRP는 조작적인 기본 연산을 제공한다.  
  - 하지만 이 부분은 FRP의 핵심 개념과는 동떨어져 있기 때문에 필요할 때만 제한적으로 써야한다.  

- FRP 코드를 프로그램의 나머지 부분과 연결하기  
  1. 이벤트를 Stream이나 Cell에 집어넣기  
      - StreamSink, CellSink는 각각 Stream,Cell의 하위 클래스로 Stream이나 Cell에 값을 보내거나 밀어넣을 수 있게 해준다.  
      - Stream이나 Cell에 값을 밀어넣기 전까지는 모든 I/O와 상태 변경을 수행할 수 있다. 즉, 참조 투명성이 적용되지 않는다.  
      - CellSink의 경우는 언제나 값이 존재해야 하기 때문에 초기값이 필요하다. 또 listener를 등록하자마자, Cell의 현재 값을 콜백으로 통지받는다.  
      - 값을 보내는 호출은 자체적인 트랜잭션 안에서 실행된다.  
      - 하나의 트랜잭션 안에서는 하나의 Stream에는 하나의 값만 보내는 게 허용되고, 마지막으로 보낸 값 이외에는 전부 무시되는 게 기본이다.  
      - 하나의 트랜잭션 안에서 스트림에 여러 값을 보내기 위해서는 값을 조합하기 위한 함수를 생성자에 넘겨야 한다.  
  2. Stream이나 Cell의 이벤트를 listen하기  
      - Listen()을 호출하면 Listener객체가 반환되며, 이 Listener 객체에 여러 Listener 객체들을 append할 수 있다.  
      - unlisten()을 호출해서 콜백을 명시적으로 해제한다. append된 것은 합쳐진 Listener를 해제하면 모두 해제된다.  
      - Sodium의 경우는, Listener를 명시적으로 해제하지 않으면 메모리 누수의 원인이 된다.  
  - Sodium에서 FRP와 다른 부분을 연결하는 규칙  
      1. FRP Listener 내부가 아니라면 send()를 호출해도 안전하다. 절대 블록되지 않는다.  
      2. FRP 로직에 넘기는 함수는 참조 투명성을 만족하는 한 뭐든 할 수 있다. 또한 Stream 이벤트를 처리하는 함수는 FRP로직을 만들어 내거나 Sample()을 사용할 수도 있다. 하지만 I/O는 금지된다.  
      3. Listener는 블록되거나 send()를 호출해서는 안된다. 하지만 다른 스레드에게 작업을 위임하는 일을 포함하는 논블로킹 I/O를 할 수는 있다.  
- 지연 연산(Lazy evaluation) : 아직 준비되지 않은 값을 사용하려 할 때는 오류가 나는데 오류를 방지, 값이 정말로 필요할 때 까지 연산을 미룸. 그 전까지는 값에 대한 프록시만 가지고 있음.  
- 트랜잭션 : 다른 FRP 시스템에서는 moment, instant라고도 불림. Rx계열에는 트랜잭션 개념이 없다.  
  1. Sodium에서는 명시적으로 호출하지 않으면 자동으로 트랜잭션을 실행한다.  
  2. 명시적으로 트랜잭션을 만들수도 있다. 빌려쓰기 패턴을 사용함으로 트랜잭션을 열고 닫지 않는 실수를 막아준다.  
  - 트랜잭션의 실행 단계  
      1. 모든 Stream 이벤트를 동시에 처리하기  
      2. 모든 Cell 값을 원자적으로 갱신하기  
    - 이벤트 처리 단계에서는 Cell의 값이 변하지 않기 때문에 각 이벤트가 모두 동시적으로 일어난다고 여길 수가 있다.  
- 명시적 트랜잭션 안에서 FRP 로직 만들기  
  - 초기화 로직을 큰 트랜잭션 하나로 감싸는 방식이 권장된다. 이는 그 트랜잭션 안에서 I/O가 일어날 수 있음을 암시한다.  
    - 일반적으로는 I/O와 FRP를 구분해야 하지만, 초기화 과정에서 하는 것은 문제가 되지 않는다.  
    - Sodium에서는 한 트랜잭션 안에서 한 Stream에 대해 listen과 send를 모두 호출하는 경우 연산 순서에 관계없이 send로 보낸 값이 보이는 것을 보장한다.  
      - 이는 최초의 이벤트를 잃어버리는 재앙을 제거할 수 있다.  
- FRP에서 시간 모델 : Stream은 두 모델 모두 동일, Cell에서만 차이를 보임  
    1. 이산적인 시간 : Sodium에서 주로 촛점을 맞추는 모델  
    2. 연속적인 시간  
      - 연속적으로 변화하는 Cell이라는 개념을 보호하기 위해서는 Cell값의 변화를 관찰할 수 없어야 한다. 즉 Cell을 Stream으로 변환할 수 없어야 한다.  
- update와 value  
    1. update : Cell의 이산적인 변화를 반환, hold의 역.  
        - Cell의 변화를 관찰할 수 없다는 규칙을 위해서는 update를 사용하는 함수가 자신의 호출자에게 Cell의 단계를 노출하면 안된다.  
        - listen하기 시작한 트랜잭션이나 그 이후에 발생한 변화만을 돌려줌  
    2. value : 현재 트랜잭션 안에서 Cell의 현재 값을 이벤트로 발사.  
        - Sodium의 기본 연산들은 자기 자신만을 포함하는 트랜잭션을 자동으로 만들기 때문에 다른 연산과 같은 트랜잭션으로 묶어두지 않으면 값이 사라진다.  
- split : 데이터 패킷을 쪼개서 각각의 쪼개진 패킷을 별도의 트랜잭션을 만들어 처리  
  - 기존에 있던 트랜잭션이 사라지지는 않는다.  
  - split안에서 split을 호출할 수도 있다.  
- defer : 어떤 이벤트 하나를 새로운 트랜잭션에 넣는 것  
  - 리스트 대신에 단일 이벤트를 대상으로 하는 split의 변종으로 구현  
  - Cell 상태의 새로운 버젼을 읽을 수 있는 방법을 제공함  
  - 실제로는 이벤트의 출력 시점을 뒤로 미루는 게 아니라 이벤트를 당기는 효과가 있음. 이벤트가 원래의 다음번 트랜잭션의 앞에 또 다른 트랜잭션을 만들어 넘기는 것이기 때문  
- defer 나 split은 동시에 여러번 써도 한번의 트랜잭션만 만들어진다. 여러 개가 만들어지면 그 순서를 정하는 것이 문제가 되기 때문이다.  
  - 프로그램에서 남용하게 되면 동시성 문제를 일으킬 수 있다.  

### 정리  

- listen과 send는 FRP와 외부 세계와의 인터페이스를 제공한다.  
- update,value,split,defer 이 4가지 연산은 모두 조작적인 연산이므로 힙성성을 깰 여지가 있다.  
  - 따라서 조심스럽게 사용되어야 하고, 조작적인 연산을 할 때만 사용해야 한다.  
- split과 defer는 새로운 트랜잭션을 만들어 낼 수 있는 능력이 있다.  
  - 다만, 남용하면 동시성 문제가 일어나니 조심스럽게 사용해야 한다.  

## Chapter9. 연속적인 시간  

- FRP에서는 독립적인 애니메이션을 정의하고, 원하는 프레임 비율로 추출할 수가 있다.  
  - 레스터 이미지와 벡터 이미지를 생각하면 편할 것이다. 단지 공간이 아닌 시간에 대한 것일 뿐이다.  
  - 외부에서 발생한 이벤트가 전달되기 전에 시간을 표현하는 Cell이 갱신된다.  
  - 이 값은 연속적으로 변화하는 것으로 이해해야 하며, lift나 map의 연산의 결과 역시 연속적이다.  
- TimerSystem : Sodium에서 시간을 처리하기 위해 제공하는 클래스.  
  - SecondTimerSystem : 생성시 Sodium의 트랜잭션 시스템에 자신을 후킹해서 트랜잭션이 생길 때마다 호출되도록 만듦  
    - 트랜잭션이 발생하면 SecondsTimerSystem은 현재의 실제시간을 시스템에 넘김  
    - 연속적인 애니메이션에 대한 서술과 그 애니메이션상의 시간을 움직이며 표본을 추출하는 애니메이션 루프 두가지로 구분이 될 수 있음  
- 시간 측정 : TimerSystem에서는 at()이라는 멤버 변수에 시간 값의 Cell을 넣어 알람을 발생시킬 수 있다.
  - at()을 호출하는 쪽에서 시간을 갱신해주지 않으면 알람이 설정된 상태로 남아 무한루프를 돈다.  

## Chapter10. 패러다임 간의 전투  

- Drag&Drop 예제에서의 상태 기계(State Machine) vs FRP vs 액터 모델  
  1. 상태 기계 - 설계를 잘 하면 간결하게 만들 수는 있다. 하지만 모든 상태가 존재할 수 있는 상황이므로, 프로그래머의 실수로 특정 단계를 누락하게 될 위험성이 남아있다.  
  2. FRP - switch를 이용해 필요할 때에만 필요한 로직이 존재할 수 있게 만듬  
  3. 액터 모델 - 흐름 제어 기능 존재, 또한 암시적 상태 기계를 허용하여 흐름 제어안에 암시적으로 넣을 수 있다.  이는 FRP의 switch와 비슷한 장점을 제공한다.  
  - 이 케이스에서는 액터가 더 간단하다.  
- FRP가 모든 경우에서 다른 패러다임을 이기는 것은 아니다.  
  - 다만 문제가 복잡해질수록 FRP의 복잡도는 다른 패러다임에 비해 선형적으로 증가한다.  
  - 애자일 방법론도 비슷한 주장을 하지만, FRP는 수학적인 원칙으로 이를 달성함.  
- 그렇다면 여기서 기능 추가나 변경이 들어가면?  
  - 상태 기계는 고려해야 할 것이 많다.  
  - 액터 모델은 상태 변수가 여러개가 되면 코드 중복이 일어나기 쉽다.  
  - FRP는 적은 변경으로 중복 없이도 기능 추가가 가능하다.  

- 결론  
  1. 전통적인 상태 기계 방식은 상태 갱신을 종종 잊어버리거나 잘못된 순서로 호출할 위험이 있다.  
  2. 액터 모델은 일부 문제에서는 FRP보다 쉽게 해결할 수 있지만, 둘 이상의 독립적인 상태 변수가 생기면 잘 처리하지 못한다.  
      - 문제가 깔끔한 선형제어인 경우에 적합하다.  
  3. FRP는 독립적이 상태 변수가 여럿 있는 경우를 상태 기계보다 덜 복잡한 방법으로 잘 처리한다.  

## Chapter11. 실전 프로그래밍  

1. I/O  
    - I/O를 나타내는 함수 타입 : Stream\<B\> myIO(Stream\<A\> sIn)  
      - 핵심은 내부에서는 I/O를 하지만 외부에서 볼 때는 FRP 코드처럼 보이게 하는 것  
    - FRP 코드는 예외를 다룰 수 없고 예외를 던지지도 않는다. 따라서 I/O에서 발생할 수 있는 예외상황에서도 반드시 값을 내보내야 한다.  
      - 오류를 모델링 하기 위해서는 옵션 타입이나 가변 타입을 사용해야 한다.  
      - 다만 옵션 타입은 오류 정보가 필요한 경우에는 적합하지 않다.  
      - Rx의 경우는 오류 처리 기능을 내장하고 있고, 연쇄적으로 전파하기까기 한다.  
    - I/O가 실행되면 반드시 두개의 트랜잭션이 연관이 된다.  
      - I/O를 시작하는 트랜잭션  
      - I/O의 결과를 받는 트랜잭션  
    - I/O는 비동기적으로 실행되기 때문에 I/O 액션을 여러 개 병렬로 실행하는 것도 가능하다.  
      - 병렬로 실행된 I/O의 반환 순서는 실행 순서와는 무관하다.  
2. Promise/future  
    - 현재 사용할 수 있거나 미래에 사용할 수 있는 값을 모델링  
    - 현재 사용할 수 없는 값이라면 그 값을 사용할 수 있는 상황이 되면 통지받을 수 있음  
    - Promise에 lift를 구현하여 함수를 Promise에 끌어올릴 수 있다.  
    - Promise의 사용 예제 : 지도 어플리케이션  
3. 분산 시스템  
    - **주의!:FRP는 기본적인 인프라이며, 그 자체가 해법을 일괄적으로 제공하지는 않는다.**  
    - 분산 시스템의 CAP 이론 - [참조](https://goo.gl/TvMc9c)  
        1. 일관성(Consistency)  
        2. 가용성(Availability)  
        3. 분할 내성(Partition Tolerence)  
        - 이 이론은 결국 네트워크로 분할된 분산 시스템은 가용성과 일관성 중 하나를 선택할 수 밖에 없다는 뜻이다.  
        - 보통은 가용성이 더 중요하기에, 일관성이 포기된다.  
    - FRP는 일관성을 잘 보장한다. 그러나 그것은 지역적인 것에 국한된다.  
    - FRP에서는 메시지의 도착시간을 보장하거나 메시지가 누락되지 않을 거란 보장을 할 수 없다.  
    - 이를 해결하기 위해서는 추가적인 로직이 들어가야 하며, FRP는 이런 로직을 다루기에 이상적이다.  
    - 다만 분산 시스템에서 FRP 수준의 일관성을 기대할 수는 없다.  
4. 단위 테스트  
    - FRP에는 암시적인 상태가 존재할 수 없기 때문에, 모든 코드는 자동적으로 테스트 가능해진다.  
    - 단위 테스트 적용 방법  
       1. 코드 작성 후 선택적으로 테스트 작성  
       2. TDD  
           1. 빨간불 - 테스트부터 작성. 기능이 없기 때문에 테스트는 무조건 실패  
           2. 녹색불 - 테스트를 통과하기 위해 필요한 최소한의 코드 작성  
           3. 리팩터링 - 코드 정리 및 반복적인 코드 추출, 테스트를 만족하기만 하면 그 코드는 제대로 된 것이므로, 리팩터링을 많이 해도 안전하다.  
    - FRP는 일반적으로 TDD를 권장하지 않는다.  
        1. FRP는 정적 타입을 기반으로 한 타입 주도 개발이기 때문에 굳이 많은 테스트 코드가 필요하지 않다. TDD는 명령형 언어에 더 적합하다.  
        2. FRP는 이미 리팩터링을 안전하게 할 수 있기 때문에, TDD의 주 목적인 안전한 리팩터링의 가치가 바랜다.  
        3. FRP는 강제로 코드 결합을 느슨하게 만드므로, 근본적으로 테스트 가능하다.  
        - 다만, 더 확실하게 코드를 보장해야 한다면 TDD를 할 수는 있을 것이다.  
        - 또 아무리 FRP라도 로직의 오류는 방지하지 못하기 때문에 그것을 위해서 단위 테스트를 작성할 필요는 있다.  

## Chapter12. 도우미와 패턴  

- FRP는 고도로 추상화 되었기 때문에, FRP로 만든 해법은 아주 일반적일 수 있다.  
- 일반화한 코드는 루프에서도 잘 작동하는 것이 중요하다.

1. 중복 값 제거 - 조용히 시키기  
    - 직전 값과 같은 값이 발생하지 못하게 막는 것  
    - 라이브러리 단에서부터 자동으로 제거할 수도 있지만  
        1. 모든 값에 동등성 개념이 존재하리란 보장이 불가  
        2. 필요하지 않은데 매번 검사를 하는 것은 비효율적  
    - 새 값이 마지막 값과 같은지 검사하고, 같으면 아무것도 안 내보낸다.  
2. 게임 일시정지
    - 게임 클럭을 Cell을 이용해 메인 클럭과 별도로 관리  
    - 게임 로직에는 메인 클럭을 넘기지 않음으로 게임에서 잘못된 클럭을 사용하는 것을 방지  
3. 정션 또는 클라이언트 레지스트리  
    - 동적으로 등록할 수 있는 리스트를 Cell이나 Stream의 형태로 구현
    - 내용을 나중에 추가할 수 있는 Cell이나 Stream을 만듦  
    - 클라이언트를 등록하는 행위가 상태를 변화시키기 때문에, 이는 함수형의 해결법이 아니다. 다만 확장성을 얻기 위해 의미적 깔끔함을 맞바꿨다.  
4. 변경할 수 있는 원격 값  
    - FRP의 장점은 이벤트 처리 로직을 함수형 코드를 사용해 다룰 수 있다는 것으로, 상태 기계 모델이나 액터 패턴에서는 불가능  
5. 영속성  
    1. 영속화하고 싶은 모든 상태를 포함하는 컨테이너 클래스를 작성하고, 그 클래스에 대한 영속화 함수를 작성  
    2. FRP로직 초기화 전에 디스크에서 시스템의 초기 상태를 읽어오고, FRP에 필요한 상태를 제공하기  
    3. 시스템의 전체 상태를 나타내는 Cell을 만들고 필요에 따라 갱신  
6. 고유 ID 생성하기  
    - 내부적으로는 명령형이고 상태가 있지만 외부적으로는 참조 투명한 객체를 만들기  
    - 외부에 드러나지 않는 상태를 유지하고, 외부에 공개되는 함수들에 대해서만은 참조 투명성을 유지하는 것이 핵심  
    - 이 경우, 해당 객체는 상태를 가지고 있기 때문에, 함부로 혼용하게 되면 오류의 원인이 되므로 주의해야 한다.  
7. FRP기반의 GUI 시스템  
    - 원래 GUI는 객체지향 프로그래밍의 영역이였고 정형화되어 있다. 하지만 이 경우에도 FRP는 탁월한 패러다임  
    - 기본 원리는 Input과 Output으로 이루어진다는 점에서 다른 FRP로직과 크게 다른 점은 없음.  
    - 실제 화면을 그리는 시스템은 FRP가 아니기 때문에 그릴 수 있는 형태로 변환해서 넘겨줄 필요가 있음(ex. 스윙 컴포넌트로의 변환)  

## Chapter13. 리팩터링  

- 지저분한 코드는 복잡한 코드이고, 복잡성은 복리로 높아진다. 따라서 적절한 때에 리팩터링을 통해 복잡성을 낮춰야 한다.  
- FRP의 합성성으로 인해 복잡성 자체가 감당 못하게 커지는 경우는 많지 않지만, 그래도 리팩터링은 중요하다.  
- 다행히 FRP의 리팩터링은 아주 쉬운 일이다.  

- 리팩터링은 필수적인 과정이다. 리팩터링을 미루면 미룰수록 마지막에 처리해야 할 일이 늘어나기만 할 뿐이다.  
- 전통적 방식에서는 코드의 기능을 수정하거나 버그를 고칠수록 점점 코드가 지저분해진다.  
- FRP는 다이어그램을 그대로 반영할 수 있기 때문에, 좀 더 쉽게 리팩터링 타이밍을 판단할 수 있고 수정도 쉽다.  
- FRP는 리팩터링으로 코드가 깨지는 것을 자동으로 막아주기 때문에, 단위 테스트의 중요성이 떨어진다. 물론 있어서 나쁠 건 없다.  

## Chapter14. 기존 프로젝트에 FRP추가하기  

- 소프트웨어가 해결해야 하는 문제는 점점 더 복잡해지고, 이 문제를 해결하기 위해 해결해야 할 중요한 키워드는 **병렬성**이다.  
- 기존의 방법론으로 이 병렬성을 해결하려면 코드가 지나치게 복잡해져서 관리가 불가능한 지경에 이른다.  
- 병렬성 해결을 위해 함수형 프로그래밍이 주목받고 있으며, FRP는 그 중 일부이다.  

- FRP가 도움이 될 만한 상황
    1. FRP와 비슷한 문제를 해결하는 코드가 깨지기 쉬운 부분을 가진다.  
    2. 여섯가지 재앙으로 묘사되는 종류의 버그가 시스템에 존재하고, 이걸 계속 해결하려 힘써왔다.  
    3. 코드의 일부가 다를 수 없는 수준으로 복잡해지거나, 다루기 어려운 방법으로 점차 바뀌고 있음을 볼 수 있다.  

- FRP를 부드럽게 기존 프로젝트에 적용하는 법  
    1. 불변 데이터 구조로 바꾸기  
        - 불변성 : FRP로직이나 코드 조각이 어떤 데이터에 대한 참조를 가지고 있고, 그 참조가 가리키는 값이 프로그램의 다른 부분에 의해 변경되는 일이 절대로 없음을 확신할 수 있는 경우.  
        - 모든 데이터를 불변 데이터 구조로 변경하는 것만으로도, 스레드 안전성과 합성성이 주는 이점을 누릴 수 있다.  
    2. 콜백을 대체하는 스트림  
        - 기존 콜백을 Cell또는 Stream으로 바꿔준다  
        - **주의점** : listener안에서는 send()로 값을 밀어넣을 수 없다.  
            - 왜?
                1. 메시지 전달의 의존관계를 명확히 하기 위해서  
                2. FRP코드를 명령형으로 쓰는 것을 방해하기 위해서  
            - 해결법  
                - 보수적: 다른 스레드로 보내버리기  
                - 급진적: send() 호출 가능성이 있는 부분을 모두 FRP스럽게 바꿔준다.  
        - 프로젝트에서 FRP를 위해서는  
            1. 상태를 유지하는데 드는 비용과 불변 데이터 구조로 바꾸는데 드는 비용을 비교해야 한다.  
            2. 외부 인터페이스를 유지하는데 드는 비용과 바꾸는 데 드는 비용을 비교해야한다.  
    3. 큰 트랜잭션 안에서 프로그램 초기화하기  
        - 프로그램을 시작할 때 호출하는 여러 모듈들을 초기화하는 코드가 순서에 의존적이기 때문에 프로그램이 복잡하고 깨지기 쉬워짐  
        - 큰 트랜잭션을 만들고 그 안에서 FRP의 loop기능을 이용해 순서의존성과 순환 참조 문제를 해결할 수 있다.  
        - 여러 변수들을 초기화 할 때 더 명시적으로 하기 위해 클래스로 래핑하는 것도 좋다.  
    4. 정션(클라이언트 레지스트리)사용으로 확장성 모듈 만들기  
        - 단순히 merge로만 처리하면, 중간에 빼먹기도 쉽고, 확장성도 떨어진다.  
        - 앞에서 본 정션을 이용하면 기존 프로그램에 FRP를 확장성있게 적용할 수 있다.  
    5. 변경 가능한 변수를 Cell로 대치  
        - 변수를 sink와 cell을 이용해 읽기/쓰기만 해도 스레드 안전성을 얻고, 이 값의 변경을 listen할 수 있게 되며, FRP코드와 호환도 된다.  
        - 다만, 불변 데이터 타입의 값만을 셀에 저장해야 한다는 규칙이 하나 생긴다  

## Chapter15. 앞으로의 방향  

- FRP는 그 가능성에 비해 아직도 초기단계에 머무르고 있다.  

1. 성능  
    - FRP는 데이터 의존관계와 사용 패턴을 실행 시점에 측정할 수 있기 때문에, JIT 컴파일, 라이브 최적화 등의 여지가 많다.  
    - 전통적인 아키텍쳐가 아닌 FRP 최적화된 기계가 있다면 더 좋은 성능을 얻을 수 있을 것이다.  
2. 사전 컴파일  
    - 자원이 한정된 환경에서 적용하기 위해 다른 언어로 컴파일 할 수 있다면 좋을 것이다. (ex. C 프로그램,FPGA용 프로그램,임베디드 프로그래밍)  
    - 가장 문제가 되는 것은 switch를 구현하는 것  
    - 제어용 어플리케이션은 FRP가 잘 들어 맞는 분야이므로, Switch만 구현할 수 있다면 그 유용성은 굉장히 높다.  
3. 병렬성  
    - FRP 코드를 자동으로 다중 코어 시스템에서 실행하도록 병렬화 할 수도 있을 것이다. 다만 자동화는 보기보다 어려운 일이니 이 말은 신중해야 한다.  
    - 병렬화를 얻기위한 가장 간단한 방법은 Cell을 Software Transaction Memory(STM)로 구현하는 것  
        - 다만 이러한 개념은 함수형 언어에서만 제대로 작동한다. FRP는 비슷한 정도의 제약을 두기 때문에 가능하다.  
        - 이를 위해서는 어떤 언어로 만들어졌든, FRP 엔진에서는 STM이 잘 작동해야한다.  
    - JIT 컴파일러의 기법을 이용해 지능적인 스케쥴링으로 병렬성을 더 복잡하게 구현할 수도 있을 것이다.  
    - GPU에서의 FRP는 그리 타당하지 않다. GPU는 데이터 병렬성이라는 다른 종류의 병렬성에 더 적합하기 때문이다.  
4. 문법 개선  
    - FRP문법은 대부분의 언어에서 거칠게 표현되지만, 전처리를 통해 개선될 수 있다.  
        1. 자동 끌어올리기  
        2. 암시적 전방참조  
        3. 중위 연산자 - 대신 이러한 코드는 FRP 초심자들이 어려움을 겪게 될 것  
        4. 타입 추론  
5. 표준화와 코드 재사용  
    - 다양한 완성도를 가진 다양한 시스템의 공존은 그리 도움이 되지 않는다. 즉, 표준이 필요하다.  
    - 이 표준은 반드시 **표시적 의미론**을 기반으로 해야한다.  
    - 표준화되지 않은 코드는 코드의 재사용 가능성을 저해한다.  
    - 표준화를 해야 FRP 엔진 성능 개선에 들어가는 노력이 효율적일 수 있고, 지원도 잘 할 수 있다.  
    - 프로그래밍 언어간의 파편화 역시 FRP 확산을 막는 걸림돌이다.  
6. FRP 데이터베이스 애플리케이션  
    - 각 Cell이 자동으로 DB키와 연동되고 값을 자동으로 영속화 시키는 것을 기대할만하다.  
7. 시각화와 디버깅 도구  
    - 시간에 따른 FRP 상태 변화를 그래픽화 시킴  
    - 시각화 도구와 디버깅 도구를 사용하면 FRP 엔진 구현을 한단계씩 돌리지 않아도 디버깅 가능, 심지어 앞뒤로 돌려가며 가능할 것(리플레이 디버깅)  
8. 시각적 프로그래밍  
9. 리팩터링 도구  

## Appendix. 관리자를 위한 조언  

1. 하겠다고 한 일을 하라
    - 결국 프로젝트의 성패는 코드 품질에 달려있다.  
    - FRP는 기존의 IT 업계에 만연한 문제 중 몇가지(6가지 재앙)를 예방할 수 있다.  
2. 투자 대상은?  
    - 사람 : 리드 프로그래머, 또는 다른 방식으로 일처리할 동기부여가 되어 있는 사람  
    - 도구 : 사용하는 언어의 FRP 시스템, 없으면 포팅해야 함  
    - 기존 코드가 FRP대로 잘 돌아가기 위해 신경써야 할 비용, 이는 새로운 기능에서의 버그 수 감소로 상쇄될 수 있다.  
3. FRP 경험자를 고용하려고 하면 함수형 프로그래밍 관심자들이 줄을 설 것이다. 신입을 고용해서 3~6개월 교육하는 것도 도움이 된다.
4. FRP는 이미 넷플릭스에서 사용되고 있다.(RxJava),새로운 투자에 대한 불안함이 있다면, 작게 시작해보고 이후에 더 키워나가자  
5. FRP가 성공적으로 안착한다면 기존의 시스템에서의 테스터의 비중은 줄어든다. 대신 다양한 분야의 기술을 갖춘 사람들을 골고루 채용할 수 있게 되기 때문에 팀의 포트폴리오를 늘려야 할 필요가 있다.

---

참조 논문 : Push-pull functional reactive programming - Conal Elliott

---