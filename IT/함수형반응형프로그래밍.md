
# 함수형 반응형 프로그래밍(Functional Reactive Programming)  

저자 : 스티븐 블랙히스, 앤서니 존스  
역자 : 오현석  
출판사 : 매닝출판사, 한빛미디어  
출판년월 : 2017/8  
페이지 : 492  

---

## __Chapter 1. 듣기를 멈추자!__  

---  

- FRP? 표준 프로그래밍 언어에서 간단한 라이브러리 형태로 적용되며, 관찰자 패턴에서 사용되는 리스너(listener, 혹은 callback)을 대신함.->관찰자 패턴 자체를 대치  
- 프로젝트의 복잡도가 너무 높아질 때의 근본적 해결법 = __리팩토링__ , FRP는 제어할 수 없는 복잡도를 예방하거나 고칠 때 도움이 되기 때문에 리팩토링과 잘 어우러진다.  
- 표시적(denotative)이고 시간 연속적(temporally continuous)  
- 표시적이란? 정확,간결,구현독립적,합성가능한 semantic으로 프로그램이 이루어져야 한다.
- FRP - 함수형 프로그래밍과 반응형 프로그래밍의 교집합
  - 함수형
        1. 수학적 의미의 함수에 기반함  
        2. 공유된 변경 가능상태를 의도적으로 피함 -> 불변 데이터 구조 사용  
        3. 합성성 강조 -> FRP의 복잡도를 효율적으로 처리할 수 있는 원동력  
    - 반응형  
        1. 프로그램을 제어의 흐름으로써가 아니라 이벤트 기반, 입력에 반응하는 데이터 흐름으로 이해하는 광범위한 용어  
        2. 프로그램 구성요소 간의 느슨한 결합을 허용하여 코드가 더 모듈화 된다.  
    - 함수형 반응형 프로그래밍 : 반응형 프로그래밍을 달성하기 위해 함수형 프로그래밍의 규칙을 따르도록 강제하는 구체적인 방법. 합성성 강조  

- 반응형 프로그래밍으로 설명되는 시스템은 분산처리를 강조하지만 FRP는 더 세밀한 단위를 사용해 일관성을 강조. 분산 시스템에서 규모 확장성을 위해서는 일관성이 완화되어야만 하기 때문에 FRP는 분산 시스템을 위한 것이 아니다. ex) Akka는 반응형 프로그래밍으로 분류되는데, 분산 시스템을 위한 것으로 FRP가 아닌 actor모델을 사용한다.  

- Rx는 아카와 FRP 중간 어느 지점에 위치. Rx는 이벤트 핸들러를 사슬처럼 엮는데 관심이 있다. FRP는 작업 방식을 더 엄격히 제한하며, 더 많은 것을 보장한다.  

- 두 가지 프로그래밍 모델  
    1. 스레드 : 상태 변화를 제어 흐름으로 모델링 -> FSM,I/O에 잘 어울림  
    2. 이벤트 : 이산적이고 비동기적으로 전파되는 메시지 -> GUI,비디오게임  

- 모든 프로그램은 상태 기계, 상태 기계는 분석이 어렵고, 그래서 프로그래밍이 어렵다. 프로그래머는 이 어려운 프로그래밍을 구조화해서 분석하고 관리하기 쉽게 만드는 것, 즉 추상화 능력이다.  
- 이벤트 기반 프로그램에도 다양한 버그가 있다. 하지만 __이 중 대다수는 예방할 수 있다.__  
- 기존 코드 : 생산자가 소비자에 의존, 관찰자 패턴 : 소비자가 생산자에 의존  
  - 장점 : 프로그램의 확장이 쉽고, 구성요소 간의 연결이 느슨해짐  
- 리스너 버그의 근원  
    1. 예측 불가능한 순서  
    2. 첫 번째 이벤트 소실  
    3. 지저분한 상태  
    4. 스레드 문제  
    5. 콜백 누수  
    6. 의도치 않은 재귀  
  - 이것들을 고치기 위해 관찰자 패턴을 연구하다 보면 자연스레 FRP에 도달하게 될 것이다.  
- FRP로 재시작이 필요없는 프로그램을 만들 수 있다. 일반적인 변경 가능한 변수 대신 변경 통지와 실행순서 관리를 자동으로 해주는 컨테이너에 상태를 저장한다. (여기서는 Cell)  
- 복잡도를 다루는 핵심 - __합성성__  
- FRP의 작동방식 : 데이터 입력 - 비즈니스 로직으로 데이터 검증 - 상태 변화  
- FRP의 두가지 기본적 데이터 타입  
    1. 셀 : 시간에 따라 변화하는 값을 표현 -> 변수의 추상화된 형태  
    2. 스트림 : 이벤트의 흐름  
- FRP의 구조  
    1. FRP 로 작성된 문장들을 해석하여 방향성 그래프로 초기화  
    2. 방향성 그래프를 FRP엔진에 보내 입력이 들어왔을 때 방향성 그래프가 지정하는 의존성 관계대로 처리하게 만듬(스프레드시트와 같은 방식으로 작동한다!) -> GUI 라이브러리의 동작 방식과 유사  
- FRP의 패러다임  
  - 패러다임은 참이라고 여기는 몇가지 가정을 근거로 하며 이는 사람마다 다르다. 이 가정이 상당히 다를 경우 서로 통약불가능(incommensurable)하다고 한다.  
  - 패러다임은 천천히, 또는 어떤 깨달음에 의해 한순간에 바뀐다. FRP는 간단한 아이디어지만, 그것을 이해하기까지의 과정은 도전이다.  
- 스레드는 시퀀스 표현에, 이벤트는 의존성 표현에 사용된다. 의존성을 스레드로 표현하거나 이벤트를 시퀀스로 표현하려면 쉽게 복잡해진다. FRP는 시퀀스 중심의 프로그래밍을 문제 설명에 더 가까운 방식으로 바꾼다.  

- 선언적 프로그래밍 : 어떻게(How)보다 무엇(What)을 하는 프로그램인지를 서술하는 방식의 프로그래밍 - operation 보다는 concept, 훨씬 이해가 쉽다.  

- FRP의 기반 철학 : 프로그램은 입력을 출력으로 변환하는 것  

- 대부분의 프로그래머는 조작적인 사고에 익숙하지만 FRP에서는 오히려 지양해야할 것이다. FRP는 내부적으로 이것들을 가린다. 내부 작동은 성능에만 영향을 줄 뿐이다. -> 내부 구현보다 개념에 더 집중하라.  

- FRP에서 함수형 프로그래밍은 로직을 기술하는 언어의 문장을 조작하는 메타언어의 성격을 가진다. -> 규칙을 서술하고, 이 규칙을 합성하여 새로운 규칙을 만든다.  

## Chapter 2. FRP의 핵심  

---  

1. 타입 : Stream, Cell  
2. 기본 연산 : map, merge, hold, snapshot, filter, lift, never, constant  
3. StreamLoop와 CellLoop를 전방 참조  
4. hold와 snapshot을 사용한 누적기  

- Cell : 시간에 따라 변할 수 있는 값  
- Stream : 이벤트의 흐름, (유의어 : 이벤트[이 경우, 이벤트안에 이벤트 발생이 들어있다라고 표현], 이벤트 스트림, 관찰자, 시그널), 이벤트가 스트림을 통해 전달되는 경우, 스트림을 '발사한다(fire)' 혹은 내보낸다 표현  
  - stream은 자신을 통해 전달될 수 있는 값의 타입을 가짐.  
- Unit : '아무것도 아닌 값'을 나타내는 타입. 인자의 개수를 동일하게 맞추기 위해 사용. -> OOP방식이면 아무것도 안 받는 핸들러를 하나 더 만들것.  
- Payload : 발생한 이벤트(혹은 메시지)에 들어있는 값.  
- Cell(유의어 : behavior, property, siganl)  
  - Cell이 함수형에서 기피하는 지역적이지 않은 변경 가능한 변수인 것은 아닌가?  
        - 맞다. 다만 이벤트 처리는 태생적으로 상태를 동반하고, 이를 바꿀 수 있는 것은 없다.  
        - 그래서 이를 FRP에서 사용하기 위해서는 이를 FRP의 방법으로 다루기 위해 Cell과 Stream을 사용한다.  
        - Cell의 내부 값은 변경이 가능하지만, Stream이나 Cell 자체는 불변 값이기 때문에 참조 투명성이 있는 함수 내부에서도 사용 가능하다.  
        - 이는 합성성을 해치지 않게 만들어 준다.  
        - 다만 이는 FRP 기본 연산에 넘기는 함수가 참조 투명성을 만족해야만 유효하다.  
- FRP에서의 연산 : 스트림이나 셀을 다른 스트림이나 셀로 변환하는 함수나 코드  
  - 기본 연산(primitive) : 다른 연산자를 조합하여 표현할 수 없는 연산. FRP에서 모든 연산의 근본 재료가 됨  
- I/O와 로직은 분리되어야 한다. 보통 I/O는 시퀀스 방식으로 이루어지기 때문에, I/O 부분을 분리한 후, FRP 시스템에 연결하는 방식을 권장한다. -> 방법은 추후 설명  
- FRP가 제대로 작동하기 위한 조건 : __참조 투명성__ , 혹은 순수(pure)  
    1. I/O수행 금지  
    2. 함수 내부에서 발생한 예외는 내부에서 처리해야 한다.  
    3. 변경 가능한 외부 변수를 함수 내부로 끌어오면 안된다. 단, 상수는 가능하며 오히려 권장된다.  
    4. 외부에서 보이는 변수의 상태 변경이 금지된다.  
    5. 함수 호출과 호출 사이에 지속되는 상태를 유지해서는 안된다.  
  - 요약: side-effect가 없어야 하고, 인자 값 이외의 외부 상태에 반환값이 영향을 받아도 안된다.  
  - 예외 : 진단 메시지를 찍을 때 -> 프로그램에 논리적 영향을 끼치지는 않으나, 실행순서가 예상과 달라질 수는 있다.  
- Stream과 Cell을 어떻게 구분하여 쓸 것인가?  
  - 사용자나 프로그램이 모두 이벤트를 발생시키는 경우는 Stream  
  - 프로그램만이 이벤트를 발생시키며, 시간에 따라 변화하는 값을 표현할때는 Cell  
- Cell은 변수일 수도 있지만 상수일 수도 있음.  
- 기본 연산 설명  
  1. map : 한 스트림을 같은 타입이나 다른 타입의 새로운 스트림으로 변환  
      - 원래의 스트림과 변환된 스트림은 개념적으로는 동시에 발사됨.  
        - 물론 실제로는 그렇지 않지만, Transactional context를 이용해 그렇게 보이게 만듬  

  2. merge : 두 개의 Stream을 합친 Stream을 반환. 이렇게 해서 하나의 Stream을 받는 곳에서 두 개의 Stream의 값 변화를 모두 감지 가능  
      - 동시에 발생할 경우의 정책  
        - 두개의 이벤트를 하나로 합쳐서 발사, 이 경우 합치는 함수를 제공해야 함  
        - 두 이벤트 중 하나를 버림. 이 때 우선순위가 낮은 이벤트가 버려짐  
        - 두 개의 이벤트를 합치지 않고 한 스트림에서 두 개 이상의 이벤트를 발사하기도 함.  
          - 단순화를 위해서는 권장하지 않음  

      - 일부 유사 FRP 시스템에는 이러한 동시 이벤트라는 개념 자체가 없기도 한데,  이는 합성성을 깨는 원인이 된다.  
      - merge의 동작방식  

        1. 개념적으로는 이벤트의 순서를 감지할수 없지만, 조작적으로 보면 이벤트는 바람직한 순서의 반대로 일어남.  
        2. 더 이상의 입력이 들어오지 않는다는 확신이 들 때까지 임시 저장고에 이벤트를 보관  
        3. 더 이상 입력이 없으면 이벤트를 출력. 이 때 동시에 두 이벤트르 받았다면 제공받은 함수를 사용해 두 이벤트를 합친다.  

  3. hold : Stream의 결과를 Cell에 저장함. 즉 Stream을 Cell로 바꿔줌.  
      - Cell의 값은 Stream에서 가장 최근에 받은 값  
      - Cell은 항상 값을 가지고 아무때나 값을 추출할 수 있어야 한다. 따라서 hold를 사용할 때는 최초로 이벤트가 도착할 때까지 Cell에 담아둘 기본값을 지정해야 한다.  
      - Stream은 이벤트를 발사하는 순간만 값을 가진다.  

  4. snapshot : Stream이벤트가 발생된 시점의 Cell 값을 캡쳐함.이후 제공받은 함수를 통해  스트림 이벤트의 값과 셀 값을 합친다. (유의어 : withLatest, attach, tag)  
      - 작동 방식  
        1. Stream 이벤트가 발생하면 지정된 Cell의 값을 캡쳐해옴.  
        2. 캡쳐해온 값에 f를 적용하여 새로운 이벤트를 만듬. f가 없는 버전에서는 그냥 Cell의 값만 캡쳐해 옴  
        3. 해당 이벤트를 스트림을 통해 내보냄  
      - 전방 참조(Forward reference) 문제 : 정의하기 전에 식별자를 사용하게 되는 문제.  
        - 값 루프(Value Loop) :  함수형 프로그래밍에서 어떤 값이 자기 자신을 사용해 직접 정의되거나 다른 변수를 통해 간접적으로 정의되는 것  
          - 값 루프는 조작형 언어에서는 사용할 수 없다.  
          - 이를 해결하기 위해서 CellLoop라는 것을 추가, 값을 대입하기 전에 미리 해당 변수를 참조할 수 있게 만든다.  
            - 이와 비슷하게 StreamLoop도 있다.  
      - FRP 코드 안에는 시퀀스라는 것이 존재하지 않는다. 임의대로 각 줄을 뒤섞고 필요에 따라 CellLoops나 StreamLoops를 삽입해도 코드는 동일하게 동작한다.  
        - 다만 현실의 제약이 있어서 Loop의 선언과 그 안에 값을 삽입하는 것은 반드시 같은 트랜잭션에서 실행되어야 한다.  
      - snapshot이 보는 값은 과거의 값인가 변경된 값인가?  
        - 어떤 이벤트가 촉발하는 변화는 원자적이기 때문에, 두 가지 상태가 동시에 존재할 수는 없다.  
        - 이에 대한 접근 방법  
          1. 무조건 예전의 값을 본다. 트랜잭션이 끝나야지만이 값이 갱신된다. -> 이 책에서 사용하는 방법  
          2. 무조건 새로운 값을 본다. 이 경우 루프 안에 있으면 결과를 예측할 수 없다.  
          3. 새로운 값을 보지만, delay라는 연산을 통해 명시적으로 이전 값을 볼 수 있다.  
          4. 루프를 허용하지 않으며, 고수준의 accum 스타일로만 사용해야 한다.  

  5. filter : Stream 값이 정해진 경우만 흘러가게 만든다.  
      - filter에 사용되는 함수 역시 참조 투명성을 만족해야 한다.  

  6. lift : 두 개 이상의 Cell을 하나로 조합하는 것. map과 유사하지만 map은 단일 Cell에 작용한다는 점이 다름  
      - 함수형 프로그래밍에서 lift는 값에 대한 함수를 그 타입이 들어있는 컨테이너에 대한 함수로 만들어 주는 것이다. (A->B => C< A > -> C< B >)  
      - FRP에서 lift라 하는 이유는 값에 작용하는 함수를 Cell에 작용하는 함수로 끌어올려 주기 때문이다.  
      - lift의 출력 Cell은 입력 중 하나가 변경되면 자동으로 갱신된다.  
      - map과 lift는 종종 같은 의미로 혼용된다.  
        - 이 책에서는 단일 Stream이나 Cell에 대해서는 map, 둘 이상의 Cell에 대해서는 lift 사용.  

  7. never : 이벤트를 절대 발사하지 않는 스트림을 만든다.  
      - FRP의 상태변화는 모두 외부 I/O로 부터 시작된 이벤트로 인해 일어난다.  
          - 따라서 never 스트림과 결합된 요소는 앞으로도 상태 변화에 아무런 영향을 주지 못한다.  

  8. constant : 특정 Cell의 값을 고정시킴  
      - 엄밀히 말하면 never와 hold의 조합으로 표현할 수 있으므로 기본 연산이 아니다.  

  - 그 외 기본 연산 : sample, switch  

## Chapter3. 간단한 위젯 만들기  

---  
2장에서 배운 내용에 대한 실습. 실습 코드는 [Swidget](https://github.com/SodiumFRP/sodium/tree/master/book/swidgets) 참조  

## Chapter4. 실제 애플리케이션 작성하기  

---  

- 전체 소스 코드 : [주유 펌프](https://github.com/SodiumFRP/sodium/tree/master/book/petrol-pump)  

- 관찰  
  - 기본  
    1. Input 과 Output으로 캡슐화된 인터페이스. 각각 Cell 또는 Stream 이다.  
        - Input은 외부세계 또는 Output으로부터 입력을 받는다.  
        - Output은 결과를 Input또는 외부 세계로 흘려보낸다.  

    2. 모든 Input과 Output은 불변성을 유지하기 위해 상수로 선언.  
        - 컨테이너만 상수니까 내용은 바꿀 수 있음.  
        - 이는 FRP에서 가장 중요한 **합성성**을 유지하기 위함.  

    3. set 메서드의 선언  
        - 해당 부분만 바뀐 전체 객체를 새로 만들어 반환  
        - 이 역시 불변성을 유지하기 위해서이다.  
        - 보기에는 비효율적일 수도 있지만, 생각보다 비효율적이진 않다.  
        - 오히려 지나치게 성능만 고려하면 좋지 못한 결과가 나오기도 한다.  
        - 성능에 대한 결정은 항상 프로파일링 결과를 바탕으로 이루어져야 한다.  
  - 구현  
    1. 주유 로직(Life Cycle)  
        - 입력 : 노즐 3개  
        - 출력 : sStart, sEnd, fillActive.  
            - sStart와 sEnd는 fillActive에 의존하고, fillActive는 다시 sStart와 sEnd에 의존한다.  
            - 이럴 때 Loop를 사용한다.  
        - 코드가 오히려 더 장황해지는 것은 아닌가?  
            1. FRP는 프로그램이 클 수록 그 위력을 발휘함  
            2. 일반적인 프로그래밍 언어로 직접 표현하면 투박해짐  
                - 전처리기 등으로 하면 더 개선될 여지가 많음.  
                - 다만 아직 전처리기 개발이 잘 이루어지지는 않았다.  
    2. 연료량 계산(accumulate)
        - 입력 : sClearAccumulator, sDelta, Callibration  
        - 출력 : litersDelivered  
        - 매 펄스를 누적시키는 Cell, 펄스에 매 펄스당 나오는 연료량을 나타내는 Calibration 값을 곱해 반환  
        - 별도 클래스로 구현하지는 않고, Pump 클래스에서 정적 메서드로 구현  
    3. 연료의 가격 표시
        1. 주유시점의 가격 고정(capturePrice)  
            - 입력 : price1, price2, price3, sStart  
            - 출력 : price  
            - Fill class의 정적 메서드로 구현  
        2. 주유량과 가격 표시(Fill)  
            - accumulate 메서드와 capturePrice의 조합  
            - 출력 : litersDelivered, dollarsDelivered  
            - 자바 기준으로, 출력이 하나면 정적 메서드가 쉽고 두 개 이상이면 클래스가 더 쉽다.  
    4. POS 시스템과의 통신, 그 이후 초기화  
        1. 통신은 주유와 별개의 영역이므로 다른 클래스로 구현한다.  
        2. 통신은 오래 걸리기 때문에 중간에 일어나서는 안되는 이벤트가 일어날 수도 있다. 그것을 막기 위해 gate 연산을 적용한다.  
            - gate연산 : 인자로 지정한 Cell의 값이 참인 경우에만 이벤트가 흘러가게 허용한다.  
                - snapshot과 filter의 조합이기 때문에 기본연산은 아니다.  
    5. 키패드 모듈을 구현한다.  
        - 컴파일러 기능을 최대한 활용하여 버그를 방지하자  
            - 이 경우에서는 if-else 대신 ?:(삼항 연산자)를 이용한 것  
        > ### 모듈성에 대한 노트
        > - 모듈의 형태  
        >   1. 모든 필드를 public한 상수형태로 정의한다.  
        >       - 필드의 유일한 목적은 Stream이나 Cell을 사용 가능하게 하는 것 뿐  
        >       - private한 필드를 원한다면 생성자 안에서 지역변수를 사용하라  
        >       - 객체의 내부 상태 변경은 문제를 야기할 뿐이다. 따라서 모두 상수로 선언한다.  
        >   2. 클래스의 유일한 메서드는 생성자뿐이다.  
        >      - 상수를 초기화 할 수 있는 기회는 생성자 뿐이다.  
        >   3. 당연히 이것은 OOP가 아니다.  
        >       - OOP의 목적은 객체의 상태 관리  
        >       - FRP에서는 이를 Stream과 Cell을 이용해 다룬다.  
        >   4. 출력이 하나뿐인 모듈이 필요하면 정적 메서드를 쓰라.  
        >       - 모든 것이 불변이기 때문에 public으로 해도 문제가 없다.  
        >       - 지역적으로만 사용해도 된다면 private도 무방하다.  
        > - 여러 값을 반환하는 방식이 튜플인지 클래스인지는 해당 언어에서 널리 쓰이는 방식을 적용하면 된다.  
        >   - 자바에서는 튜플보다 클래스  
        > - FRP의 특징은 모듈의 입력과 출력이 명시적이라는 것  
        >   - FRP 모듈은 상태로만 이루어진 로직이고, 호출하는 쪽에서 그 모듈을 잘 연결해서 일하도록 만들어야 한다.  
        >   - 이러한 방식은 우리가 작성한 코드가 올바르다는 것을 컴파일러가 증명할 수 있게 만드는 것.  
        > - FRP 모듈의 입력과 출력이 너무 많이지는 경우가 종종 있다.  
        >   - 대부분의 프로그래밍 상황에서는 코드 냄새이지만, FRP에서는 정도가 약간 덜하다.  
        >   - FRP에서는 프로그램이 서로 통신하는 부분을 감출 방법이 없어서 더 많은 입출력을 명시적으로 써야하다보니, 이전보다 입출력이 많이 보일 수는 있다.  
        >   - 그럼에도 너무 많다면, 컨테이너 클래스를 만들어 그 안에 감추는 방법을 쓰면 된다. 이는 매우 강력하다.  
        > - FRP는 버그의 대부분을 미연에 방지한다. 하지만 버그의 가능성은 여전히 남아있다.  
        >   1. 정해진 입력과 출력을 사용하는 것을 잊어버릴 수도 있다.  
        >      - 선언해놓고 사용하지 않는 값이 있다면 그것은 거의 확실히 버그다.(물론 의도적으로 무시하는 경우는 예외다)  
        >      - 컴파일러의 경고를 주의깊게 보라  
        >   2. 입력값을 공급하는 것을 잊을 수 있다.  
        >      - 다만 대부분 컴파일러가 경고를 할 것이다  
        >      - 제공할 게 없으면 never Stream이라도 제공해야 한다  
        >   3. 타입이 동알한 값을 실수로 혼용하는 경우가 있다.  
        >      - 혼동할 수 있는 타입을 단독으로 담는 컨테이너로 감싸도록 하라.  
        >      - 이렇게 하면 값의 의미를 타입명에 반영할 수 있어서 의미가 더 명확해진다.  
        >      - 이러한 패턴은 함수형 프로그래밍에서 흔하게 일어나는데, 이것을 하스켈에서의 키워드인 newtype을 따와서 뉴타입 패턴이라 하자.  
    6. 현재 주유 금액 추가하기  
        - 입력 : 미리 지정한 금액, 연료 가격, 주유한 연료의 양(리터), 주유중인 연료, 주유 활성화  
        - 출력 : 주유, 키패드 활성화  
        - 로직  
            - 0은 미리 지정한 최대 주유금액이 없다는 뜻  
            - 미리 지정한 금액 바로 직전에만 주유 속도를 늦춰서 천천히 주유한다.  
            - 미리 지정한 금액에 도달하면 주유를 멈춘다.  
            - 주유 속도가 느려지기 전까지 주유금액 변경 가능, 느려지면 입력 금지  
        - 입력, 출력, 로직을 정하면, 그것을 FRP 방식으로 표현하면 프로그램이 완성된다.  
- 결론  
  - 코드의 절반은 주고받을 값을 정하기 위한 오버헤드  
  - 나머지 대부분은 상태가 있는 로직이다.  
  - 이렇게 값을 전달하는 이유는 변수의 영역을 제한해서 코드를 깔끔하게 유지하는 것이다.  
  - FRP 코드에 없는 것  
    - 명시적인 순서가 없다. 이해를 돕기 위해 순차적으로 보이게 썼을 뿐이다.  
    - 상태 갱신에 가장자리 조건에 들이는 실질적 관심이 없다. 대부분은 그냥 사라져 버린다.(다는 아니다)  
    - 일반적인 변경 가능한 변수에 상태를 저장하지 않고 Cell을 사용한다.  
    - 스레드 등 제어 흐름 비슷한 것은 사용하지 않는다.  
    - 상태 변경을 코드에서 직접적으로 시작하지 않는다. Cell이나 Stream은 언제나 정보의 소스다.  
      - 정보가 도달해야 하는 Sink의 개념이 FRP에는 없다.  
      - 상태를 변경하는 유일한 방법은 Stream의 이벤트이며, 직접 만들 수 있는 Stream은 never 뿐이다.  
      - 따라서 상태를 변경하는 요인들은 FRP 시스템 외부에서 밖에 없다. 그래서 이런 방식을 반응형(Reactive)라 한다.  

## Chapter5. 새로운 개념  

---  

### 왜 프로그래밍이 점점 복잡해지는가  

- 원하는 성능을 위해서 하드웨어 아키텍처는 점점 복잡해져 왔으며, 이에 맞춰 소프트웨어 아키텍쳐도 더 복잡해졌다.  
- 우리가 써온 대부분의 프로그래밍 언어들은 폰 노이만 기계에서 동작하기 위해 설계되었으나, 실제로는 그렇지 않다. 또한 폰 노이만 구조는 병렬성을 달성하기 어렵다.
- 다양한 아키텍쳐가 존재하고 미래에도 새로운 아키텍쳐가 나올 수 있는데, 지금까지의 프로그래밍 언어는 폰 노이만 구조 하나에만 최적화되어 있다.  
- 근본 원인 : 문제 자체가 아닌, 특정 기계에만 잘 들어맞는 프로그램을 작성하고 있기 때문!  

### FRP는 이 문제를 어떻게 다루는가  

- 특정 아키텍쳐에 의존적이지 않고, 문제 그 자체에 집중한 프로그램을 작성하고, 그 정보를 컴파일러(FRP 시스템)에 넘겨 대상 기계에 최적화인 코드를 만들어 내는 것!  
- 프로그래밍이 병렬성을 얻게 되면 훨씬 적은 전력으로 동일한 스루풋을 달성할 수 있다.  
  - 이 병렬성이야 말로 기계가 아닌 문제에 촛점을 맞춘 프로그래밍 기법을 채택하도록 이끌어 갈 것이다.  
    - 다만 현재의 구현은 병렬성을 많이 살리지는 못한다. 그렇지만 근본적으로 FRP는 전통적인 방법과는 다른 방식으로 병렬성을 달성할 수 있다.  

### - FRP가 복잡성 문제를 해결하는 법 : **합성성**  

- 프로그램의 복잡도는 지수적으로 증가한다.  
  - 기존에는 리팩토링을 해서 균형을 잡아주었다.  
- FRP에서는 복잡도가 선형적으로 증가한다.  
  - FRP의 합성성은 수학적으로 증명될 수 있기 때문에 어떤 FRP 코드라도 합성성이 보장된다.  

- 엔지니어링은 기본적으로 환원주의(reduction)을 기반으로 한다.  
  - 이는 문제를 작은 부분으로 나눠 해결한 뒤 합치는 방법이다.  
  - 각각의 작은 문제들의 합성성이 보장되지 않으면 환원주의는 실패한다.  
- FRP는 합성성을 강제함으로 환원주의가 성립할 수 있도록 하고, 그런 식으로 작업하도록 강제한다.  
- 프로그래머들이 당면한 문제는 점점 더 병렬적이고 분산적이며 더 복잡해지고 있다. 이러한 문제를 해결하는데 필요한 것은 합성성이다.  
- FRP는 합성성을 위해 많은 부분을 강제한다. 하지만 이러한 것에서 오는 어려움을 이겨내면 많은 버그를 해결할 수 있다.  
- FRP 시스템에서는 Cell이나 Stream에 있는 값이 코드의 여러 군데에서 참조되므로 처리과정에서 변하지 않는 것이 중요하다. 즉, 불변성이다.  
- FRP에서는 의존관계가 명확하기 때문에 리팩토링도 쉽고, 그로 인해 적절한 추상화를 기존보다 쉽게 이뤄낼 수 있다. 이는 곧 프로그램의 의도를 명확히 하게 된다.  
  - '누군가 버그를 보고하면 프로그램을 돌려보지 않아도 버그를 찾을 수 있을 정도가 되어야 한다.'  
- 추상화는 이해에 더 시간이 들어가기 때문에 분명히 비용이다. 하지만 FRP는 추상화에 의한 비용보다 유용성이 높은 경우가 많이 있다.  

## Chapter6. 웹에서의 FRP  

---  

- FRP가 특히 잘 어울리는 영역  
  1. 이벤트 기반 UI  
  2. 네트워크  
  -> 웹 애플리케이션에 적용하기 적절하다.  

- RxJS- FRP 기능을 가지는 시스템. 웹 어플리케이션에서 널리쓰임  

- Rx vs Sodium  
  - Sodium :  '진정한 FRP'라는 핵심 개념을 실용적이고 최소한으로 구현하는 것을 목표로 함.  
    - 버그 발생을 최소화하기 위해 제약을 많이 가함  
  - Rx : 실제 세계의 문제를 푸는 것을 돕기 위해 설계.  
    - 종종 FRP가 아닌 코드들을 함께 조합해서 사용  
    - 이는 FRP 기본 요소들을 직접 만들어 내는 것에 해당하며, 합성성을 유지하기 어렵게 만든다.  
- Rx에는 '표시적 의미론'이 부족하다. 즉, 각 부분들 중 합성성이 부족한 분야가 았다는 것으로, Rx를 '진정한 FRP'로 인정받지 못하게 한다.  

### Rx의 특징들  

1. Observable : Sodium의 Stream에 대응하는 것.  
    - Stream은 한 가지 이벤트 타입만 지원하지만, Observable은 onNext, onError, onComplete의 세가지 이벤트 타입 지원  
    - 값의 시퀀스를 표현하며, 값을 얻기 위해서는 Observable을 구독해야 함.  
    - 구독한 값은 각 이벤트마다 지정된 콜백 함수를 통해 전달받게 됨.  
2. 뜨거운 Observable과 차가운 Observable  
    - 차가운 Observable : 구독하면 처음부터 모든 정보를 순차적으로 얻을 수 있다.  
      - 함수형 프로그래밍에서의 리스트와 비슷함.  
      - Rx의 목표중 일부가 일반적인 함수형 프로그래밍을 위한 하부 구조를 함수형이 아닌 언어에 제공하는 것이기 때문에 이러한 것을 지원.  
    - 뜨거운 Observable : 구독한 시점 이후에 발생하는 이벤트를 받을 수 있다.  
      - Sodium의 Stream에 해당  
3. 상태 관리  
    - Rx에는 Cell에 해당하는 요소는 없지만, 다른 방법을 통해 비슷한 효과를 얻을 수 있다.  
    - scan() : 마지막으로 이벤트를 처리한 시점의 상태값을 유지하여 상태가 있는 누적기 제공  
        - 제공된 함수에 상태와 새로운 값이 전달되며, 이를 바탕으로 새로운 상태를 반환  
        - sodium의 accum()과 동등하며, 이는 hold-snapshot으로 구현할 수 있다.  
    - withLatestFrom() : 인자로 넘긴 Observable의 가장 최근 값을 가져옴.  
        - Observable을 Cell처럼 취급한 것, 명시적 변환 없이도 처리 가능하다는 특징이 있음  
        - 이전에 이벤트가 발생한 적이 없다면 아무것도 반환하지 않는다.  
    - BehaviorSubject : Sodium의 Cell에 대응하는 것으로 '현재 값'이라는 개념을 포함한다.  
        - 구독하면 현재 값이 즉시 콜백에 전달됨.  
        - 첫 값을 받은 이후에는 뜨거운 Observable로 전환.  
            > Rx에서의 전방참조  
            > - sodium에서 Cell의 전방참조는 Rx의 BehaviorSubject로 구현가능  
            > - Stream의 전방참조는 Subject로 가능  
    - startWith() : 구독하는 순간 초깃값 전달  
        - BehaviorSubject와 비슷하지만 '현재 값'이라는 개념이 없음  
        - 구독하면 항상 정해진 초기값을 전달함  
    - combineLatest() : 두 Observable로부터 현재 값을 조합  
        - sodium의 lift에 해당한다.  

### Rx의 오류들  

1. 글리치(glitch)문제 : FRP시스템에서 정의한 관계와 출력에서 관찰할 수 있는 내용이 다른 경우  
    - 동시 이벤트에서 관계가 복잡해질 때 이러한 문제가 나타난다.  
    - Rx는 이 글리치에서 자유롭지 못하다. Sodium은 이 문제를 해결했다.  
    - 프로젝트에서 어떤 시스템을 사용하기로 하고 자원 투자가 이루어졌다면, 해당 시스템의 글리치는 절대 수정할 수 없다.  
2. merge가 동시성 이벤트를 일관성 있게 다루지 못함.  
    - 이는 합성성의 부재로 인한 문제이다.  

> - Rx가 없애주는 리스너의 재앙들  
>    1. 예측 불가능한 순서 - 미해결  
>    2. 첫번째 이벤트 소실 - 해결  
>    3. 지저분한 상태 - 해결  
>    4. 스레드 문제 - 미해결(단, JS에는 스레드가 없으므로 아예 이런 문제가 없음)  
>    5. 콜백 누수 - 해결  
>    6. 의도치 않은 재귀 - 미해결  
>        - 콜백 내에서 이벤트를 Observable에 넣을 수 있도록 허용하기 때문에 재귀 발생 가능성이 있음  

### Rx로 I/O하기  

- 자신만의 뜨거운 Observable을 만들어낸다.  
    1. Observable을 만들고, 구독자에게 제공할 값을 처리할 함수를 넘긴다.  
    2. 비동기적인 I/O코드를 작성한 다음 onNext()로 값을 내보낸다.  
    3. publish()는 출력을 단일 출력 Stream으로 브로드캐스팅한다. 따라서  인스턴스가 1개만 존재하게 되며 구독자들은 같은 이벤트의 복제본은 받게 된다.
    4. connect()로 명시적으로 Observable을 시작해야 한다.  
- 직접 만든 뜨거운 Observable을 상태가 있는 로직이나 FRP 기본 요소 구현에 사용하지 말라.  
  - 합성성을 보장받기 위해서이다.  
- I/O 코드는 FRP 시스템 외부의 존재로 인식되어야 하며, 섞이지 않도록 특별한 주의를 기울여야 한다.  

### 기타 주의점  

- FRP가 하는 일 중 대부분은 정적 타입 지정(Static typing)의 능력을 활용한다.  
  - 동적 타입 지정에 얽메이지 않고 타입 추론을 잘해주는 정적 타입 언어를 적용해보자  

## Chapter7. 스위치 연산  

- 2장에서 언급하지 않은 나머지 기본 연산 2가지 : switch, sample  
  - sample : 셀의 값을 얻어냄  
    - Cell 내부의 값을 부득이하게 직접 넘겨야 할 때 사용  
    - Cell의 값은 시간에 따라 달라지므로 sample 연산은 참조 투명성을 만족하지 않는다.  
    - 다만 하나의 이벤트 안에서는 동일한 트랜잭션이므로 sample 또는 커스텀 FRP 로직을 사용할 수 있다.  
    - Cell을 직접 반환하는 lift, Cell.map 연산 안에서 sample을 사용하면 안된다.  
  - switch : 프로그램이 실행되는 동안 방향성 그래프를 동적으로 바꾸게 해 줌(유의어 : flatten, join)  
    - FRP 로직을 변경하기 위해 FRP 로직을 사용할 수 있게 해줌  
    - Stream 또는 Cell을 바꿔치기 할 수 있다.  
    - Switch할 때 바꿔치기 된 로직이 계속 참조되고 있다면 바꿔치기 된 로직이 메모리 누수의 원인이 된다.  
      - StreamLoop로 새로운 구현으로 바꿔치기 한다.  
      - once() 메소드를 이용해 Stream에서 이벤트가 1번만 발생하도록 한 뒤에, 이벤트가 발생하면 해제되도록 한다.  
    - 로직이 필요할 때마다 생성해주고, 필요 없어지면 제거할 수 있다. 이는 잘못된 상태를 만들지 않는데 도움이 된다.  
    - 이전 상태를 다른 곳에 Hold해놓음으로 상태간의 전환을 꾀할 수도 있다.  
- FRP가 기존의 방식에 비해 제약하는 것이 많다고 느껴질 수 있다.  
  - 하지만 기존의 프로그래밍 언어도 FRP와는 다르지만 제약이 있었다.  
  - FRP의 제약은 '우리가 사용하는 기계는 폰 노이만 구조이다'라는 가정을 하지 못하게 막는다.  
  - FRP는 우리에게 필요한 것을 제공하지만 우리가 원하는 방식대로 제공하지 않을 뿐이다.  
- FRP는 정적 타입을 사용하여 언어의 타입 시스템을 한계까지 몰아붙인다.  
  - 이러한 코드 정보는 컴파일하는 동안에 사라져서 기계는 아무런 추가 부하가 없다.  
  - 오히려 소스 코드에 더 많은 정보를 넣음으로써 사람에게 더 많은 정보를 제공한다.  
  - 다만 짧은 코드안에 많은 정보가 들어가므로 읽기가 어려울 수 있다.  
  - 중간 변수를 인라이닝 하거나, 타입 추론을 사용하면 좀 더 이해하기 쉽게 만들 수 있다.  
- merge의 효율  
  1. 순차적 merge - O(N)의 시간 복잡도  
  2. 재귀적인 merge(리스트를 계속 반으로 나눠 merge) - O(lg(N))의 시간 복잡도, 갱신이 잦으면 오버헤드가 큼  
  3. switch를 이용해 부분적으로만 재귀 merge  

## Chapter8. 조작적인 기본연산  

- 프로그래밍 과정 중에는 FRP의 핵심 개념과 잘 들어맞지 않는 부분이 존재한다.
  - 이 부분을 해결하기 위해 FRP는 조작적인 기본 연산을 제공한다.  
  - 하지만 이 부분은 FRP의 핵심 개념과는 동떨어져 있기 때문에 필요할 때만 제한적으로 써야한다.  

- FRP 코드를 프로그램의 나머지 부분과 연결하기  
  1. 이벤트를 Stream이나 Cell에 집어넣기  
      - StreamSink, CellSink는 각각 Stream,Cell의 하위 클래스로 Stream이나 Cell에 값을 보내거나 밀어넣을 수 있게 해준다.  
      - Stream이나 Cell에 값을 밀어넣기 전까지는 모든 I/O와 상태 변경을 수행할 수 있다. 즉, 참조 투명성이 적용되지 않는다.  
      - CellSink의 경우는 언제나 값이 존재해야 하기 때문에 초기값이 필요하다. 또 listener를 등록하자마자, Cell의 현재 값을 콜백으로 통지받는다.  
      - 값을 보내는 호출은 자체적인 트랜잭션 안에서 실행된다.  
      - 하나의 트랜잭션 안에서는 하나의 Stream에는 하나의 값만 보내는 게 허용되고, 마지막으로 보낸 값 이외에는 전부 무시되는 게 기본이다.  
      - 하나의 트랜잭션 안에서 스트림에 여러 값을 보내기 위해서는 값을 조합하기 위한 함수를 생성자에 넘겨야 한다.  
  2. Stream이나 Cell의 이벤트를 listen하기  
      - Listen()을 호출하면 Listener객체가 반환되며, 이 Listener 객체에 여러 Listener 객체들을 append할 수 있다.  
      - unlisten()을 호출해서 콜백을 명시적으로 해제한다. append된 것은 합쳐진 Listener를 해제하면 모두 해제된다.  
      - Sodium의 경우는, Listener를 명시적으로 해제하지 않으면 메모리 누수의 원인이 된다.  
  - Sodium에서 FRP와 다른 부분을 연결하는 규칙  
      1. FRP Listener 내부가 아니라면 send()를 호출해도 안전하다. 절대 블록되지 않는다.  
      2. FRP 로직에 넘기는 함수는 참조 투명성을 만족하는 한 뭐든 할 수 있다. 또한 Stream 이벤트를 처리하는 함수는 FRP로직을 만들어 내거나 Sample()을 사용할 수도 있다. 하지만 I/O는 금지된다.  
      3. Listener는 블록되거나 send()를 호출해서는 안된다. 하지만 다른 스레드에게 작업을 위임하는 일을 포함하는 논블로킹 I/O를 할 수는 있다.  
- 지연 연산(Lazy evaluation) : 아직 준비되지 않은 값을 사용하려 할 때는 오류가 나는데 오류를 방지, 값이 정말로 필요할 때 까지 연산을 미룸. 그 전까지는 값에 대한 프록시만 가지고 있음.  
- 트랜잭션 : 다른 FRP 시스템에서는 moment, instant라고도 불림. Rx계열에는 트랜잭션 개념이 없다.  
  1. Sodium에서는 명시적으로 호출하지 않으면 자동으로 트랜잭션을 실행한다.  
  2. 명시적으로 트랜잭션을 만들수도 있다. 빌려쓰기 패턴을 사용함으로 트랜잭션을 열고 닫지 않는 실수를 막아준다.  
  - 트랜잭션의 실행 단계  
      1. 모든 Stream 이벤트를 동시에 처리하기  
      2. 모든 Cell 값을 원자적으로 갱신하기  
    - 이벤트 처리 단계에서는 Cell의 값이 변하지 않기 때문에 각 이벤트가 모두 동시적으로 일어난다고 여길 수가 있다.  
- 명시적 트랜잭션 안에서 FRP 로직 만들기  
  - 초기화 로직을 큰 트랜잭션 하나로 감싸는 방식이 권장된다. 이는 그 트랜잭션 안에서 I/O가 일어날 수 있음을 암시한다.  
    - 일반적으로는 I/O와 FRP를 구분해야 하지만, 초기화 과정에서 하는 것은 문제가 되지 않는다.  
    - Sodium에서는 한 트랜잭션 안에서 한 Stream에 대해 listen과 send를 모두 호출하는 경우 연산 순서에 관계없이 send로 보낸 값이 보이는 것을 보장한다.  
      - 이는 최초의 이벤트를 잃어버리는 재앙을 제거할 수 있다.  
- FRP에서 시간 모델 : Stream은 두 모델 모두 동일, Cell에서만 차이를 보임  
    1. 이산적인 시간 : Sodium에서 주로 촛점을 맞추는 모델  
    2. 연속적인 시간  
      - 연속적으로 변화하는 Cell이라는 개념을 보호하기 위해서는 Cell값의 변화를 관찰할 수 없어야 한다. 즉 Cell을 Stream으로 변환할 수 없어야 한다.  
- update와 value  
    1. update : Cell의 이산적인 변화를 반환, hold의 역.  
        - Cell의 변화를 관찰할 수 없다는 규칙을 위해서는 update를 사용하는 함수가 자신의 호출자에게 Cell의 단계를 노출하면 안된다.  
        - listen하기 시작한 트랜잭션이나 그 이후에 발생한 변화만을 돌려줌  
    2. value : 현재 트랜잭션 안에서 Cell의 현재 값을 이벤트로 발사.  
        - Sodium의 기본 연산들은 자기 자신만을 포함하는 트랜잭션을 자동으로 만들기 때문에 다른 연산과 같은 트랜잭션으로 묶어두지 않으면 값이 사라진다.  
- split : 데이터 패킷을 쪼개서 각각의 쪼개진 패킷을 별도의 트랜잭션을 만들어 처리  
  - 기존에 있던 트랜잭션이 사라지지는 않는다.  
  - split안에서 split을 호출할 수도 있다.  
- defer : 어떤 이벤트 하나를 새로운 트랜잭션에 넣는 것  
  - 리스트 대신에 단일 이벤트를 대상으로 하는 split의 변종으로 구현  
  - Cell 상태의 새로운 버젼을 읽을 수 있는 방법을 제공함  
  - 실제로는 이벤트의 출력 시점을 뒤로 미루는 게 아니라 이벤트를 당기는 효과가 있음. 이벤트가 원래의 다음번 트랜잭션의 앞에 또 다른 트랜잭션을 만들어 넘기는 것이기 때문  
- defer 나 split은 동시에 여러번 써도 한번의 트랜잭션만 만들어진다. 여러 개가 만들어지면 그 순서를 정하는 것이 문제가 되기 때문이다.  
  - 프로그램에서 남용하게 되면 동시성 문제를 일으킬 수 있다.  

### 정리  

- listen과 send는 FRP와 외부 세계와의 인터페이스를 제공한다.  
- update,value,split,defer 이 4가지 연산은 모두 조작적인 연산이므로 힙성성을 깰 여지가 있다.  
  - 따라서 조심스럽게 사용되어야 하고, 조작적인 연산을 할 때만 사용해야 한다.  
- split과 defer는 새로운 트랜잭션을 만들어 낼 수 있는 능력이 있다.  
  - 다만, 남용하면 동시성 문제가 일어나니 조심스럽게 사용해야 한다.  

## Chapter9. 연속적인 시간  

- FRP에서는 독립적인 애니메이션을 정의하고, 원하는 프레임 비율로 추출할 수가 있다.  
  - 레스터 이미지와 벡터 이미지를 생각하면 편할 것이다. 단지 공간이 아닌 시간에 대한 것일 뿐이다.  